{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simulations of reforms to employer contributions from the \"Bozio-Wasmer\" report","text":"<p>This directory contains all the programs used to simulate the reforms presented in the \"Bozio-Wasmer\" report and their outcomes.</p>"},{"location":"#objectives","title":"Objectives","text":"<p>This package is built to quantify different outcomes of employer contributions :</p> <ul> <li> <p>Empirically :</p> <ul> <li>To quantify budget costs (static and \"first-round\" after application of the employment effects) associated with each reform</li> <li>To estimate employment effects of the reform</li> </ul> </li> <li> <p>Theoretically :</p> <ul> <li>To estimate incentives to increase wages</li> <li>To estimate the impact of adding the \"prime de partage de la valeur\" to the basis for reducing contributions</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#package-and-dependencies","title":"Package and dependencies","text":"<pre><code>git clone &lt;toolbox_repo_url&gt;\npip install -e igf_toolbox_python\n\ngit clone &lt;repo_url&gt;\npip install -e bozio_wasmer_simulations\n</code></pre> <p>The package is then usable as any other python package.</p>"},{"location":"#parametrisation","title":"Parametrisation","text":"<p>File in the <code>config.yaml</code> file : <pre><code>CASD :\n  PROJET : \"INGENFI\"\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>Here's an example of how to use the functions in the package:</p> <pre><code>from bozio_wasmer_simulations import CaptationMarginaleSimulator\n\n# Create a simulator object\nsimulator = CaptationMarginaleSimulator()\n\n# Define a dictionary of reform parameters\nreform_params = {\n    'TYPE': 'fillon',\n    'PARAMS': {\n        'PLAFOND': 2.7,\n        'TAUX_50_SALARIES_ET_PLUS': 0.35,\n        'TAUX_MOINS_DE_50_SALARIES': 0.354\n    }\n}\n\n# Simulate a reform\ndata_simul = simulator.simulate_reform(\n  name='my_reform', \n  reform_params=reform_params, \n  year=2022, \n  simulation_step_smic=0.1, \n  simulation_max_smic=4\n)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>The package is licensed under the MIT License.</p>"},{"location":"api/CaptationMarginaleSimulator/","title":"CaptationMarginaleSimulator","text":""},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator","title":"CaptationMarginaleSimulator","text":"<p>A class for simulating marginal capture rates.</p> <p>This class inherits from TheoreticalSimulator and CoreSimulation and provides methods for calculating the marginal capture rate, preprocessing the gross salary, building the columns for the DADS data, preprocessing the DADS data for simulation, simulating the marginal capture rate, simulating a reform, simulating multiple reforms, building the weights for the simulation, building the dataset, and calculating a synthetic rate.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger for logging messages.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>class CaptationMarginaleSimulator(TheoreticalSimulator, CoreSimulation):\n    \"\"\"\n    A class for simulating marginal capture rates.\n\n    This class inherits from TheoreticalSimulator and CoreSimulation and provides methods for calculating the marginal capture rate,\n    preprocessing the gross salary, building the columns for the DADS data, preprocessing the DADS data for simulation,\n    simulating the marginal capture rate, simulating a reform, simulating multiple reforms, building the weights for the simulation,\n    building the dataset, and calculating a synthetic rate.\n\n    Attributes:\n        logger (logging.Logger):\n            A logger for logging messages.\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        project: str,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[3], \"logs/captation_marginale_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the ReformSimulation object.\n\n        Args:\n            project (str): The name of the CASD project\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/captation_marginale_simulation.log').\n\n        \"\"\"\n        # Initialisation du simulateur\n        TheoreticalSimulator.__init__(self, log_filename=log_filename)\n        CoreSimulation.__init__(self, project=project, log_filename=log_filename)\n\n\n    # Fonction auxiliaire de calcul du taux de captation marginal\n    def _calculate_taux_captation_marginal(\n        self, data: pd.DataFrame, name: Union[str, None]\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Calculates the marginal capture rate.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            name (Union[str, None]):\n                The name of the scenario.\n\n        Returns:\n            (pd.DataFrame): The input data with the marginal capture rate calculated.\n        \"\"\"\n        # Calcul des \\delta S_NET / \\delta Co\u00fbt du travail\n        if (name is None) | (name == \"\"):\n            data[\"taux_captation_marginal\"] = (\n                data[\"salaire_net\"].shift(-1) - data[\"salaire_net\"]\n            ) / (data[\"salaire_super_brut\"].shift(-1) - data[\"salaire_super_brut\"])\n            data[\"taux_captation_marginal\"] = data[\"taux_captation_marginal\"].fillna(\n                method=\"ffill\"\n            )\n        else:\n            data[f\"taux_captation_marginal_{name}\"] = (\n                data[\"salaire_net\"].shift(-1) - data[\"salaire_net\"]\n            ) / (\n                data[f\"salaire_super_brut_{name}\"].shift(-1)\n                - data[f\"salaire_super_brut_{name}\"]\n            )\n            data[f\"taux_captation_marginal_{name}\"] = data[\n                f\"taux_captation_marginal_{name}\"\n            ].fillna(method=\"ffill\")\n\n        return data\n\n    # Fonction auxiliaire de preprocessing du salaire de base\n    def _preprocess_salaire_de_base(\n        self, data: pd.DataFrame, year: int, name: str\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Preprocesses the gross salary.\n\n        Expresses the gross salary as a proportion of the SMIC and drops the unnecessary columns.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            year (int):\n                The year for which the data is being processed.\n            name (str):\n                The name of the scenario.\n\n        Returns:\n            (pd.DataFrame): The preprocessed data.\n        \"\"\"\n        # Expression du salaire en proportion du SMIC\n        data[\"salaire_de_base_prop_smic\"] = data[\"salaire_de_base\"] / self.value_smic(\n            year=year\n        )\n        # Liste des variables \u00e0 conserver\n        list_var_keep = (\n            [\"salaire_de_base\", \"salaire_de_base_prop_smic\", \"taux_captation_marginal\"]\n            if ((name is None) | (name == \"\"))\n            else [\n                \"salaire_de_base\",\n                \"salaire_de_base_prop_smic\",\n                f\"taux_captation_marginal_{name}\",\n            ]\n        )\n        # Suppression des variables inutiles\n        data.drop(\n            np.setdiff1d(data.columns.tolist(), list_var_keep), axis=1, inplace=True\n        )\n\n        return data\n\n    # Fonction auxiliaire de construction des colonnes des DADS\n    def columns_dads(self, year: int) -&gt; List[str]:\n        \"\"\"\n        Returns the columns to keep from the DADS data.\n\n        Args:\n            year (int):\n                The year for which the data is being processed.\n\n        Returns:\n            (List[str]): The columns to keep from the DADS data.\n        \"\"\"\n        # Liste des variables \u00e0 conserver lors de l'import\n        return params[\"DADS\"][\"COLONNES_CAPTATION_MARGINALE\"]\n\n    # Fonction auxiliaire de preprocessing des DADS en vue d'une branchement avec openfisca\n    def preprocess_dads_simulation(self, year: int) -&gt; None:\n        \"\"\"\n        Preprocesses the DADS data for simulation.\n\n        Args:\n            year (int):\n                The year for which the data is being processed.\n        \"\"\"\n        # Simulation du SMIC proratis\u00e9\n        # Construction des variables d'int\u00e9r\u00eat\n        # Conversion de la de la date de d\u00e9but de contrat de travail en datetime\n        self.data_dads[\"date_fin_contrat\"] = (\n            pd.to_datetime(f\"{year}-01-01\", format=\"%Y-%m-%d\")\n            + pd.to_timedelta(arg=self.data_dads[\"datfin\"], unit=\"D\")\n        ).dt.strftime(\"%Y-%m-%d\")\n        self.data_dads[\"contrat_de_travail_fin\"] = np.where(\n            self.data_dads[\"datfin\"] &lt; 360,\n            self.data_dads[\"date_fin_contrat\"],\n            \"2099-12-31\",\n        )\n        # Conersion en string\n        self.data_dads[\"date_debut_contrat\"] = (\n            pd.to_datetime(self.data_dads[\"date_debut_contrat\"], format=\"%Y-%m-%d\")\n            .dt.strftime(\"%Y-%m-%d\")\n            .fillna(\"1970-01-01\")\n        )\n        # Renomination de certaines variables\n        self.data_dads.rename(\n            {\n                \"date_debut_contrat\": \"contrat_de_travail_debut\",\n                \"nbheur\": \"heures_remunerees_volume\",\n                \"brut_s\": \"salaire_de_base\",\n            },\n            axis=1,\n            inplace=True,\n        )\n        # Ajout de la r\u00e9mun\u00e9ration de l'apprenti\n        self.data_dads[\"remuneration_apprenti\"] = 0\n        # Expression du salaire de base en fonction du SMIC\n        self.data_dads[\"salaire_de_base_prop_smic\"] = self.data_dads[\n            \"salaire_de_base\"\n        ] / self.value_smic(year=year)\n\n        # Suppression des colonnes inutiles\n        self.data_dads.drop(\n            np.setdiff1d(\n                self.columns_dads(year=year) + [\"date_fin_contrat\"],\n                [\"ident_s\", \"siren\", \"eqtp\", \"brut_s\", \"date_debut_contrat\", \"nbheur\"],\n            ).tolist(),\n            axis=1,\n            inplace=True,\n        )\n\n        # Logging\n        self.logger.info(\n            \"Successfully preprocessed data_dads to connect it with openfisca\"\n        )\n\n    # Fonction auxiliaire de simulation du taux marginal\n    def simulate(\n        self, year: int, simulation_step_smic: float, simulation_max_smic: float\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates the marginal capture rate.\n\n        Initializes the simulation case, initializes the tax-benefit system,\n        simulates the variables, postprocesses the simulated variables,\n        calculates the marginal capture rate, and preprocesses the gross salary.\n\n        Args:\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n        \"\"\"\n        # Initialisation du cas de simulation\n        self.init_base_case(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Initialisation du syst\u00e8me socio-fiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n        # Extraction des variables \u00e0 simuler\n        list_var_simul = params[\"VARIABLES_CAPTATION_MARGINALE\"]\n        # Simulation\n        data_simul = self.base_case_simulation(\n            tax_benefit_system=tax_benefit_system,\n            year=year,\n            list_var_simul=list_var_simul,\n        )\n        # Retraitement des variables simul\u00e9es\n        data_simul = preprocess_simulated_variables(data=data_simul)\n        # Calcul du taux marginal\n        data_simul = self._calculate_taux_captation_marginal(data=data_simul, name=None)\n        # Retraitement du salaire de base\n        data_simul = self._preprocess_salaire_de_base(\n            data=data_simul, year=year, name=None\n        )\n\n        return data_simul\n\n    # Fonction auxiliaire de simulation d'une r\u00e9forme\n    def simulate_reform(\n        self,\n        name: str,\n        reform_params: dict,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates a reform.\n\n        Initializes the simulation case, initializes the tax-benefit system,\n        applies the reform, simulates the variables, postprocesses the simulated variables,\n        calculates the marginal capture rate, and preprocesses the gross salary.\n\n        Args:\n            name (str):\n                The name of the reform.\n            reform_params (dict):\n                The parameters of the reform.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n        \"\"\"\n        # Initialisation du cas de simulation\n        if not hasattr(self, \"base_case\"):\n            self.init_base_case(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n            )\n\n        # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n\n        # Application de la r\u00e9forme\n        reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n            tax_benefit_system=tax_benefit_system, dict_params=reform_params\n        )\n\n        # Logging\n        self.logger.info(\"Successfully updated the tax-benefit system\")\n\n        # Extraction du type de la r\u00e9forme\n        reform_type = reform_params[\"TYPE\"]\n\n        # It\u00e9ration de la simulation\n        data_simul = self.base_case_simulation(\n            tax_benefit_system=reformed_tax_benefit_system,\n            year=year,\n            list_var_simul=params[\"VARIABLES_CAPTATION_MARGINALE\"]\n            + [f\"new_allegement_{reform_type}\"],\n        )\n\n        # Retraitement des variables simul\u00e9es\n        data_simul = preprocess_simulated_variables(data=data_simul)\n\n        # Construction du nouveau salaire super brut\n        data_simul[f\"salaire_super_brut_{name}\"] = (\n            data_simul[\n                [\n                    \"salaire_super_brut\",\n                    \"allegement_general\",\n                    \"allegement_cotisation_maladie\",\n                    \"allegement_cotisation_allocations_familiales\",\n                ]\n            ].sum(axis=1)\n            - data_simul[f\"new_allegement_{reform_type}\"]\n        )\n\n        # Calcul du taux marginal\n        data_simul = self._calculate_taux_captation_marginal(data=data_simul, name=name)\n\n        # Retraitement du salaire de base\n        data_simul = self._preprocess_salaire_de_base(\n            data=data_simul, year=year, name=name\n        )\n\n        return data_simul\n\n    # Fonction auxiliaire de simulation de plusieurs r\u00e9formes th\u00e9oriques\n    def iterate_reform_simulations(\n        self,\n        scenarios: dict,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates multiple reforms.\n\n        Iterates over the scenarios and simulates each reform.\n        Concatenates the simulated data for all reforms.\n\n        Args:\n            scenarios (dict):\n                The scenarios to simulate.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n\n        Returns:\n            (pd.DataFrame): The simulated data for all reforms.\n        \"\"\"\n        # Initialisation de la liste r\u00e9sultat\n        list_data_simul = []\n        # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n        for i, scenario in tqdm(enumerate(scenarios.keys())):\n            # It\u00e9ration des r\u00e9formes\n            data_simul = self.simulate_reform(\n                name=scenario.lower(),\n                reform_params=scenarios[scenario],\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n            )\n            # Ajout \u00e0 la liste r\u00e9sultat\n            if i &gt; 0:\n                list_data_simul.append(\n                    data_simul.drop(\n                        [\"salaire_de_base\", \"salaire_de_base_prop_smic\"], axis=1\n                    )\n                )\n            else:\n                list_data_simul.append(data_simul)\n        # Concat\u00e9nation\n        data_simul = pd.concat(list_data_simul, axis=1, join=\"outer\")\n\n        return data_simul\n\n    # Fonction auxiliaire de construction des poids\n    def build_weights_simulation(\n        self,\n        data_simul: pd.DataFrame,\n        year: int,\n        simulation_max_smic: float,\n        list_var_groupby: Optional[List[str]] = [\"salaire_de_base_prop_smic\"],\n    ) -&gt; Tuple[pd.DataFrame, pd.DataFrame]:\n        \"\"\"\n        Builds the weights for the simulation.\n\n        Args:\n            data_simul (pd.DataFrame):\n                The simulated data.\n            year (int):\n                The year for which the data is being processed.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            list_var_groupby (Optional[List[str]], optional):\n                The variables to group by, by default ['salaire_de_base_prop_smic']\n\n        Returns:\n            (Tuple[pd.DataFrame, pd.DataFrame]): The descriptive statistics and the secret statistics.\n        \"\"\"\n        # Construction du jeu de donn\u00e9es data_dads s'il n'est pas d\u00e9j\u00e0 en argument\n        if not hasattr(self, \"data_dads\"):\n            self.build_data_dads(year=year)\n\n        # Cr\u00e9ation de tranches de salaires\n        self.data_dads[\"salaire_de_base_prop_smic\"] = pd.to_numeric(\n            pd.cut(\n                x=self.data_dads[\"salaire_de_base_prop_smic\"],\n                bins=data_simul[\"salaire_de_base_prop_smic\"].tolist(),\n                labels=data_simul[\"salaire_de_base_prop_smic\"].tolist()[:-1],\n                include_lowest=True,\n            )\n        )\n        # Restriction aux salaires inf\u00e9rieurs \u00e0 4 SMIC\n        self.data_dads = self.data_dads.loc[\n            self.data_dads[\"salaire_de_base_prop_smic\"] &lt;= simulation_max_smic\n        ]\n\n        # Initialisation de l'estimateur de statistiques descriptives\n        estimator = SecretStatEstimator(\n            data_source=self.data_dads, \n            list_var_groupby=list_var_groupby, \n            list_var_of_interest=[\"eqtp\", \"salaire_de_base\"], \n            var_individu=\"ident_s\", \n            var_entreprise=\"siren\", \n            var_weights=\"weights\", \n            threshold_secret_stat_effectif_individu=5, \n            threshold_secret_stat_effectif_entreprise=3, \n            threshold_secret_stat_contrib_individu=0.8, \n            threshold_secret_stat_contrib_entreprise=0.85, \n            strategy='total'\n        )\n        # Construction de la statistique descriptive et du contr\u00f4le du secret statistique\n        data_stat_des, data_secret_stat = estimator.estimate_secret_stat(\n            iterable_operations=[\"sum\"], \n            include_total=False, \n            drop=False, \n            fill_value=np.nan, \n            nest=False\n        )\n\n        return data_stat_des, data_secret_stat\n\n    # M\u00e9thode construisant le jeu de donn\u00e9es avec les variables simul\u00e9es\n    def build(\n        self,\n        year_data: int,\n        year_simul: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        scenarios: Optional[Union[dict, None]] = None,\n        data: Optional[Union[pd.DataFrame, None]] = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Builds the dataset.\n\n        Loads the data, preprocesses it, adds weights, simulates the variables,\n        simulates the reforms, builds the weights, and returns the dataset.\n\n        Args:\n            year_data (int):\n                The year of the data.\n            year_simul (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            scenarios (Optional[Union[dict, None]], optional):\n                The scenarios to simulate, by default None\n            data (Optional[Union[pd.DataFrame, None]], optional):\n                The data, by default None\n\n        Returns:\n            (pd.DataFrame): The dataset.\n        \"\"\"\n        # Chargement du jeu de donn\u00e9es\n        self.build_data_dads(data=data, year=year_data)\n        # Preprocessing\n        self.preprocess_dads_simulation(year=year_data)\n        # Ajout des poids\n        self.add_weights(year_data=year_data, year_simul=year_simul)\n        # Simulation des variables\n        data_simul = self.simulate(\n            year=year_simul,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # It\u00e9ration des r\u00e9formes\n        if scenarios is not None:\n            data_simul = pd.concat(\n                [\n                    data_simul,\n                    self.iterate_reform_simulations(\n                        scenarios=scenarios,\n                        year=year_simul,\n                        simulation_step_smic=simulation_step_smic,\n                        simulation_max_smic=simulation_max_smic,\n                    ).drop([\"salaire_de_base\", \"salaire_de_base_prop_smic\"], axis=1),\n                ],\n                axis=1,\n                join=\"outer\",\n            )\n        # Construction des poids\n        data_stat_des, data_secret_stat = self.build_weights_simulation(\n            data_simul=data_simul,\n            year=year_simul,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Concat\u00e9nation avec les EQTP et la masse salariale par tranche\n        data_simul = pd.concat(\n            [\n                data_simul.set_index(\"salaire_de_base_prop_smic\"),\n                data_stat_des.drop,\n            ],\n            axis=1,\n            join=\"inner\",\n        ).reset_index()\n\n        # Logging\n        self.logger.info(\"Successfully build simulated DataFrame\")\n\n        return data_simul\n\n    # Fonction auxiliaire calculant un taux synt\u00e9htique\n    def build_taux_synthetique(\n        self,\n        data: pd.DataFrame,\n        elasticite: int,\n        names: List[str],\n        weights: Optional[List[str]] = [\"eqtp_sum\", \"salaire_de_base_sum\"],\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Calculates a synthetic rate.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            elasticite (int):\n                The elasticity.\n            names (List[str]):\n                The names of the scenarios.\n            weights (Optional[List[str]], optional):\n                The weights, by default ['eqtp_sum', 'salaire_de_base_sum']\n\n        Returns:\n            (pd.DataFrame): The synthetic rate.\n\n        Raises:\n            ValueError: If the input data does not contain the necessary columns.\n        \"\"\"\n        # V\u00e9rification que les les colonnes n\u00e9cessaires sont bien pr\u00e9sentes dans le jeu de donn\u00e9es\n        missing_columns = np.setdiff1d(\n            weights\n            + [\"taux_captation_marginal\"]\n            + [f\"taux_captation_marginal_{name.lower()}\" for name in names],\n            data.columns.tolist(),\n        ).tolist()\n        if missing_columns != []:\n            # Logging\n            self.logger.error(\n                f\"Given DataFrame should contain {missing_columns} as columns\"\n            )\n            # Erreur\n            raise ValueError(\n                f\"Given DataFrame should contain {missing_columns} as columns\"\n            )\n\n        # Initialisation du jeu de donn\u00e9es r\u00e9sultat\n        data_res = pd.DataFrame(data=0, index=weights, columns=names)\n        # Compl\u00e9tion du jeu de donn\u00e9es\n        for weight in weights:\n            for name in names:\n                data_res.loc[weight, name] = (\n                    elasticite\n                    * (\n                        data[f\"taux_captation_marginal_{name.lower()}\"]\n                        / data[\"taux_captation_marginal\"]\n                        - 1\n                    )\n                    .multiply(other=data[weight])\n                    .sum()\n                    / data[weight].sum()\n                )\n\n        return data_res\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.zonage_zrd","title":"zonage_zrd  <code>property</code>","text":"<pre><code>zonage_zrd: List[str]\n</code></pre> <p>Imports the defense restructuring zones (ZRD) zoning.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of defense restructuring zones.</p>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.zonage_zrr","title":"zonage_zrr  <code>property</code>","text":"<pre><code>zonage_zrr: List[str]\n</code></pre> <p>Imports the rural revitalization zones (ZRR) zoning.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of rural revitalization zones.</p>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.add_weights","title":"add_weights","text":"<pre><code>add_weights(year_data: int, year_simul: int) -&gt; None\n</code></pre> <p>Adds weights to the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year_data</code> <code>int</code> <p>The year of the data.</p> required <code>year_simul</code> <code>int</code> <p>The year of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def add_weights(self, year_data: int, year_simul: int) -&gt; None:\n    \"\"\"\n    Adds weights to the DADS data.\n\n    Args:\n        year_data (int): The year of the data.\n        year_simul (int): The year of the simulation.\n\n    Returns:\n        None\n    \"\"\"\n    # Simulation du SMIC proratis\u00e9\n    # Simulation\n    self.data_dads = self.simulate_smic_proratise(\n        data=self.data_dads, year=year_data, list_var_exclude=[], inplace=True\n    )\n\n    # Si l'ann\u00e9e des donn\u00e9es ne coincide pas avec l'ann\u00e9e des simulations, on met \u00e0 jour les salaires pour qu'il corresponde au m\u00eame niveau de SMIC\n    if year_data != year_simul:\n        # Renomination de la colonne simul\u00e9e\n        self.data_dads.rename(\n            {\"smic_proratise\": f\"smic_proratise_{year_data}\"}, axis=1, inplace=True\n        )\n        # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e de simulation\n        self.data_dads = self.simulate_smic_proratise(\n            data=self.data_dads, year=year_simul, list_var_exclude=[], inplace=True\n        )\n        # Correction des salaires\n        # Salaire en proportion du SMIC\n        self.data_dads[\"salaire_brut_smic\"] = (\n            self.data_dads[[\"salaire_de_base\", \"remuneration_apprenti\"]].sum(axis=1)\n            / self.data_dads[f\"smic_proratise_{year_data}\"]\n        )\n        # Actualisation des r\u00e9umn\u00e9rations\n        self.data_dads[\"salaire_de_base\"] = np.where(\n            self.data_dads[\"salaire_de_base\"] &gt; 0,\n            self.data_dads[\"salaire_brut_smic\"] * self.data_dads[\"smic_proratise\"],\n            0,\n        )\n        self.data_dads[\"remuneration_apprenti\"] = np.where(\n            self.data_dads[\"remuneration_apprenti\"] &gt; 0,\n            self.data_dads[\"salaire_brut_smic\"] * self.data_dads[\"smic_proratise\"],\n            0,\n        )\n        # Suppression du SMIC proratis\u00e9 initialement calcul\u00e9\n        self.data_dads.drop(f\"smic_proratise_{year_data}\", axis=1, inplace=True)\n    # Recr\u00e9ation d'un salaire brut\n    self.data_dads[\"brut_s\"] = self.data_dads[\n        [\"salaire_de_base\", \"remuneration_apprenti\"]\n    ].sum(axis=1)\n    # Ajout des poids\n    self.data_dads = add_weights_eqtp_accos(\n        data_dads=self.data_dads,\n        year=year_simul,\n        var_eqtp=\"eqtp\",\n        var_sal_brut=\"brut_s\",\n        var_smic_proratise=\"smic_proratise\",\n    )\n    # Suppression de la colonne de salaire brut\n    self.data_dads.drop(\"brut_s\", axis=1, inplace=True)\n\n    # Logging\n    self.logger.info(\"Successfully added accoss weights to data_dads\")\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.base_case_simulation","title":"base_case_simulation","text":"<pre><code>base_case_simulation(tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]) -&gt; DataFrame\n</code></pre> <p>Performs a simulation on the base case.</p> <p>Parameters:</p> Name Type Description Default <code>tax_benefit_system</code> <code>TaxBenefitSystem</code> <p>The tax-benefit system to use for the simulation.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>A list of variables to simulate.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing the results of the simulation.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def base_case_simulation(\n    self, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Performs a simulation on the base case.\n\n    Args:\n        tax_benefit_system (TaxBenefitSystem):\n            The tax-benefit system to use for the simulation.\n        year (int):\n            The year for which the simulation is performed.\n        list_var_simul (List[str]):\n            A list of variables to simulate.\n\n    Returns:\n        (pd.DataFrame): A dataframe containing the results of the simulation.\n    \"\"\"\n    # Initialisation des param\u00e8tres de la simulation\n    simulation_builder = SimulationBuilder()\n    simulation = simulation_builder.build_from_entities(\n        tax_benefit_system, self.base_case\n    )\n    # Initialisation du dictionnaire r\u00e9sultat\n    dict_simul = {}\n    # It\u00e9ration sur la liste des variables \u00e0 simuler\n    for variable in list_var_simul:\n        dict_simul[variable] = simulation.calculate_add(variable, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {variable} for period {year}\")\n    # Conversion en dataFrame\n    data_simul = pd.DataFrame(dict_simul)\n\n    return data_simul\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.build","title":"build","text":"<pre><code>build(year_data: int, year_simul: int, simulation_step_smic: float, simulation_max_smic: float, scenarios: Optional[Union[dict, None]] = None, data: Optional[Union[DataFrame, None]] = None) -&gt; DataFrame\n</code></pre> <p>Builds the dataset.</p> <p>Loads the data, preprocesses it, adds weights, simulates the variables, simulates the reforms, builds the weights, and returns the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>year_data</code> <code>int</code> <p>The year of the data.</p> required <code>year_simul</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>scenarios</code> <code>Optional[Union[dict, None]]</code> <p>The scenarios to simulate, by default None</p> <code>None</code> <code>data</code> <code>Optional[Union[DataFrame, None]]</code> <p>The data, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The dataset.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def build(\n    self,\n    year_data: int,\n    year_simul: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    scenarios: Optional[Union[dict, None]] = None,\n    data: Optional[Union[pd.DataFrame, None]] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Builds the dataset.\n\n    Loads the data, preprocesses it, adds weights, simulates the variables,\n    simulates the reforms, builds the weights, and returns the dataset.\n\n    Args:\n        year_data (int):\n            The year of the data.\n        year_simul (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        scenarios (Optional[Union[dict, None]], optional):\n            The scenarios to simulate, by default None\n        data (Optional[Union[pd.DataFrame, None]], optional):\n            The data, by default None\n\n    Returns:\n        (pd.DataFrame): The dataset.\n    \"\"\"\n    # Chargement du jeu de donn\u00e9es\n    self.build_data_dads(data=data, year=year_data)\n    # Preprocessing\n    self.preprocess_dads_simulation(year=year_data)\n    # Ajout des poids\n    self.add_weights(year_data=year_data, year_simul=year_simul)\n    # Simulation des variables\n    data_simul = self.simulate(\n        year=year_simul,\n        simulation_step_smic=simulation_step_smic,\n        simulation_max_smic=simulation_max_smic,\n    )\n    # It\u00e9ration des r\u00e9formes\n    if scenarios is not None:\n        data_simul = pd.concat(\n            [\n                data_simul,\n                self.iterate_reform_simulations(\n                    scenarios=scenarios,\n                    year=year_simul,\n                    simulation_step_smic=simulation_step_smic,\n                    simulation_max_smic=simulation_max_smic,\n                ).drop([\"salaire_de_base\", \"salaire_de_base_prop_smic\"], axis=1),\n            ],\n            axis=1,\n            join=\"outer\",\n        )\n    # Construction des poids\n    data_stat_des, data_secret_stat = self.build_weights_simulation(\n        data_simul=data_simul,\n        year=year_simul,\n        simulation_max_smic=simulation_max_smic,\n    )\n    # Concat\u00e9nation avec les EQTP et la masse salariale par tranche\n    data_simul = pd.concat(\n        [\n            data_simul.set_index(\"salaire_de_base_prop_smic\"),\n            data_stat_des.drop,\n        ],\n        axis=1,\n        join=\"inner\",\n    ).reset_index()\n\n    # Logging\n    self.logger.info(\"Successfully build simulated DataFrame\")\n\n    return data_simul\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.build_data_dads","title":"build_data_dads","text":"<pre><code>build_data_dads(year: int, data: Optional[Union[DataFrame, None]] = None) -&gt; None\n</code></pre> <p>Builds the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <code>data</code> <code>Optional[Union[DataFrame, None]]</code> <p>The data. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def build_data_dads(\n    self, year: int, data: Optional[Union[pd.DataFrame, None]] = None\n) -&gt; None:\n    \"\"\"\n    Builds the DADS data.\n\n    Args:\n        year (int): The year.\n        data (Optional[Union[pd.DataFrame, None]], optional): The data. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    if data is not None:\n        self._build_data_dads_from_dataframe(data=data, year=year)\n    else:\n        self.data_dads = self._init_data_dads(year=year)\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.build_taux_synthetique","title":"build_taux_synthetique","text":"<pre><code>build_taux_synthetique(data: DataFrame, elasticite: int, names: List[str], weights: Optional[List[str]] = ['eqtp_sum', 'salaire_de_base_sum']) -&gt; DataFrame\n</code></pre> <p>Calculates a synthetic rate.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The input data.</p> required <code>elasticite</code> <code>int</code> <p>The elasticity.</p> required <code>names</code> <code>List[str]</code> <p>The names of the scenarios.</p> required <code>weights</code> <code>Optional[List[str]]</code> <p>The weights, by default ['eqtp_sum', 'salaire_de_base_sum']</p> <code>['eqtp_sum', 'salaire_de_base_sum']</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The synthetic rate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data does not contain the necessary columns.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def build_taux_synthetique(\n    self,\n    data: pd.DataFrame,\n    elasticite: int,\n    names: List[str],\n    weights: Optional[List[str]] = [\"eqtp_sum\", \"salaire_de_base_sum\"],\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates a synthetic rate.\n\n    Args:\n        data (pd.DataFrame):\n            The input data.\n        elasticite (int):\n            The elasticity.\n        names (List[str]):\n            The names of the scenarios.\n        weights (Optional[List[str]], optional):\n            The weights, by default ['eqtp_sum', 'salaire_de_base_sum']\n\n    Returns:\n        (pd.DataFrame): The synthetic rate.\n\n    Raises:\n        ValueError: If the input data does not contain the necessary columns.\n    \"\"\"\n    # V\u00e9rification que les les colonnes n\u00e9cessaires sont bien pr\u00e9sentes dans le jeu de donn\u00e9es\n    missing_columns = np.setdiff1d(\n        weights\n        + [\"taux_captation_marginal\"]\n        + [f\"taux_captation_marginal_{name.lower()}\" for name in names],\n        data.columns.tolist(),\n    ).tolist()\n    if missing_columns != []:\n        # Logging\n        self.logger.error(\n            f\"Given DataFrame should contain {missing_columns} as columns\"\n        )\n        # Erreur\n        raise ValueError(\n            f\"Given DataFrame should contain {missing_columns} as columns\"\n        )\n\n    # Initialisation du jeu de donn\u00e9es r\u00e9sultat\n    data_res = pd.DataFrame(data=0, index=weights, columns=names)\n    # Compl\u00e9tion du jeu de donn\u00e9es\n    for weight in weights:\n        for name in names:\n            data_res.loc[weight, name] = (\n                elasticite\n                * (\n                    data[f\"taux_captation_marginal_{name.lower()}\"]\n                    / data[\"taux_captation_marginal\"]\n                    - 1\n                )\n                .multiply(other=data[weight])\n                .sum()\n                / data[weight].sum()\n            )\n\n    return data_res\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.build_weights_simulation","title":"build_weights_simulation","text":"<pre><code>build_weights_simulation(data_simul: DataFrame, year: int, simulation_max_smic: float, list_var_groupby: Optional[List[str]] = ['salaire_de_base_prop_smic']) -&gt; Tuple[DataFrame, DataFrame]\n</code></pre> <p>Builds the weights for the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data_simul</code> <code>DataFrame</code> <p>The simulated data.</p> required <code>year</code> <code>int</code> <p>The year for which the data is being processed.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>list_var_groupby</code> <code>Optional[List[str]]</code> <p>The variables to group by, by default ['salaire_de_base_prop_smic']</p> <code>['salaire_de_base_prop_smic']</code> <p>Returns:</p> Type Description <code>Tuple[DataFrame, DataFrame]</code> <p>The descriptive statistics and the secret statistics.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def build_weights_simulation(\n    self,\n    data_simul: pd.DataFrame,\n    year: int,\n    simulation_max_smic: float,\n    list_var_groupby: Optional[List[str]] = [\"salaire_de_base_prop_smic\"],\n) -&gt; Tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    Builds the weights for the simulation.\n\n    Args:\n        data_simul (pd.DataFrame):\n            The simulated data.\n        year (int):\n            The year for which the data is being processed.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        list_var_groupby (Optional[List[str]], optional):\n            The variables to group by, by default ['salaire_de_base_prop_smic']\n\n    Returns:\n        (Tuple[pd.DataFrame, pd.DataFrame]): The descriptive statistics and the secret statistics.\n    \"\"\"\n    # Construction du jeu de donn\u00e9es data_dads s'il n'est pas d\u00e9j\u00e0 en argument\n    if not hasattr(self, \"data_dads\"):\n        self.build_data_dads(year=year)\n\n    # Cr\u00e9ation de tranches de salaires\n    self.data_dads[\"salaire_de_base_prop_smic\"] = pd.to_numeric(\n        pd.cut(\n            x=self.data_dads[\"salaire_de_base_prop_smic\"],\n            bins=data_simul[\"salaire_de_base_prop_smic\"].tolist(),\n            labels=data_simul[\"salaire_de_base_prop_smic\"].tolist()[:-1],\n            include_lowest=True,\n        )\n    )\n    # Restriction aux salaires inf\u00e9rieurs \u00e0 4 SMIC\n    self.data_dads = self.data_dads.loc[\n        self.data_dads[\"salaire_de_base_prop_smic\"] &lt;= simulation_max_smic\n    ]\n\n    # Initialisation de l'estimateur de statistiques descriptives\n    estimator = SecretStatEstimator(\n        data_source=self.data_dads, \n        list_var_groupby=list_var_groupby, \n        list_var_of_interest=[\"eqtp\", \"salaire_de_base\"], \n        var_individu=\"ident_s\", \n        var_entreprise=\"siren\", \n        var_weights=\"weights\", \n        threshold_secret_stat_effectif_individu=5, \n        threshold_secret_stat_effectif_entreprise=3, \n        threshold_secret_stat_contrib_individu=0.8, \n        threshold_secret_stat_contrib_entreprise=0.85, \n        strategy='total'\n    )\n    # Construction de la statistique descriptive et du contr\u00f4le du secret statistique\n    data_stat_des, data_secret_stat = estimator.estimate_secret_stat(\n        iterable_operations=[\"sum\"], \n        include_total=False, \n        drop=False, \n        fill_value=np.nan, \n        nest=False\n    )\n\n    return data_stat_des, data_secret_stat\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.columns_dads","title":"columns_dads","text":"<pre><code>columns_dads(year: int) -&gt; List[str]\n</code></pre> <p>Returns the columns to keep from the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the data is being processed.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The columns to keep from the DADS data.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def columns_dads(self, year: int) -&gt; List[str]:\n    \"\"\"\n    Returns the columns to keep from the DADS data.\n\n    Args:\n        year (int):\n            The year for which the data is being processed.\n\n    Returns:\n        (List[str]): The columns to keep from the DADS data.\n    \"\"\"\n    # Liste des variables \u00e0 conserver lors de l'import\n    return params[\"DADS\"][\"COLONNES_CAPTATION_MARGINALE\"]\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.init_base_case","title":"init_base_case","text":"<pre><code>init_base_case(year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; None\n</code></pre> <p>Initializes a base case for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def init_base_case(\n    self, year: int, simulation_step_smic: float, simulation_max_smic: float\n) -&gt; None:\n    \"\"\"\n    Initializes a base case for simulation.\n\n    Args:\n        year (int):\n            The year for which the simulation is performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction de la valeur moyenne de SMIC sur l'ann\u00e9e\n    value_smic = self.value_smic(year=year)\n    # Calcul de la valeur maximale de la simulation et de la valeur du pas\n    simulation_max = simulation_max_smic * value_smic\n    simulation_step = simulation_step_smic * value_smic\n    # Calcul du nombre d'observations dans la simulation entre le min (1 SMIC) et le max avec le pas sp\u00e9cifi\u00e9\n    simulation_count = ceil((simulation_max - value_smic) / simulation_step) + 1\n    # D\u00e9finition des caract\u00e9ristiques de l'individu\n    self.base_case = {\n        \"individus\": {\n            \"individu_1\": {\n                \"effectif_entreprise\": {year: 200},\n                \"depcom_entreprise\": {year: \"93001\"},\n                \"contrat_de_travail_debut\": {year: \"2009-03-16\"},\n                \"heures_remunerees_volume\": {year: 1820},\n                \"prime_exceptionnelle_pouvoir_achat\": {year: 0},\n                \"quotite_de_travail\": {year: 12},\n                \"prime_partage_valeur_exoneree\": {year: 0},\n                \"prime_partage_valeur_non_exoneree\": {year: 0},\n                \"age\": {year: 40},\n                \"secteur_activite_employeur\": {\n                    year: \"non_agricole\"\n                },  # {year : TypesSecteurActivite.non_agricole},\n                \"exoneration_cotisations_employeur_tode_eligibilite\": {year: False},\n                \"choix_exoneration_cotisations_employeur_agricole\": {year: False},\n                \"travailleur_occasionnel_agricole\": {year: False},\n                \"zone_restructuration_defense\": {year: False},\n                \"zone_revitalisation_rurale\": {year: False},\n                \"categorie_salarie\": {\n                    year: \"prive_non_cadre\"\n                },  # {year : TypesCategorieSalarie.prive_non_cadre},\n                \"contrat_de_travail\": {\n                    year: \"temps_plein\"\n                },  # {year : TypesContratDeTravail.temps_plein},\n                \"contrat_de_travail_fin\": {year: \"2099-12-31\"},\n                \"contrat_de_travail_type\": {\n                    year: \"cdi\"\n                },  # {year : TypesContrat.cdi},\n                \"salarie_regime_alsace_moselle\": {year: False},\n                #'salaire_de_base'\n                \"remuneration_apprenti\": {year: 0},\n                \"apprentissage_contrat_debut\": {year: \"1970-01-01\"},\n                \"apprenti\": {year: False},\n                \"stage_duree_heures\": {year: 0},\n                \"stage_gratification\": {year: 0},\n                \"taux_versement_transport\": {year: 0.032},\n                \"taux_accident_travail\": {year: 0.0212},\n            }\n        },\n        \"menages\": {\n            \"menage_1\": {\n                \"personne_de_reference\": [\"individu_1\"],\n                \"depcom\": {year: \"93001\"},\n            },\n        },\n        \"familles\": {\"famille_1\": {\"parents\": [\"individu_1\"]}},\n        \"foyers_fiscaux\": {\"foyer_fiscal_1\": {\"declarants\": [\"individu_1\"]}},\n        \"axes\": [\n            [\n                {\n                    \"count\": simulation_count,\n                    \"name\": \"salaire_de_base\",\n                    \"min\": value_smic,\n                    \"max\": simulation_max,\n                    \"period\": year,\n                }\n            ]\n        ],\n    }\n\n    # Logging\n    self.logger.info(\"Successfully initialized a test case\")\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.iterate_reform_simulations","title":"iterate_reform_simulations","text":"<pre><code>iterate_reform_simulations(scenarios: dict, year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; DataFrame\n</code></pre> <p>Simulates multiple reforms.</p> <p>Iterates over the scenarios and simulates each reform. Concatenates the simulated data for all reforms.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios to simulate.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data for all reforms.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def iterate_reform_simulations(\n    self,\n    scenarios: dict,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates multiple reforms.\n\n    Iterates over the scenarios and simulates each reform.\n    Concatenates the simulated data for all reforms.\n\n    Args:\n        scenarios (dict):\n            The scenarios to simulate.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n\n    Returns:\n        (pd.DataFrame): The simulated data for all reforms.\n    \"\"\"\n    # Initialisation de la liste r\u00e9sultat\n    list_data_simul = []\n    # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n    for i, scenario in tqdm(enumerate(scenarios.keys())):\n        # It\u00e9ration des r\u00e9formes\n        data_simul = self.simulate_reform(\n            name=scenario.lower(),\n            reform_params=scenarios[scenario],\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Ajout \u00e0 la liste r\u00e9sultat\n        if i &gt; 0:\n            list_data_simul.append(\n                data_simul.drop(\n                    [\"salaire_de_base\", \"salaire_de_base_prop_smic\"], axis=1\n                )\n            )\n        else:\n            list_data_simul.append(data_simul)\n    # Concat\u00e9nation\n    data_simul = pd.concat(list_data_simul, axis=1, join=\"outer\")\n\n    return data_simul\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.iterate_simulation","title":"iterate_simulation","text":"<pre><code>iterate_simulation(data: DataFrame, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str], list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Iterates a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>tax_benefit_system</code> <code>FranceTaxBenefitSystem</code> <p>The tax benefit system.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>The list of variables to simulate.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def iterate_simulation(\n    self,\n    data: pd.DataFrame,\n    tax_benefit_system: TaxBenefitSystem,\n    year: int,\n    list_var_simul: List[str],\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Iterates a simulation.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        tax_benefit_system (FranceTaxBenefitSystem): The tax benefit system.\n        year (int): The year of the simulation.\n        list_var_simul (List[str]): The list of variables to simulate.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Disjonction de cas suivant la n\u00e9cessit\u00e9 de r\u00e9aliser une copie ind\u00e9pendante du jeu de donn\u00e9es\n    if inplace:\n        data_res = data\n    else:\n        data_res = data.copy()\n\n    # Initialisation des param\u00e8tres de la simulation\n    simulation = SimulationBuilder().build_default_simulation(\n        tax_benefit_system, len(data_res)\n    )\n    # Ajout de l'ensemble des donn\u00e9es\n    # /!\\ On ajout 'smic_proratis\u00e9' aux variables \u00e0 exclure de l'imputation pour contourner l'\u00e9cueil de la mauvaise transition entre valeurs mensuelles et annuelles # + ['smic_proratise']\n    # Finalement retir\u00e9 car les r\u00e9mu restent divis\u00e9es par 12 et ne sont pas intersect\u00e9es avec la dur\u00e9e du contrat\n    # Il s'agit sans doute d'un point \u00e0 am\u00e9liorer dans le package\n    for caracteristic in np.setdiff1d(data_res.columns, list_var_exclude):\n        try:  # if not (caracteristic in ['id', 'siren']) :\n            simulation.set_input(\n                caracteristic, year, data_res[caracteristic].to_numpy()\n            )\n            # logging\n            self.logger.info(\n                f\"Successfully initialized {caracteristic} in the french tax benefit system\"\n            )\n        except Exception as e:\n            # Logging\n            self.logger.warning(\n                f\"Cannot initialize {caracteristic} in the french tax benefit system : {e}\"\n            )\n            pass\n    # Ajout des cotisations et des all\u00e8gements g\u00e9n\u00e9raux\n    for var_simul in tqdm(list_var_simul):\n        data_res[var_simul] = simulation.calculate_add(var_simul, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {var_simul} for period {year}\")\n\n    return data_res\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.plot","title":"plot","text":"<pre><code>plot(data: DataFrame, x: str, hue: Union[str, List[str]], x_label: Optional[Union[str, None]] = None, y_label: Optional[Union[str, None]] = None, hue_label: Optional[Union[str, None]] = None, labels: Optional[Dict[str, str]] = {}, export_key: Optional[Union[PathLike, None]] = None, show: Optional[bool] = True) -&gt; None\n</code></pre> <p>Plots the results of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to plot.</p> required <code>x</code> <code>str</code> <p>The variable to use for the x-axis.</p> required <code>hue</code> <code>Union[str, List[str]]</code> <p>The variable(s) to use for the hue.</p> required <code>x_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the x-axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the y-axis. Defaults to None.</p> <code>None</code> <code>hue_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the hue. Defaults to None.</p> <code>None</code> <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary of labels to apply to the data. Defaults to {}.</p> <code>{}</code> <code>export_key</code> <code>Optional[Union[PathLike, None]]</code> <p>The path to save the plot to. Defaults to None.</p> <code>None</code> <code>show</code> <code>Optional[bool]</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def plot(\n    self,\n    data: pd.DataFrame,\n    x: str,\n    hue: Union[str, List[str]],\n    x_label: Optional[Union[str, None]] = None,\n    y_label: Optional[Union[str, None]] = None,\n    hue_label: Optional[Union[str, None]] = None,\n    labels: Optional[Dict[str, str]] = {},\n    export_key: Optional[Union[os.PathLike, None]] = None,\n    show: Optional[bool] = True,\n) -&gt; None:\n    \"\"\"\n    Plots the results of the simulation.\n\n    Args:\n        data (pd.DataFrame):\n            The data to plot.\n        x (str):\n            The variable to use for the x-axis.\n        hue (Union[str, List[str]]):\n            The variable(s) to use for the hue.\n        x_label (Optional[Union[str, None]], optional):\n            The label for the x-axis. Defaults to None.\n        y_label (Optional[Union[str, None]], optional):\n            The label for the y-axis. Defaults to None.\n        hue_label (Optional[Union[str, None]], optional):\n            The label for the hue. Defaults to None.\n        labels (Optional[Dict[str, str]], optional):\n            A dictionary of labels to apply to the data. Defaults to {}.\n        export_key (Optional[Union[os.PathLike, None]], optional):\n            The path to save the plot to. Defaults to None.\n        show (Optional[bool], optional):\n            Whether to display the plot. Defaults to True.\n\n    Returns:\n        None\n    \"\"\"\n    # Conversion des arguments en liste\n    if isinstance(hue, str):\n        hue = [hue]\n\n    # Cr\u00e9ation des noms \u00e0 partir des labels\n    id_name = x_label if (x_label is not None) else x\n    var_name = hue_label if (hue_label is not None) else \"Variable\"\n    value_name = y_label if (y_label is not None) else \"Valeur\"\n\n    # R\u00e9organisation du jeu de donn\u00e9es\n    data_graph = pd.melt(\n        frame=data,\n        id_vars=x,\n        value_vars=hue,\n        var_name=var_name,\n        value_name=value_name,\n    ).rename({x: id_name}, axis=1)\n    # Application des labels\n    data_graph[var_name] = (\n        data_graph[var_name].map(labels).fillna(data_graph[var_name])\n    )\n\n    # Initialisation de la figure\n    fig, ax = plt.subplots()\n    # Construction du graphique\n    sns.lineplot(data=data_graph, x=id_name, y=value_name, hue=var_name)\n    # Formattage de l'axe des ordonn\u00e9es\n    if all([\"_prop_\" in var_hue for var_hue in hue]):\n        ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))\n    # Exportation\n    if export_key is not None:\n        plt.savefig(export_key, bbox_inches=\"tight\")\n\n    # Logging\n    self.logger.info(f\"Successfully build graph\")\n\n    if show:\n        plt.show()\n    else:\n        plt.close(\"all\")\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.preprocess_dads_simulation","title":"preprocess_dads_simulation","text":"<pre><code>preprocess_dads_simulation(year: int) -&gt; None\n</code></pre> <p>Preprocesses the DADS data for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the data is being processed.</p> required Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def preprocess_dads_simulation(self, year: int) -&gt; None:\n    \"\"\"\n    Preprocesses the DADS data for simulation.\n\n    Args:\n        year (int):\n            The year for which the data is being processed.\n    \"\"\"\n    # Simulation du SMIC proratis\u00e9\n    # Construction des variables d'int\u00e9r\u00eat\n    # Conversion de la de la date de d\u00e9but de contrat de travail en datetime\n    self.data_dads[\"date_fin_contrat\"] = (\n        pd.to_datetime(f\"{year}-01-01\", format=\"%Y-%m-%d\")\n        + pd.to_timedelta(arg=self.data_dads[\"datfin\"], unit=\"D\")\n    ).dt.strftime(\"%Y-%m-%d\")\n    self.data_dads[\"contrat_de_travail_fin\"] = np.where(\n        self.data_dads[\"datfin\"] &lt; 360,\n        self.data_dads[\"date_fin_contrat\"],\n        \"2099-12-31\",\n    )\n    # Conersion en string\n    self.data_dads[\"date_debut_contrat\"] = (\n        pd.to_datetime(self.data_dads[\"date_debut_contrat\"], format=\"%Y-%m-%d\")\n        .dt.strftime(\"%Y-%m-%d\")\n        .fillna(\"1970-01-01\")\n    )\n    # Renomination de certaines variables\n    self.data_dads.rename(\n        {\n            \"date_debut_contrat\": \"contrat_de_travail_debut\",\n            \"nbheur\": \"heures_remunerees_volume\",\n            \"brut_s\": \"salaire_de_base\",\n        },\n        axis=1,\n        inplace=True,\n    )\n    # Ajout de la r\u00e9mun\u00e9ration de l'apprenti\n    self.data_dads[\"remuneration_apprenti\"] = 0\n    # Expression du salaire de base en fonction du SMIC\n    self.data_dads[\"salaire_de_base_prop_smic\"] = self.data_dads[\n        \"salaire_de_base\"\n    ] / self.value_smic(year=year)\n\n    # Suppression des colonnes inutiles\n    self.data_dads.drop(\n        np.setdiff1d(\n            self.columns_dads(year=year) + [\"date_fin_contrat\"],\n            [\"ident_s\", \"siren\", \"eqtp\", \"brut_s\", \"date_debut_contrat\", \"nbheur\"],\n        ).tolist(),\n        axis=1,\n        inplace=True,\n    )\n\n    # Logging\n    self.logger.info(\n        \"Successfully preprocessed data_dads to connect it with openfisca\"\n    )\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.simulate","title":"simulate","text":"<pre><code>simulate(year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; DataFrame\n</code></pre> <p>Simulates the marginal capture rate.</p> <p>Initializes the simulation case, initializes the tax-benefit system, simulates the variables, postprocesses the simulated variables, calculates the marginal capture rate, and preprocesses the gross salary.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def simulate(\n    self, year: int, simulation_step_smic: float, simulation_max_smic: float\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the marginal capture rate.\n\n    Initializes the simulation case, initializes the tax-benefit system,\n    simulates the variables, postprocesses the simulated variables,\n    calculates the marginal capture rate, and preprocesses the gross salary.\n\n    Args:\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation du cas de simulation\n    self.init_base_case(\n        year=year,\n        simulation_step_smic=simulation_step_smic,\n        simulation_max_smic=simulation_max_smic,\n    )\n    # Initialisation du syst\u00e8me socio-fiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction des variables \u00e0 simuler\n    list_var_simul = params[\"VARIABLES_CAPTATION_MARGINALE\"]\n    # Simulation\n    data_simul = self.base_case_simulation(\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=list_var_simul,\n    )\n    # Retraitement des variables simul\u00e9es\n    data_simul = preprocess_simulated_variables(data=data_simul)\n    # Calcul du taux marginal\n    data_simul = self._calculate_taux_captation_marginal(data=data_simul, name=None)\n    # Retraitement du salaire de base\n    data_simul = self._preprocess_salaire_de_base(\n        data=data_simul, year=year, name=None\n    )\n\n    return data_simul\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.simulate_reform","title":"simulate_reform","text":"<pre><code>simulate_reform(name: str, reform_params: dict, year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; DataFrame\n</code></pre> <p>Simulates a reform.</p> <p>Initializes the simulation case, initializes the tax-benefit system, applies the reform, simulates the variables, postprocesses the simulated variables, calculates the marginal capture rate, and preprocesses the gross salary.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the reform.</p> required <code>reform_params</code> <code>dict</code> <p>The parameters of the reform.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/taux_captation_marginal.py</code> <pre><code>def simulate_reform(\n    self,\n    name: str,\n    reform_params: dict,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates a reform.\n\n    Initializes the simulation case, initializes the tax-benefit system,\n    applies the reform, simulates the variables, postprocesses the simulated variables,\n    calculates the marginal capture rate, and preprocesses the gross salary.\n\n    Args:\n        name (str):\n            The name of the reform.\n        reform_params (dict):\n            The parameters of the reform.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation du cas de simulation\n    if not hasattr(self, \"base_case\"):\n        self.init_base_case(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Application de la r\u00e9forme\n    reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n        tax_benefit_system=tax_benefit_system, dict_params=reform_params\n    )\n\n    # Logging\n    self.logger.info(\"Successfully updated the tax-benefit system\")\n\n    # Extraction du type de la r\u00e9forme\n    reform_type = reform_params[\"TYPE\"]\n\n    # It\u00e9ration de la simulation\n    data_simul = self.base_case_simulation(\n        tax_benefit_system=reformed_tax_benefit_system,\n        year=year,\n        list_var_simul=params[\"VARIABLES_CAPTATION_MARGINALE\"]\n        + [f\"new_allegement_{reform_type}\"],\n    )\n\n    # Retraitement des variables simul\u00e9es\n    data_simul = preprocess_simulated_variables(data=data_simul)\n\n    # Construction du nouveau salaire super brut\n    data_simul[f\"salaire_super_brut_{name}\"] = (\n        data_simul[\n            [\n                \"salaire_super_brut\",\n                \"allegement_general\",\n                \"allegement_cotisation_maladie\",\n                \"allegement_cotisation_allocations_familiales\",\n            ]\n        ].sum(axis=1)\n        - data_simul[f\"new_allegement_{reform_type}\"]\n    )\n\n    # Calcul du taux marginal\n    data_simul = self._calculate_taux_captation_marginal(data=data_simul, name=name)\n\n    # Retraitement du salaire de base\n    data_simul = self._preprocess_salaire_de_base(\n        data=data_simul, year=year, name=name\n    )\n\n    return data_simul\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.simulate_smic_proratise","title":"simulate_smic_proratise","text":"<pre><code>simulate_smic_proratise(data: DataFrame, year: int, list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Simulates the prorated minimum wage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def simulate_smic_proratise(\n    self,\n    data: pd.DataFrame,\n    year: int,\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the prorated minimum wage.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        year (int): The year of the simulation.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal fran\u00e7ais\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e des donn\u00e9es\n    data = self.iterate_simulation(\n        data=data,\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=[\"smic_proratise\"],\n        list_var_exclude=list_var_exclude,\n        inplace=inplace,\n    )\n\n    return data\n</code></pre>"},{"location":"api/CaptationMarginaleSimulator/#bozio_wasmer_simulations.simulation.theoretical.taux_captation_marginal.CaptationMarginaleSimulator.value_smic","title":"value_smic","text":"<pre><code>value_smic(year: int) -&gt; float\n</code></pre> <p>Calculates the value of the SMIC for the given year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the SMIC value is calculated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the SMIC for the given year.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def value_smic(self, year: int) -&gt; float:\n    \"\"\"\n    Calculates the value of the SMIC for the given year.\n\n    Args:\n        year (int):\n            The year for which the SMIC value is calculated.\n\n    Returns:\n        (float): The value of the SMIC for the given year.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    value_smic = sum(\n        [\n            tax_benefit_system.get_parameters_at_instant(\n                instant=f\"{year}-{month}\"\n            ).marche_travail.salaire_minimum.smic.smic_b_mensuel\n            for month in [str(m).zfill(2) for m in range(1, 13)]\n        ]\n    )\n    # Logging\n    self.logger.info(f\"The SMIC value computed for {year} is {value_smic} \u20ac\")\n\n    return value_smic\n</code></pre>"},{"location":"api/CoreSimulation/","title":"CoreSimulation","text":""},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation","title":"CoreSimulation","text":"<p>A class used to build the core simulation data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>class CoreSimulation(EmpiricalSimulator):\n    \"\"\"\n    A class used to build the core simulation data.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        project: str,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[3], \"logs/core_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the CoreSimulation object.\n\n        Args:\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/core_simulation.log').\n\n        Returns:\n            None\n        \"\"\"\n        # Initialisation du projet CASD\n        self.project = project\n        # Initialisation du logger\n        super().__init__(log_filename=log_filename)\n\n    # Fonction auxiliaire d'importation du zonage des Zones de Revitalisation Rurales (ZRR)\n    @property\n    def zonage_zrr(self) -&gt; List[str]:\n        \"\"\"\n        Imports the rural revitalization zones (ZRR) zoning.\n\n        Returns:\n            (List[str]): The list of rural revitalization zones.\n        \"\"\"\n        # Importation des donn\u00e9es\n        data_zonage_zrr = pd.read_excel(\n            os.path.join(\n                FILE_PATH.parents[3], \"data/diffusion-zonages-zrr-cog2021.xls\"\n            ),\n            skiprows=5,\n            dtype={\"CODGEO\": str},\n        )\n        # S\u00e9lection des donn\u00e9es\n        list_zonage_zrr = data_zonage_zrr.loc[\n            data_zonage_zrr[\"ZRR_SIMP\"].isin(\n                [\"C - Class\u00e9e en ZRR\", \"P - Commune partiellement class\u00e9e en ZRR\"]\n            ),\n            \"CODGEO\",\n        ].tolist()\n\n        return list_zonage_zrr\n\n    # Fonction auxiliaire d'importation du zonage des Zones de Restructuration de la D\u00e9fense (ZRD)\n    @property\n    def zonage_zrd(self) -&gt; List[str]:\n        \"\"\"\n        Imports the defense restructuring zones (ZRD) zoning.\n\n        Returns:\n            (List[str]): The list of defense restructuring zones.\n        \"\"\"\n        # Importation des donn\u00e9es\n        list_zonage_zrd = pd.read_excel(\n            os.path.join(FILE_PATH.parents[3], \"data/diffusion-zonages-zrd-2020.xls\"),\n            skiprows=5,\n            dtype={\"CODGEO\": str},\n        )[\"CODGEO\"].tolist()\n\n        return list_zonage_zrd\n\n    # Fonction auxiliaire de construction des colonnes des DADS\n    # @property\n    def columns_dads(self, year: int) -&gt; List[str]:\n        \"\"\"\n        Builds the columns for the DADS data.\n\n        Args:\n            year (int): The year.\n\n        Returns:\n            (List[str]): The list of columns.\n        \"\"\"\n        # Liste des variables \u00e0 conserver lors de l'import\n        columns = params[\"DADS\"][\"COLONNES\"]\n        # Ajout des primes de partage de la valeur si on se trouve en 2022\n        if year == 2022:\n            columns += params[\"DADS\"][\"COLONNES_2022\"]\n        return columns\n\n    # Fonction auxilaire de construction des donn\u00e9es DADS\n    def build_data_dads(\n        self, year: int, data: Optional[Union[pd.DataFrame, None]] = None\n    ) -&gt; None:\n        \"\"\"\n        Builds the DADS data.\n\n        Args:\n            year (int): The year.\n            data (Optional[Union[pd.DataFrame, None]], optional): The data. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        if data is not None:\n            self._build_data_dads_from_dataframe(data=data, year=year)\n        else:\n            self.data_dads = self._init_data_dads(year=year)\n\n    # Fonction auxiliaire de construction des donn\u00e9es DADS \u00e0 partir d'un DataFrame\n    def _build_data_dads_from_dataframe(self, data: pd.DataFrame, year: int) -&gt; None:\n        \"\"\"\n        Builds the DADS data from a DataFrame.\n\n        Args:\n            data (pd.DataFrame): The data.\n            year (int): The year.\n\n        Returns:\n            None\n        \"\"\"\n        # V\u00e9rification que l'ensemble des variables attendues sont dans le jeu de donn\u00e9es\n        # Variables manquantes\n        missing_variables = np.setdiff1d(\n            self.columns_dads(year=year), data.columns.tolist()\n        ).tolist()\n        if missing_variables == []:\n            self.data_dads = data\n            # Logging\n            self.logger.info(\"Successfully build data_dads\")\n        else:\n            # Logging\n            self.logger.error(\n                f\"Given DataFrame should contain {missing_variables} as columns\"\n            )\n            # Erreur\n            raise ValueError(\n                f\"Given DataFrame should contain {missing_variables} as columns\"\n            )\n\n    # Fonction auxiliaire d'importation et de retraitement des DADS\n    def _init_data_dads(self, year: int) -&gt; pd.DataFrame:\n        \"\"\"\n        Imports and preprocesses the DADS data.\n\n        Args:\n            year (int): The year.\n\n        Returns:\n            (pd.DataFrame): The preprocessed DADS data.\n        \"\"\"\n        # Filtre sur les lignes (s\u00e9lection des postes principaux de l'ann\u00e9e du mill\u00e9sime)\n        filter_dads = [(\"annee\", \"==\", f\"{year}\"), (\"pps\", \"==\", \"1\")]\n\n        # Chargement des donn\u00e9es\n        data_dads = load_dads(\n            project=self.project, year=year, columns=self.columns_dads(year=year), filters=filter_dads\n        )\n\n        # Construction de l'\u00e2ge\n        data_dads[\"age\"] = -(data_dads[\"annee_naiss\"].subtract(other=year))\n        # Compl\u00e9tion des Nan\n        data_dads[\"age\"] = data_dads[\"age\"].fillna(year - 1970)\n\n        # Restriction sur le champ du secteur priv\u00e9 et aux salari\u00e9s \u00e2g\u00e9s de 18 \u00e0 64 ans, en france m\u00e9tropolitaine\n        data_dads = data_dads.loc[\n            (~data_dads[\"domempl_empl\"].isin(params[\"CHAMP\"][\"DOMEMPL_EXCLUDE\"]))\n            &amp; (data_dads[\"age\"] &gt;= int(params[\"CHAMP\"][\"AGE_MIN\"]))\n            &amp; (data_dads[\"age\"] &lt;= int(params[\"CHAMP\"][\"AGE_MAX\"]))\n            &amp; (~data_dads[\"dept\"].isin(params[\"CHAMP\"][\"DEPT_EXCLUDE\"]))\n        ]\n\n        # Construction d'un identifiant\n        data_dads.reset_index(drop=True, inplace=True)\n        data_dads.reset_index(drop=False, names=\"id\", inplace=True)\n\n        # Logging\n        self.logger.info(\"Successfully build data_dads\")\n\n        return data_dads\n\n    # Fonction auxiliaire de preprocessing des DADS en vue d'une branchement avec openfisca\n    def preprocess_dads_simulation(self, year: int) -&gt; None:\n        \"\"\"\n        Preprocesses the DADS data for simulation.\n\n        Args:\n            year (int): The year.\n\n        Returns:\n            None\n        \"\"\"\n        # Preprocessing pour les all\u00e8gements g\u00e9n\u00e9raux\n        self.data_dads = preprocess_dads_openfisca_ag(\n            data_dads=self.data_dads,\n            year=year,\n            list_zonage_zrr=self.zonage_zrr,\n            list_zonage_zrd=self.zonage_zrd,\n        )\n\n        # Suppression des variables inutiles pour les simulations\n        self.data_dads.drop(\n            np.setdiff1d(\n                self.columns_dads(year=year) + [\"pcs_2\", \"date_fin_contrat\"],\n                params[\"PREPROCESSING\"][\"KEEP\"],\n            ),\n            axis=1,\n            inplace=True,\n            errors=\"ignore\",\n        )\n\n        # Logging\n        self.logger.info(\n            \"Successfully preprocessed data_dads to connect it with openfisca\"\n        )\n\n    # Fonction auxiliaire d'ajout de poids\n    def add_weights(self, year_data: int, year_simul: int) -&gt; None:\n        \"\"\"\n        Adds weights to the DADS data.\n\n        Args:\n            year_data (int): The year of the data.\n            year_simul (int): The year of the simulation.\n\n        Returns:\n            None\n        \"\"\"\n        # Simulation du SMIC proratis\u00e9\n        # Simulation\n        self.data_dads = self.simulate_smic_proratise(\n            data=self.data_dads, year=year_data, list_var_exclude=[], inplace=True\n        )\n\n        # Si l'ann\u00e9e des donn\u00e9es ne coincide pas avec l'ann\u00e9e des simulations, on met \u00e0 jour les salaires pour qu'il corresponde au m\u00eame niveau de SMIC\n        if year_data != year_simul:\n            # Renomination de la colonne simul\u00e9e\n            self.data_dads.rename(\n                {\"smic_proratise\": f\"smic_proratise_{year_data}\"}, axis=1, inplace=True\n            )\n            # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e de simulation\n            self.data_dads = self.simulate_smic_proratise(\n                data=self.data_dads, year=year_simul, list_var_exclude=[], inplace=True\n            )\n            # Correction des salaires\n            # Salaire en proportion du SMIC\n            self.data_dads[\"salaire_brut_smic\"] = (\n                self.data_dads[[\"salaire_de_base\", \"remuneration_apprenti\"]].sum(axis=1)\n                / self.data_dads[f\"smic_proratise_{year_data}\"]\n            )\n            # Actualisation des r\u00e9umn\u00e9rations\n            self.data_dads[\"salaire_de_base\"] = np.where(\n                self.data_dads[\"salaire_de_base\"] &gt; 0,\n                self.data_dads[\"salaire_brut_smic\"] * self.data_dads[\"smic_proratise\"],\n                0,\n            )\n            self.data_dads[\"remuneration_apprenti\"] = np.where(\n                self.data_dads[\"remuneration_apprenti\"] &gt; 0,\n                self.data_dads[\"salaire_brut_smic\"] * self.data_dads[\"smic_proratise\"],\n                0,\n            )\n            # Suppression du SMIC proratis\u00e9 initialement calcul\u00e9\n            self.data_dads.drop(f\"smic_proratise_{year_data}\", axis=1, inplace=True)\n        # Recr\u00e9ation d'un salaire brut\n        self.data_dads[\"brut_s\"] = self.data_dads[\n            [\"salaire_de_base\", \"remuneration_apprenti\"]\n        ].sum(axis=1)\n        # Ajout des poids\n        self.data_dads = add_weights_eqtp_accos(\n            data_dads=self.data_dads,\n            year=year_simul,\n            var_eqtp=\"eqtp\",\n            var_sal_brut=\"brut_s\",\n            var_smic_proratise=\"smic_proratise\",\n        )\n        # Suppression de la colonne de salaire brut\n        self.data_dads.drop(\"brut_s\", axis=1, inplace=True)\n\n        # Logging\n        self.logger.info(\"Successfully added accoss weights to data_dads\")\n\n    # Fonction auxiliaire de simulation\n    def simulate(self, year: int) -&gt; None:\n        \"\"\"\n        Simulates the data.\n\n        Args:\n            year (int): The year.\n\n        Returns:\n            None\n        \"\"\"\n        # Le salaire de base  et smic_proratis\u00e9 sont des variables mensuelles dans Openfisca et les DADS sont des variables annuelles\n        # Les deux variables ayant l'attribut set_input=set_input_divide_by_period mais smic_proratis\u00e9 est calcul\u00e9 en tenant compte de la dur\u00e9e du contrat\n        # Si on simule d'abord un smic proratis\u00e9 et qu'on en cr\u00e9e une variable annuelle, on divisera par 12 les deux grandeurs, alors qu'il faudrait les intersecter les deux avec la dur\u00e9e du contrat\n        # Le rapport smic_proratise/salaire_de_base ou salaire_de_base/smic_proratise reste alors juste.\n        # Simulation du SMIC proratis\u00e9\n        if \"smic_proratise\" not in self.data_dads.columns:\n            self.data_dads = self.simulate_smic_proratise(\n                data=self.data_dads, year=year, list_var_exclude=[], inplace=True\n            )\n        # Liste des variables \u00e0 simuler\n        list_var_simul = np.setdiff1d(params[\"VARIABLES\"], [\"smic_proratise\"])\n        # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n        # It\u00e9ration de la simulation\n        self.data_dads = self.iterate_simulation(\n            data=self.data_dads,\n            tax_benefit_system=tax_benefit_system,\n            year=year,\n            list_var_simul=list_var_simul,\n            list_var_exclude=[],\n            inplace=True,\n        )\n        # Retraitement des variables simul\u00e9es\n        self.data_dads = preprocess_simulated_variables(data=self.data_dads)\n        # Renomination de la quotit\u00e9 de travail pour pallier la mauvaise gestion annuel/mensuel de la variable dans openfisca\n        self.data_dads.rename({\"eqtp\": \"quotite_de_travail\"}, axis=1, inplace=True)\n\n        # Logging\n        self.logger.info(\n            f\"Successfully simulated {list_var_simul} on data_dads observations\"\n        )\n\n    # M\u00e9thode construisant le jeu de donn\u00e9es avec les variables simul\u00e9es\n    def build(\n        self,\n        year_data: int,\n        year_simul: int,\n        data: Optional[Union[pd.DataFrame, None]] = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Builds the simulation data.\n\n        Args:\n            year_data (int): The year of the data.\n            year_simul (int): The year of the simulation.\n            data (Optional[Union[pd.DataFrame, None]], optional): The data. Defaults to None.\n\n        Returns:\n            (pd.DataFrame): The simulation data.\n        \"\"\"\n        # Chargement du jeu de donn\u00e9es\n        self.build_data_dads(data=data, year=year_data)\n        # Preprocessing\n        self.preprocess_dads_simulation(year=year_data)\n        # Ajout des poids\n        self.add_weights(year_data=year_data, year_simul=year_simul)\n        # Simulation des variables\n        self.simulate(year=year_simul)\n\n        # Construction de chiffres cadres aggr\u00e9g\u00e9s\n        aggregated_numbers = (\n            self.data_dads[\n                [\n                    \"salaire_de_base\",\n                    \"remuneration_apprenti\",\n                    \"salaire_super_brut\",\n                    \"salaire_super_brut_hors_allegements\",\n                    \"exonerations_et_allegements\",\n                    \"exoneration_cotisations_employeur_apprenti\",\n                    \"exoneration_cotisations_employeur_tode\",\n                    \"exoneration_cotisations_employeur_zrd\",\n                    \"exoneration_cotisations_employeur_zrr\",\n                    \"exoneration_cotisations_employeur_jei\",\n                    \"exoneration_cotisations_employeur_stagiaire\",\n                    \"allegement_general\",\n                    \"allegement_cotisation_maladie\",\n                    \"allegement_cotisation_allocations_familiales\",\n                    \"versement_transport\",\n                    \"prime_partage_valeur_exoneree\",\n                ]\n            ]\n            .multiply(other=self.data_dads[\"weights\"], axis=0)\n            .sum()\n        )\n        # Logging\n        self.logger.info(\"Successfully build simulated DataFrame\")\n        self.logger.info(aggregated_numbers.to_string())\n\n        return self.data_dads\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.zonage_zrd","title":"zonage_zrd  <code>property</code>","text":"<pre><code>zonage_zrd: List[str]\n</code></pre> <p>Imports the defense restructuring zones (ZRD) zoning.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of defense restructuring zones.</p>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.zonage_zrr","title":"zonage_zrr  <code>property</code>","text":"<pre><code>zonage_zrr: List[str]\n</code></pre> <p>Imports the rural revitalization zones (ZRR) zoning.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of rural revitalization zones.</p>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.add_weights","title":"add_weights","text":"<pre><code>add_weights(year_data: int, year_simul: int) -&gt; None\n</code></pre> <p>Adds weights to the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year_data</code> <code>int</code> <p>The year of the data.</p> required <code>year_simul</code> <code>int</code> <p>The year of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def add_weights(self, year_data: int, year_simul: int) -&gt; None:\n    \"\"\"\n    Adds weights to the DADS data.\n\n    Args:\n        year_data (int): The year of the data.\n        year_simul (int): The year of the simulation.\n\n    Returns:\n        None\n    \"\"\"\n    # Simulation du SMIC proratis\u00e9\n    # Simulation\n    self.data_dads = self.simulate_smic_proratise(\n        data=self.data_dads, year=year_data, list_var_exclude=[], inplace=True\n    )\n\n    # Si l'ann\u00e9e des donn\u00e9es ne coincide pas avec l'ann\u00e9e des simulations, on met \u00e0 jour les salaires pour qu'il corresponde au m\u00eame niveau de SMIC\n    if year_data != year_simul:\n        # Renomination de la colonne simul\u00e9e\n        self.data_dads.rename(\n            {\"smic_proratise\": f\"smic_proratise_{year_data}\"}, axis=1, inplace=True\n        )\n        # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e de simulation\n        self.data_dads = self.simulate_smic_proratise(\n            data=self.data_dads, year=year_simul, list_var_exclude=[], inplace=True\n        )\n        # Correction des salaires\n        # Salaire en proportion du SMIC\n        self.data_dads[\"salaire_brut_smic\"] = (\n            self.data_dads[[\"salaire_de_base\", \"remuneration_apprenti\"]].sum(axis=1)\n            / self.data_dads[f\"smic_proratise_{year_data}\"]\n        )\n        # Actualisation des r\u00e9umn\u00e9rations\n        self.data_dads[\"salaire_de_base\"] = np.where(\n            self.data_dads[\"salaire_de_base\"] &gt; 0,\n            self.data_dads[\"salaire_brut_smic\"] * self.data_dads[\"smic_proratise\"],\n            0,\n        )\n        self.data_dads[\"remuneration_apprenti\"] = np.where(\n            self.data_dads[\"remuneration_apprenti\"] &gt; 0,\n            self.data_dads[\"salaire_brut_smic\"] * self.data_dads[\"smic_proratise\"],\n            0,\n        )\n        # Suppression du SMIC proratis\u00e9 initialement calcul\u00e9\n        self.data_dads.drop(f\"smic_proratise_{year_data}\", axis=1, inplace=True)\n    # Recr\u00e9ation d'un salaire brut\n    self.data_dads[\"brut_s\"] = self.data_dads[\n        [\"salaire_de_base\", \"remuneration_apprenti\"]\n    ].sum(axis=1)\n    # Ajout des poids\n    self.data_dads = add_weights_eqtp_accos(\n        data_dads=self.data_dads,\n        year=year_simul,\n        var_eqtp=\"eqtp\",\n        var_sal_brut=\"brut_s\",\n        var_smic_proratise=\"smic_proratise\",\n    )\n    # Suppression de la colonne de salaire brut\n    self.data_dads.drop(\"brut_s\", axis=1, inplace=True)\n\n    # Logging\n    self.logger.info(\"Successfully added accoss weights to data_dads\")\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.build","title":"build","text":"<pre><code>build(year_data: int, year_simul: int, data: Optional[Union[DataFrame, None]] = None) -&gt; DataFrame\n</code></pre> <p>Builds the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>year_data</code> <code>int</code> <p>The year of the data.</p> required <code>year_simul</code> <code>int</code> <p>The year of the simulation.</p> required <code>data</code> <code>Optional[Union[DataFrame, None]]</code> <p>The data. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulation data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def build(\n    self,\n    year_data: int,\n    year_simul: int,\n    data: Optional[Union[pd.DataFrame, None]] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Builds the simulation data.\n\n    Args:\n        year_data (int): The year of the data.\n        year_simul (int): The year of the simulation.\n        data (Optional[Union[pd.DataFrame, None]], optional): The data. Defaults to None.\n\n    Returns:\n        (pd.DataFrame): The simulation data.\n    \"\"\"\n    # Chargement du jeu de donn\u00e9es\n    self.build_data_dads(data=data, year=year_data)\n    # Preprocessing\n    self.preprocess_dads_simulation(year=year_data)\n    # Ajout des poids\n    self.add_weights(year_data=year_data, year_simul=year_simul)\n    # Simulation des variables\n    self.simulate(year=year_simul)\n\n    # Construction de chiffres cadres aggr\u00e9g\u00e9s\n    aggregated_numbers = (\n        self.data_dads[\n            [\n                \"salaire_de_base\",\n                \"remuneration_apprenti\",\n                \"salaire_super_brut\",\n                \"salaire_super_brut_hors_allegements\",\n                \"exonerations_et_allegements\",\n                \"exoneration_cotisations_employeur_apprenti\",\n                \"exoneration_cotisations_employeur_tode\",\n                \"exoneration_cotisations_employeur_zrd\",\n                \"exoneration_cotisations_employeur_zrr\",\n                \"exoneration_cotisations_employeur_jei\",\n                \"exoneration_cotisations_employeur_stagiaire\",\n                \"allegement_general\",\n                \"allegement_cotisation_maladie\",\n                \"allegement_cotisation_allocations_familiales\",\n                \"versement_transport\",\n                \"prime_partage_valeur_exoneree\",\n            ]\n        ]\n        .multiply(other=self.data_dads[\"weights\"], axis=0)\n        .sum()\n    )\n    # Logging\n    self.logger.info(\"Successfully build simulated DataFrame\")\n    self.logger.info(aggregated_numbers.to_string())\n\n    return self.data_dads\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.build_data_dads","title":"build_data_dads","text":"<pre><code>build_data_dads(year: int, data: Optional[Union[DataFrame, None]] = None) -&gt; None\n</code></pre> <p>Builds the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <code>data</code> <code>Optional[Union[DataFrame, None]]</code> <p>The data. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def build_data_dads(\n    self, year: int, data: Optional[Union[pd.DataFrame, None]] = None\n) -&gt; None:\n    \"\"\"\n    Builds the DADS data.\n\n    Args:\n        year (int): The year.\n        data (Optional[Union[pd.DataFrame, None]], optional): The data. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    if data is not None:\n        self._build_data_dads_from_dataframe(data=data, year=year)\n    else:\n        self.data_dads = self._init_data_dads(year=year)\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.columns_dads","title":"columns_dads","text":"<pre><code>columns_dads(year: int) -&gt; List[str]\n</code></pre> <p>Builds the columns for the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of columns.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def columns_dads(self, year: int) -&gt; List[str]:\n    \"\"\"\n    Builds the columns for the DADS data.\n\n    Args:\n        year (int): The year.\n\n    Returns:\n        (List[str]): The list of columns.\n    \"\"\"\n    # Liste des variables \u00e0 conserver lors de l'import\n    columns = params[\"DADS\"][\"COLONNES\"]\n    # Ajout des primes de partage de la valeur si on se trouve en 2022\n    if year == 2022:\n        columns += params[\"DADS\"][\"COLONNES_2022\"]\n    return columns\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.iterate_simulation","title":"iterate_simulation","text":"<pre><code>iterate_simulation(data: DataFrame, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str], list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Iterates a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>tax_benefit_system</code> <code>FranceTaxBenefitSystem</code> <p>The tax benefit system.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>The list of variables to simulate.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def iterate_simulation(\n    self,\n    data: pd.DataFrame,\n    tax_benefit_system: TaxBenefitSystem,\n    year: int,\n    list_var_simul: List[str],\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Iterates a simulation.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        tax_benefit_system (FranceTaxBenefitSystem): The tax benefit system.\n        year (int): The year of the simulation.\n        list_var_simul (List[str]): The list of variables to simulate.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Disjonction de cas suivant la n\u00e9cessit\u00e9 de r\u00e9aliser une copie ind\u00e9pendante du jeu de donn\u00e9es\n    if inplace:\n        data_res = data\n    else:\n        data_res = data.copy()\n\n    # Initialisation des param\u00e8tres de la simulation\n    simulation = SimulationBuilder().build_default_simulation(\n        tax_benefit_system, len(data_res)\n    )\n    # Ajout de l'ensemble des donn\u00e9es\n    # /!\\ On ajout 'smic_proratis\u00e9' aux variables \u00e0 exclure de l'imputation pour contourner l'\u00e9cueil de la mauvaise transition entre valeurs mensuelles et annuelles # + ['smic_proratise']\n    # Finalement retir\u00e9 car les r\u00e9mu restent divis\u00e9es par 12 et ne sont pas intersect\u00e9es avec la dur\u00e9e du contrat\n    # Il s'agit sans doute d'un point \u00e0 am\u00e9liorer dans le package\n    for caracteristic in np.setdiff1d(data_res.columns, list_var_exclude):\n        try:  # if not (caracteristic in ['id', 'siren']) :\n            simulation.set_input(\n                caracteristic, year, data_res[caracteristic].to_numpy()\n            )\n            # logging\n            self.logger.info(\n                f\"Successfully initialized {caracteristic} in the french tax benefit system\"\n            )\n        except Exception as e:\n            # Logging\n            self.logger.warning(\n                f\"Cannot initialize {caracteristic} in the french tax benefit system : {e}\"\n            )\n            pass\n    # Ajout des cotisations et des all\u00e8gements g\u00e9n\u00e9raux\n    for var_simul in tqdm(list_var_simul):\n        data_res[var_simul] = simulation.calculate_add(var_simul, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {var_simul} for period {year}\")\n\n    return data_res\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.preprocess_dads_simulation","title":"preprocess_dads_simulation","text":"<pre><code>preprocess_dads_simulation(year: int) -&gt; None\n</code></pre> <p>Preprocesses the DADS data for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def preprocess_dads_simulation(self, year: int) -&gt; None:\n    \"\"\"\n    Preprocesses the DADS data for simulation.\n\n    Args:\n        year (int): The year.\n\n    Returns:\n        None\n    \"\"\"\n    # Preprocessing pour les all\u00e8gements g\u00e9n\u00e9raux\n    self.data_dads = preprocess_dads_openfisca_ag(\n        data_dads=self.data_dads,\n        year=year,\n        list_zonage_zrr=self.zonage_zrr,\n        list_zonage_zrd=self.zonage_zrd,\n    )\n\n    # Suppression des variables inutiles pour les simulations\n    self.data_dads.drop(\n        np.setdiff1d(\n            self.columns_dads(year=year) + [\"pcs_2\", \"date_fin_contrat\"],\n            params[\"PREPROCESSING\"][\"KEEP\"],\n        ),\n        axis=1,\n        inplace=True,\n        errors=\"ignore\",\n    )\n\n    # Logging\n    self.logger.info(\n        \"Successfully preprocessed data_dads to connect it with openfisca\"\n    )\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.simulate","title":"simulate","text":"<pre><code>simulate(year: int) -&gt; None\n</code></pre> <p>Simulates the data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def simulate(self, year: int) -&gt; None:\n    \"\"\"\n    Simulates the data.\n\n    Args:\n        year (int): The year.\n\n    Returns:\n        None\n    \"\"\"\n    # Le salaire de base  et smic_proratis\u00e9 sont des variables mensuelles dans Openfisca et les DADS sont des variables annuelles\n    # Les deux variables ayant l'attribut set_input=set_input_divide_by_period mais smic_proratis\u00e9 est calcul\u00e9 en tenant compte de la dur\u00e9e du contrat\n    # Si on simule d'abord un smic proratis\u00e9 et qu'on en cr\u00e9e une variable annuelle, on divisera par 12 les deux grandeurs, alors qu'il faudrait les intersecter les deux avec la dur\u00e9e du contrat\n    # Le rapport smic_proratise/salaire_de_base ou salaire_de_base/smic_proratise reste alors juste.\n    # Simulation du SMIC proratis\u00e9\n    if \"smic_proratise\" not in self.data_dads.columns:\n        self.data_dads = self.simulate_smic_proratise(\n            data=self.data_dads, year=year, list_var_exclude=[], inplace=True\n        )\n    # Liste des variables \u00e0 simuler\n    list_var_simul = np.setdiff1d(params[\"VARIABLES\"], [\"smic_proratise\"])\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # It\u00e9ration de la simulation\n    self.data_dads = self.iterate_simulation(\n        data=self.data_dads,\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=list_var_simul,\n        list_var_exclude=[],\n        inplace=True,\n    )\n    # Retraitement des variables simul\u00e9es\n    self.data_dads = preprocess_simulated_variables(data=self.data_dads)\n    # Renomination de la quotit\u00e9 de travail pour pallier la mauvaise gestion annuel/mensuel de la variable dans openfisca\n    self.data_dads.rename({\"eqtp\": \"quotite_de_travail\"}, axis=1, inplace=True)\n\n    # Logging\n    self.logger.info(\n        f\"Successfully simulated {list_var_simul} on data_dads observations\"\n    )\n</code></pre>"},{"location":"api/CoreSimulation/#bozio_wasmer_simulations.simulation.empirical.base.CoreSimulation.simulate_smic_proratise","title":"simulate_smic_proratise","text":"<pre><code>simulate_smic_proratise(data: DataFrame, year: int, list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Simulates the prorated minimum wage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def simulate_smic_proratise(\n    self,\n    data: pd.DataFrame,\n    year: int,\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the prorated minimum wage.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        year (int): The year of the simulation.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal fran\u00e7ais\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e des donn\u00e9es\n    data = self.iterate_simulation(\n        data=data,\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=[\"smic_proratise\"],\n        list_var_exclude=list_var_exclude,\n        inplace=inplace,\n    )\n\n    return data\n</code></pre>"},{"location":"api/DescriptionBuilder/","title":"DescriptionBuilder","text":""},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder","title":"DescriptionBuilder","text":"<p>A class used to build a dataset for description and calculate employment effects.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger instance.</p> <code>project</code> <code>str</code> <p>The name of the CASD project</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>class DescriptionBuilder:\n    \"\"\"\n    A class used to build a dataset for description and calculate employment effects.\n\n\n    Attributes:\n        logger (logging.Logger):\n            A logger instance.\n        project (str):\n            The name of the CASD project\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        project: str,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[2], \"logs/description.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the DescriptionBuilder object.\n\n        Args:\n            project (str): The name of the CASD project\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[2], 'logs/description.log').\n\n        \"\"\"\n        # Initialisation du projet CASD\n        self.project = project\n        # Initialisation du logger\n        self.logger = _init_logger(filename=log_filename)\n\n    # Fonction auxiliaire d'extraction des noms de sc\u00e9narios\n    def scenarios_names(self, scenarios: Union[str, List[str], dict]) -&gt; List[str]:\n        \"\"\"\n        Extracts the names of scenarios.\n\n        Args:\n            scenarios (Union[str, List[str], dict]): The scenarios.\n\n        Returns:\n            (List[str]): The names of the scenarios.\n\n        Raises:\n            ValueError: If the type of scenarios is not 'dict', 'list' or 'str'.\n        \"\"\"\n        # Extraction des noms des scenarios\n        if isinstance(scenarios, str):\n            scenarios_names = [scenarios]\n        elif isinstance(scenarios, dict):\n            scenarios_names = [name.lower() for name in scenarios.keys()]\n        elif isinstance(scenarios, list):\n            scenarios_names = [name.lower() for name in scenarios]\n        else:\n            raise ValueError(\n                f\"Invalid type for scenarios : {type(scenarios)}. Should be in 'dict', 'list' or 'str'\"\n            )\n\n        return scenarios_names\n\n    # Construction du jeu de donn\u00e9es sur lesquel it\u00e9rer\n    def build_data_simulation(\n        self,\n        year: int,\n        scenarios: Union[str, List[str], dict],\n        taux_bascule_vm: Optional[Union[float, None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Builds the simulation data.\n\n        Args:\n            year (int): The year.\n            scenarios (Union[str, List[str], dict]): The scenarios.\n            taux_bascule_vm (Optional[Union[float, None]], optional): The rate of switching \"versement mobilit\u00e9\" to another tax base. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # Disjonction de cas suivant qu'un jeu de donn\u00e9es est ou non fourni en argument\n        if (\n            os.path.exists(\n                os.path.join(FILE_PATH.parents[2], f\"data/data_simulation_{year}.csv\")\n            )\n            is not None\n        ):\n            self._build_data_simulation_from_dataframe(year=year, scenarios=scenarios)\n        else:\n            self._init_data_simulation(\n                year=year, scenarios=scenarios, taux_bascule_vm=taux_bascule_vm\n            )\n\n    # Fonction auxiliaire de construction des donn\u00e9es DADS \u00e0 partir d'un DataFrame\n    def _build_data_simulation_from_dataframe(\n        self, year: int, scenarios: Union[str, List[str], dict]\n    ) -&gt; None:\n        \"\"\"\n        Builds the simulation data from a DataFrame.\n\n        Args:\n            year (int): The year.\n            scenarios (Union[str, List[str], dict]): The scenarios.\n\n        Returns:\n            None\n        \"\"\"\n        # Liste des variables de co\u00fbt du travail\n        list_var_ct = np.concatenate(\n            [\n                [\n                    f\"diff_ct_{name}\",\n                    f\"evol_ct_{name}\",\n                    f\"evol_ms_{name}\",\n                    f\"salaire_super_brut_{name}\",\n                ]\n                for name in self.scenarios_names(scenarios=scenarios)\n            ]\n        ).tolist()\n        # Importation des donn\u00e9es\n        self.data_simulation = pd.read_csv(\n            os.path.join(FILE_PATH.parents[2], f\"data/data_simulation_{year}.csv\"),\n            usecols=description_params[\"USECOLS\"] + list_var_ct,\n        )\n        # Logging\n        self.logger.info(\n            \"Successfully initialized data_simulation for DescriptionBuilder\"\n        )\n\n    # Fonction auxiliaire d'initialisation du jeu de donn\u00e9es de simulation en les r\u00e9alisant int\u00e9gralement\n    def _init_data_simulation(\n        self,\n        year: int,\n        scenarios: dict,\n        taux_bascule_vm: Optional[Union[float, None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the simulation data.\n\n        Args:\n            year (int): The year.\n            scenarios (dict): The scenarios.\n            taux_bascule_vm (Optional[Union[float, None]], optional): The rate of switching to VM. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # Simulation des cotisations et all\u00e8gements\n        # Initialisation\n        core_simulation = CoreSimulation()\n        # It\u00e9ration sur les ann\u00e9es de config\n        core_simulation.build(year_data=year, year_simul=year)\n\n        # Simulation de r\u00e9formes\n        reform_simulation = ReformSimulation()\n        # It\u00e9ration\n        reform_simulation.build(\n            scenarios=scenarios,\n            taux_bascule_vm=taux_bascule_vm,\n            data=core_simulation.self.data_simulation,\n        )\n\n        # Liste des variables de co\u00fbt du travail\n        list_var_ct = np.concatenate(\n            [\n                [\n                    f\"diff_ct_{name}\",\n                    f\"evol_ct_{name}\",\n                    f\"evol_ms_{name}\",\n                    f\"salaire_super_brut_{name}\",\n                ]\n                for name in self.scenarios_names(scenarios=scenarios)\n            ]\n        ).tolist()\n\n        # Ajout du jeu de donn\u00e9es\n        self.data_simulation = reform_simulation.data_simulation[list_var_ct]\n\n        # Logging\n        self.logger.info(\n            \"Successfully initialized data_simulation for DescriptionBuilder\"\n        )\n\n    # Fonction auxiliaire d'ajout au jeu de donn\u00e9es des variables utiles relatives aux variables de co\u00fbts du travail\n    def add_labor_costs_variables(self, scenarios: Union[str, List[str], dict]) -&gt; None:\n        \"\"\"\n        Adds labor costs variables to the simulation data.\n\n        Args:\n            scenarios (Union[str, List[str], dict]): The scenarios.\n\n        Returns:\n            None\n        \"\"\"\n        # Ajout du salaire brut\n        self.data_simulation[\"salaire_brut\"] = self.data_simulation[\n            [\"salaire_de_base\", \"remuneration_apprenti\"]\n        ].sum(axis=1)\n        # Suppresion des colonnes inutiles\n        self.data_simulation.drop(\n            [\"salaire_de_base\", \"remuneration_apprenti\"], axis=1, inplace=True\n        )\n        # Ajout du montant de cotisations sociales\n        self.data_simulation[\"cotisations_sociales\"] = (\n            self.data_simulation[\"salaire_super_brut\"]\n            - self.data_simulation[\"salaire_brut\"]\n        )\n        # Ajout de tranches de salaire brut exprim\u00e9 en multiples du SMIC\n        self.data_simulation[\"tranche_salaire_brut_smic\"] = (\n            np.floor(self.data_simulation[\"salaire_brut_smic\"] * 10) / 10\n        )\n\n        # Calcul de tranches d'\u00e9volution du cout du travail et de la masse salariale\n        for name in tqdm(self.scenarios_names(scenarios=scenarios)):\n            # Ajout du montant de cotisations sociales\n            self.data_simulation[f\"cotisations_sociales_{name}\"] = (\n                self.data_simulation[f\"salaire_super_brut_{name}\"]\n                - self.data_simulation[\"salaire_brut\"]\n            )\n            # Suppression du salaire super brut\n            self.data_simulation.drop(\n                f\"salaire_super_brut_{name}\", axis=1, inplace=True\n            )\n            # Cr\u00e9ation de tranches d'\u00e9volution de la masse salariale\n            self.data_simulation[f\"tranche_evol_ct_{name}\"] = (\n                np.floor(self.data_simulation[f\"evol_ct_{name}\"] * 100) / 100\n            )\n            # Cr\u00e9ation de tranches d'\u00e9volution du cout du travail\n            self.data_simulation[f\"tranche_evol_ms_{name}\"] = (\n                np.floor(self.data_simulation[f\"evol_ms_{name}\"] * 100) / 100\n            )\n\n    # Fonction auxiliaire de cr\u00e9ation des effets emplois\n    def add_employment_effect(\n        self,\n        scenarios: Union[str, List[str], dict],\n        name_elasticite: str,\n        y0_elasticite: Optional[Union[float, None]] = None,\n        seuil_pallier_elasticite_smic: Optional[Union[float, None]] = None,\n        pallier_elasticite: Optional[Union[float, None]] = None,\n        type_elasticite: Optional[Union[str, None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Adds employment effect to the simulation data.\n\n        Args:\n            scenarios (Union[str, List[str], dict]): The scenarios.\n            name_elasticite (str): The name of the elasticity.\n            y0_elasticite (Optional[Union[float, None]], optional): The initial value of the elasticity. Defaults to None.\n            seuil_pallier_elasticite_smic (Optional[Union[float, None]], optional): The threshold of the elasticity in SMIC. Defaults to None.\n            pallier_elasticite (Optional[Union[float, None]], optional): The step of the elasticity. Defaults to None.\n            type_elasticite (Optional[Union[str, None]], optional): The type of the elasticity. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # Construction des \u00e9lasticit\u00e9s\n        # Si un des \u00e9l\u00e9ments n'est pas retouv\u00e9, on recherche les param\u00e8tres correspondant au nom parmi ceux pr\u00e9d\u00e9finis\n        if (\n            (y0_elasticite is None)\n            | (seuil_pallier_elasticite_smic is None)\n            | (pallier_elasticite is None)\n            | (type_elasticite is None)\n        ):\n            dict_elasticite = elasticite_params[\"ELASTICITES\"][name_elasticite]\n        # Construction du dictionnaire \u00e0 partir des param\u00e8tres en argument\n        else:\n            dict_elasticite = {\n                \"y0_elasticite\": y0_elasticite,\n                \"seuil_pallier_elasticite_smic\": seuil_pallier_elasticite_smic,\n                \"pallier_elasticite\": pallier_elasticite,\n                \"type_elasticite\": type_elasticite,\n            }\n        # Parcours des sc\u00e9narios\n        for name in self.scenarios_names(scenarios=scenarios):\n            # Identification de la colonne d'\u00e9volution\n            col_evol = (\n                f\"evol_ct_{name}\"\n                if dict_elasticite[\"type_elasticite\"] == \"indiv\"\n                else f\"evol_ms_{name}\"\n            )\n            # Ajout des effets emploi\n            self.data_simulation = build_data_evol_emploi(\n                data_source=self.data_simulation,\n                col_new_ct=f\"salaire_super_brut_{name}\",\n                col_evol=col_evol,\n                y0_elasticite=dict_elasticite[\"y0_elasticite\"],\n                seuil_pallier_elasticite_smic=dict_elasticite[\n                    \"seuil_pallier_elasticite_smic\"\n                ],\n                pallier_elasticite=dict_elasticite[\"pallier_elasticite\"],\n                name_elasticite=name_elasticite,\n                keep_elast=False,\n                to_concat=True,\n                col_ct=\"salaire_super_brut\",\n            )\n            # Suppression de la quotit\u00e9 de travail s'il s'agit d'une \u00e9lasticit\u00e9 \"entreprise\"\n            if dict_elasticite[\"type_elasticite\"] == \"firm\":\n                self.data_simulation.drop(\n                    f\"quotite_de_travail_{name_elasticite}_{name}\", axis=1, inplace=True\n                )\n\n    # Fonction auxiliaire d'ajout des effets emploi de l'ensemble des \u00e9lasticit\u00e9s en param\u00e8tres\n    def add_employment_effects(\n        self,\n        scenarios: Union[str, List[str], dict],\n        elasticites_names: Optional[Union[List[str], None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Adds employment effects to the simulation data.\n\n        Args:\n            scenarios (Union[str, List[str], dict]): The scenarios.\n            elasticites_names (Optional[Union[List[str], None]], optional): The names of the elasticities. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialisation de la slite des \u00e9lasticit\u00e9s \u00e0 parcourir\n        elasticites_names = (\n            elasticite_params[\"ELASTICITES\"].keys()\n            if elasticites_names is None\n            else elasticites_names\n        )\n        # Parcours des \u00e9lasticit\u00e9s en param\u00e8tres\n        for name_elasticite in tqdm(elasticites_names):\n            self.add_employment_effect(\n                scenarios=scenarios, name_elasticite=name_elasticite\n            )\n        # Suppression des variables d'\u00e9volution du cout du travail et de la masse salariale apr\u00e8s la cr\u00e9ation des tranches\n        self.data_simulation.drop(\n            np.concatenate(\n                [\n                    [f\"evol_ct_{name}\", f\"evol_ms_{name}\"]\n                    for name in self.scenarios_names(scenarios=scenarios)\n                ]\n            ).tolist(),\n            axis=1,\n            inplace=True,\n        )\n\n    # Fonction auxiliaire de combinaison des effets emplois individuels et au niveau de l'entreprise\n    def combine_firm_indiv_effect(\n        self,\n        scenarios: dict,\n        name_indiv_elasticite: str,\n        name_firm_elasticite: str,\n        add_weights: bool,\n    ) -&gt; None:\n        \"\"\"\n        Combines firm and individual employment effects.\n\n        Args:\n            scenarios (dict): The scenarios.\n            name_indiv_elasticite (str): The name of the individual elasticity.\n            name_firm_elasticite (str): The name of the firm elasticity.\n            add_weights (bool): Whether to add weights.\n\n        Returns:\n            None\n        \"\"\"\n        # Parcours des sc\u00e9narios\n        for name in self.scenarios_names(scenarios=scenarios):\n            # Ajout de l'effet emploi\n            self.data_simulation[\n                f\"effet_emploi_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n            ] = self.data_simulation[\n                [\n                    f\"effet_emploi_{name_indiv_elasticite}_{name}\",\n                    f\"effet_emploi_{name_firm_elasticite}_{name}\",\n                ]\n            ].sum(\n                axis=1\n            )\n            # Ajout des poids\n            if add_weights:\n                # Reconstitution des quotit\u00e9s individus et entreprise\n                self.data_simulation[\n                    f\"quotite_de_travail_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n                ] = (\n                    self.data_simulation[\"quotite_de_travail\"]\n                    + self.data_simulation[\n                        f\"effet_emploi_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n                    ]\n                )\n                # Cr\u00e9ation des poids idoines\n                self.data_simulation[\n                    f\"weights_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n                ] = np.maximum(\n                    self.data_simulation[\"weights\"]\n                    * self.data_simulation[\n                        f\"quotite_de_travail_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n                    ]\n                    / self.data_simulation[\"quotite_de_travail\"],\n                    0,\n                )\n                # Suppression de la quotit\u00e9 de travail\n                self.data_simulation.drop(\n                    f\"quotite_de_travail_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\",\n                    axis=1,\n                    inplace=True,\n                )\n            # Suppression de la quotit\u00e9 de travail individuelle et de l'effet emploi individuel\n            self.data_simulation.drop(\n                [\n                    f\"quotite_de_travail_{name_indiv_elasticite}_{name}\",\n                    f\"effet_emploi_{name_indiv_elasticite}_{name}\",\n                ],\n                axis=1,\n                inplace=True,\n            )\n\n    # Fonction auxiliaire d'it\u00e9ration des combinaisons d'effets emploi au niveau de l'individu et de l'entreprise\n    def combine_firm_indiv_effects(\n        self,\n        scenarios: dict,\n        name_firm_elasticite: str,\n        elasticite_names: Optional[Union[List[str], None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Combines firm and individual employment effects for all scenarios.\n\n        Args:\n            scenarios (dict): The scenarios.\n            name_firm_elasticite (str): The name of the firm elasticity.\n            elasticite_names (Optional[Union[List[str], None]], optional): The names of the elasticities. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialisation de la liste des \u00e9lasticit\u00e9s \u00e0 parcourir\n        list_elasticite_names = (\n            list(elasticite_params[\"ELASTICITES\"].keys())\n            if elasticite_names is None\n            else elasticite_names\n        )\n        # Initialisation de la liste des \u00e9lasticit\u00e9s \u00e0 combiner\n        list_elasticite_combine = []\n        # Parcours des \u00e9lasticit\u00e9s en param\u00e8tres afin de d\u00e9terminer celles au niveau individuel qu'il faut combiner et  s'il faut ou non y ajouter des poids\n        for name_elasticite in list_elasticite_names:\n            if (\n                elasticite_params[\"ELASTICITES\"][name_elasticite][\"type_elasticite\"]\n                == \"indiv\"\n            ) &amp; elasticite_params[\"ELASTICITES\"][name_elasticite][\"combine\"]:\n                list_elasticite_combine.append(\n                    {\n                        \"name_indiv_elasticite\": name_elasticite,\n                        \"add_weights\": elasticite_params[\"ELASTICITES\"][\n                            name_elasticite\n                        ][\"add_weights\"],\n                    }\n                )\n            elif (\n                elasticite_params[\"ELASTICITES\"][name_elasticite][\"type_elasticite\"]\n                == \"indiv\"\n            ):\n                # Suppression des variables inutiles\n                self.data_simulation.drop(\n                    [\n                        f\"quotite_de_travail_{name_elasticite}_{name}\"\n                        for name in self.scenarios_names(scenarios=scenarios)\n                    ],\n                    axis=1,\n                    inplace=True,\n                )\n        # Parcours des \u00e9lasticit\u00e9s individuelles et ajout des combinaisons\n        for elasticite_combine in tqdm(list_elasticite_combine):\n            self.combine_firm_indiv_effect(\n                scenarios=scenarios,\n                name_indiv_elasticite=elasticite_combine[\"name_indiv_elasticite\"],\n                name_firm_elasticite=name_firm_elasticite,\n                add_weights=elasticite_combine[\"add_weights\"],\n            )\n        # Suppression des effets emploi au niveau de l'entreprise associ\u00e9s \u00e0 chaque sc\u00e9nario\n        self.data_simulation.drop(\n            [\n                f\"effet_emploi_{name_firm_elasticite}_{name}\"\n                for name in self.scenarios_names(scenarios=scenarios)\n            ],\n            axis=1,\n            inplace=True,\n        )\n\n    # Fonction auxiliaire de chargement et de retraitement des donn\u00e9es DADS\n    def build_data_dads(self, year: int) -&gt; None:\n        \"\"\"\n        Builds the DADS data.\n\n        Args:\n            year (int): The year.\n\n        Returns:\n            None\n        \"\"\"\n        # Filtre sur les lignes (s\u00e9lection des postes principaux de l'ann\u00e9e du mill\u00e9sime)\n        filter_dads = [(\"annee\", \"==\", f\"{year}\"), (\"pps\", \"==\", \"1\")]\n\n        # Chargement des donn\u00e9es\n        self.data_dads = load_dads(\n            project=self.project,\n            year=year,\n            columns=description_params[\"DADS\"][\"COLONNES\"],\n            filters=filter_dads,\n        )\n\n        # Suppression des colonnes inutiles\n        self.data_dads.drop([\"annee\", \"pps\"], axis=1, inplace=True)\n\n        # Suppression des duplicats par SIREN\n        self.data_dads.drop_duplicates(subset=[\"siren\"], keep=\"first\", inplace=True)\n        # Conversion en num\u00e9riques\n        self.data_dads[\"siren\"] = pd.to_numeric(\n            self.data_dads[\"siren\"], errors=\"coerce\"\n        )\n        # Suppression des Nan\n        self.data_dads.dropna(subset=[\"siren\"], how=\"any\", inplace=True)\n        # Ajout d'une variante excluant l'int\u00e9rim et le nettoyage\n        # Interim\n        self.data_dads[\"a17_interim_nettoyage\"] = np.where(\n            self.data_dads[\"apen\"].isin([\"7820Z\"]), \"interim\", self.data_dads[\"a17\"]\n        )\n        # Nettoyage\n        self.data_dads[\"a17_interim_nettoyage\"] = np.where(\n            self.data_dads[\"apen\"].isin([\"8121Z\", \"8122Z\", \"8129A\", \"8129B\"]),\n            \"nettoyage\",\n            self.data_dads[\"a17_interim_nettoyage\"],\n        )\n\n    # Fonction auxiliaire de chargement et de retraitement des donn\u00e9es FARE\n    def build_data_fare(self, year: int) -&gt; None:\n        \"\"\"\n        Builds the FARE data.\n\n        Args:\n            year (int): The year.\n\n        Returns:\n            None\n        \"\"\"\n        # Filtre sur les unit\u00e9s l\u00e9gales\n        filter_fare = [(\"diff_ul\", \"==\", \"1\")]\n        # Chargement des donn\u00e9es\n        self.data_fare = load_fare(\n            project=self.project,\n            year=year,\n            columns=description_params[\"FARE\"][\"COLONNES\"],\n            filters=filter_fare,\n        )\n\n        # Suppression de diff_ul\n        self.data_fare.drop(\"diff_ul\", axis=1, inplace=True)\n        # Suppression des duplicates par SIREN\n        self.data_fare.drop_duplicates(subset=[\"siren\"], keep=\"first\", inplace=True)\n        # Conversion en types num\u00e9riques et suppression des Nan\n        self.data_fare[\"siren\"] = pd.to_numeric(\n            self.data_fare[\"siren\"], errors=\"coerce\"\n        )\n        self.data_fare.dropna(subset=[\"siren\"], how=\"any\", inplace=True)\n\n    # Fonction auxiliaire d'appariement des donn\u00e9es\n    def merge_data_simulation_dads_fare(\n        self, year: Optional[Union[int, None]] = None\n    ) -&gt; None:\n        \"\"\"\n        Merges the simulation, DADS, and FARE data.\n\n        Args:\n            year (Optional[Union[int, None]], optional): The year. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # V\u00e9rification que l'ensemble des jeux de donn\u00e9es \u00e0 apparier sont en attribut de la classe\n        # data_dads\n        if not hasattr(self, \"data_dads\"):\n            self.build_data_dads(year=year)\n        # data_fare\n        if not hasattr(self, \"data_fare\"):\n            self.build_data_fare(year=year)\n\n        # Appariements\n        # Ajout des donn\u00e9es DADS\n        self.data_simulation = pd.merge(\n            left=self.data_simulation,\n            right=self.data_dads,\n            on=\"siren\",\n            how=\"left\",\n            validate=\"many_to_one\",\n            indicator=True,\n        )\n        # V\u00e9rification de la qualit\u00e9 de l'appariement\n        _serie_merge_check = self.data_simulation[\"_merge\"].value_counts()\n        # Logging\n        self.logger.info(\n            f\"Merge data_simulation &lt;- data_dads : both : {_serie_merge_check.loc['both']}, left_only : {_serie_merge_check.loc['left_only']}, right_only : {_serie_merge_check.loc['right_only']}\"\n        )\n        # Suppression de la colonne d'appariement\n        self.data_simulation.drop(\"_merge\", axis=1, inplace=True)\n\n        # Ajout des donn\u00e9es FARE\n        self.data_simulation = pd.merge(\n            left=self.data_simulation,\n            right=self.data_fare,\n            on=\"siren\",\n            how=\"left\",\n            validate=\"many_to_one\",\n            indicator=True,\n        )\n        # V\u00e9rification de la qualit\u00e9 de l'appariement\n        _serie_merge_check = self.data_simulation[\"_merge\"].value_counts()\n        # Logging\n        self.logger.info(\n            f\"Merge data_simulation &lt;- data_fare : both : {_serie_merge_check.loc['both']}, left_only : {_serie_merge_check.loc['left_only']}, right_only : {_serie_merge_check.loc['right_only']}\"\n        )\n        # Suppression de la colonne d'appariement\n        self.data_simulation.drop(\"_merge\", axis=1, inplace=True)\n\n    # Fonction de construction du jeu de donn\u00e9es de description\n    def build(\n        self,\n        year: int,\n        scenarios: dict,\n        name_firm_elasticite: str,\n        elasticite_names: Optional[Union[List[str], None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Builds the description dataset.\n\n        Args:\n            year (int): The year.\n            scenarios (dict): The scenarios.\n            name_firm_elasticite (str): The name of the firm elasticity.\n            elasticite_names (Optional[Union[List[str], None]], optional): The names of the elasticities. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        # Construction des donn\u00e9es de simulation\n        self.build_data_simulation(year=year, scenarios=scenarios)\n        # Ajout des variables de cout du travail\n        self.add_labor_costs_variables(scenarios=scenarios)\n        # Ajout des effets emploi\n        self.add_employment_effects(\n            scenarios=scenarios, elasticites_names=elasticite_names\n        )\n        # Combinaisons des effets individuels et au niveau de l'entreprise\n        self.combine_firm_indiv_effects(\n            scenarios=scenarios, name_firm_elasticite=name_firm_elasticite\n        )\n        # Ajout des variables auxiliaires issues des DADS et de FARE\n        self.merge_data_simulation_dads_fare(year=year)\n\n    # Fonction d'it\u00e9ration des statistiques descriptives\n    def stat_des(\n        self,\n        year: int,\n        list_var_groupby: List[str],\n        list_var_of_interest: List[str],\n        output_folder_path: os.PathLike,\n        export_filename: str,\n    ) -&gt; Union[Tuple[pd.DataFrame, pd.DataFrame], None]:\n        \"\"\"\n        Calculates descriptive statistics.\n\n        Args:\n            year (int): The year.\n            list_var_groupby (List[str]): The variables to group by.\n            list_var_of_interest (List[str]): The variables of interest.\n            output_folder_path (os.PathLike): The path to the output folder.\n            export_filename (str): The name of the export file.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialisation de l'estimateur de statistiques descriptives\n        estimator = SecretStatEstimator(\n            data_source=self.data_simulation, \n            list_var_groupby=list_var_groupby, \n            list_var_of_interest=list_var_of_interest, \n            var_individu=\"ident_s\", \n            var_entreprise=\"siren\", \n            var_weights=\"weights\", \n            threshold_secret_stat_effectif_individu=5, \n            threshold_secret_stat_effectif_entreprise=3, \n            threshold_secret_stat_contrib_individu=0.8, \n            threshold_secret_stat_contrib_entreprise=0.85, \n            strategy='total'\n        )\n        # Construction de la statistique descriptive et du contr\u00f4le du secret statistique\n        data_stat_des, data_secret_stat = estimator.estimate_secret_stat(\n            iterable_operations=[\"sum\"], \n            include_total=True, \n            drop=True, \n            fill_value=np.nan, \n            nest=False\n        )\n\n        # Si un chemin et une nom de fichier sont fournis, le jeu de donn\u00e9es est export\u00e9\n        if (output_folder_path is not None) &amp; (export_filename is not None):\n            # Initialisation des chemins d'export des statistiques descriptives et du contr\u00f4le du secret statistique\n            path_stat_des = os.path.join(\n                FILE_PATH.parents[2],\n                \"outputs\",\n                f\"{datetime.today().strftime('%Y-%m-%d')}/stat_des/{output_folder_path}\",\n            )\n            path_secret_stat = os.path.join(\n                FILE_PATH.parents[2],\n                \"outputs\",\n                f\"{datetime.today().strftime('%Y-%m-%d')}/secret_stat/{output_folder_path}\",\n            )\n            # Cr\u00e9ation du chemin s'il n'existe pas\n            if (not os.path.exists(path_stat_des)) | (\n                not os.path.exists(path_secret_stat)\n            ):\n                os.makedirs(path_stat_des)\n                os.makedirs(path_secret_stat)\n            # Exportation\n            data_stat_des.to_excel(f\"{path_stat_des}/stat_des_{export_filename}.xlsx\")\n            data_secret_stat.to_excel(\n                f\"{path_secret_stat}/secret_stat_{export_filename}.xlsx\"\n            )\n        # Sinon ils sont retourn\u00e9s\n        else:\n            return data_stat_des, data_secret_stat\n\n    # Fonction auxiliaire calculant les effets de premiers tours agr\u00e9g\u00e9s par sc\u00e9nario\n    def first_round_effects(\n        self,\n        data: pd.DataFrame,\n        variable: str,\n        name_elasticite: str,\n        scenarios: Union[str, List[str], dict],\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Calculates first round effects.\n\n        Args:\n            data (pd.DataFrame): The data.\n            variable (str): The variable.\n            name_elasticite (str): The name of the elasticity.\n            scenarios (Union[str, List[str], dict]): The scenarios.\n\n        Returns:\n            (pd.DataFrame): The first round effects.\n        \"\"\"\n        # Variables manquantes\n        missing_variables = np.setdiff1d(\n            [variable]\n            + [\n                f\"{variable}_{name}\"\n                for name in self.scenarios_names(scenarios=scenarios)\n            ],\n            data.columns.tolist(),\n        ).tolist()\n        # Si la variable est affect\u00e9e par les diff\u00e9rents sc\u00e9narios\n        if missing_variables == []:\n            # Parcours des diff\u00e9rentes sc\u00e9narii\n            # Effets statiques\n            stat_des_0t = pd.Series(\n                data=[(data[variable] * data[\"weights\"]).sum()]\n                + [\n                    (data[f\"{variable}_{name}\"] * data[\"weights\"]).sum()\n                    for name in self.scenarios_names(scenarios=scenarios)\n                ],\n                index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n                name=f\"{variable} (statiques)\",\n            )\n            # Effets de premier tour\n            stat_des_1t = pd.Series(\n                data=[(data[variable] * data[f\"weights\"]).sum()]\n                + [\n                    (\n                        data[f\"{variable}_{name}\"]\n                        * data[f\"weights_{name_elasticite}_{name}\"]\n                    ).sum()\n                    for name in self.scenarios_names(scenarios=scenarios)\n                ],\n                index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n                name=f\"{variable} (1er tour)\",\n            )\n            stat_des = pd.concat(\n                [stat_des_0t.to_frame(), stat_des_1t.to_frame()], axis=1, join=\"outer\"\n            )\n            # Diff\u00e9rence par rapport \u00e0 la situation actuelle\n            stat_des = pd.concat(\n                [\n                    stat_des,\n                    stat_des.subtract(other=stat_des.loc[\"Actuel\"]).add_prefix(\n                        \"variation_\"\n                    ),\n                ],\n                axis=1,\n            )\n\n        else:\n            # Parcours des diff\u00e9rentes sc\u00e9narii\n            # Effets statiques\n            stat_des_0t = pd.Series(\n                data=[(data[variable] * data[\"weights\"]).sum()]\n                * (len(self.scenarios_names(scenarios=scenarios)) + 1),\n                index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n                name=f\"{variable} (statiques)\",\n            )\n            # Effets de premier tour\n            stat_des_1t = pd.Series(\n                data=[(data[variable] * data[f\"weights\"]).sum()]\n                + [\n                    (data[variable] * data[f\"weights_{name_elasticite}_{name}\"]).sum()\n                    for name in self.scenarios_names(scenarios=scenarios)\n                ],\n                index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n                name=f\"{variable} (1er tour)\",\n            )\n            stat_des = pd.concat(\n                [stat_des_0t.to_frame(), stat_des_1t.to_frame()], axis=1, join=\"outer\"\n            )\n            # Diff\u00e9rence par rapport \u00e0 la situation actuelle\n            stat_des = pd.concat(\n                [\n                    stat_des,\n                    stat_des.subtract(other=stat_des.loc[\"Actuel\"]).add_prefix(\n                        \"variation_\"\n                    ),\n                ],\n                axis=1,\n            )\n\n        return stat_des\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.add_employment_effect","title":"add_employment_effect","text":"<pre><code>add_employment_effect(scenarios: Union[str, List[str], dict], name_elasticite: str, y0_elasticite: Optional[Union[float, None]] = None, seuil_pallier_elasticite_smic: Optional[Union[float, None]] = None, pallier_elasticite: Optional[Union[float, None]] = None, type_elasticite: Optional[Union[str, None]] = None) -&gt; None\n</code></pre> <p>Adds employment effect to the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios.</p> required <code>name_elasticite</code> <code>str</code> <p>The name of the elasticity.</p> required <code>y0_elasticite</code> <code>Optional[Union[float, None]]</code> <p>The initial value of the elasticity. Defaults to None.</p> <code>None</code> <code>seuil_pallier_elasticite_smic</code> <code>Optional[Union[float, None]]</code> <p>The threshold of the elasticity in SMIC. Defaults to None.</p> <code>None</code> <code>pallier_elasticite</code> <code>Optional[Union[float, None]]</code> <p>The step of the elasticity. Defaults to None.</p> <code>None</code> <code>type_elasticite</code> <code>Optional[Union[str, None]]</code> <p>The type of the elasticity. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def add_employment_effect(\n    self,\n    scenarios: Union[str, List[str], dict],\n    name_elasticite: str,\n    y0_elasticite: Optional[Union[float, None]] = None,\n    seuil_pallier_elasticite_smic: Optional[Union[float, None]] = None,\n    pallier_elasticite: Optional[Union[float, None]] = None,\n    type_elasticite: Optional[Union[str, None]] = None,\n) -&gt; None:\n    \"\"\"\n    Adds employment effect to the simulation data.\n\n    Args:\n        scenarios (Union[str, List[str], dict]): The scenarios.\n        name_elasticite (str): The name of the elasticity.\n        y0_elasticite (Optional[Union[float, None]], optional): The initial value of the elasticity. Defaults to None.\n        seuil_pallier_elasticite_smic (Optional[Union[float, None]], optional): The threshold of the elasticity in SMIC. Defaults to None.\n        pallier_elasticite (Optional[Union[float, None]], optional): The step of the elasticity. Defaults to None.\n        type_elasticite (Optional[Union[str, None]], optional): The type of the elasticity. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # Construction des \u00e9lasticit\u00e9s\n    # Si un des \u00e9l\u00e9ments n'est pas retouv\u00e9, on recherche les param\u00e8tres correspondant au nom parmi ceux pr\u00e9d\u00e9finis\n    if (\n        (y0_elasticite is None)\n        | (seuil_pallier_elasticite_smic is None)\n        | (pallier_elasticite is None)\n        | (type_elasticite is None)\n    ):\n        dict_elasticite = elasticite_params[\"ELASTICITES\"][name_elasticite]\n    # Construction du dictionnaire \u00e0 partir des param\u00e8tres en argument\n    else:\n        dict_elasticite = {\n            \"y0_elasticite\": y0_elasticite,\n            \"seuil_pallier_elasticite_smic\": seuil_pallier_elasticite_smic,\n            \"pallier_elasticite\": pallier_elasticite,\n            \"type_elasticite\": type_elasticite,\n        }\n    # Parcours des sc\u00e9narios\n    for name in self.scenarios_names(scenarios=scenarios):\n        # Identification de la colonne d'\u00e9volution\n        col_evol = (\n            f\"evol_ct_{name}\"\n            if dict_elasticite[\"type_elasticite\"] == \"indiv\"\n            else f\"evol_ms_{name}\"\n        )\n        # Ajout des effets emploi\n        self.data_simulation = build_data_evol_emploi(\n            data_source=self.data_simulation,\n            col_new_ct=f\"salaire_super_brut_{name}\",\n            col_evol=col_evol,\n            y0_elasticite=dict_elasticite[\"y0_elasticite\"],\n            seuil_pallier_elasticite_smic=dict_elasticite[\n                \"seuil_pallier_elasticite_smic\"\n            ],\n            pallier_elasticite=dict_elasticite[\"pallier_elasticite\"],\n            name_elasticite=name_elasticite,\n            keep_elast=False,\n            to_concat=True,\n            col_ct=\"salaire_super_brut\",\n        )\n        # Suppression de la quotit\u00e9 de travail s'il s'agit d'une \u00e9lasticit\u00e9 \"entreprise\"\n        if dict_elasticite[\"type_elasticite\"] == \"firm\":\n            self.data_simulation.drop(\n                f\"quotite_de_travail_{name_elasticite}_{name}\", axis=1, inplace=True\n            )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.add_employment_effects","title":"add_employment_effects","text":"<pre><code>add_employment_effects(scenarios: Union[str, List[str], dict], elasticites_names: Optional[Union[List[str], None]] = None) -&gt; None\n</code></pre> <p>Adds employment effects to the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios.</p> required <code>elasticites_names</code> <code>Optional[Union[List[str], None]]</code> <p>The names of the elasticities. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def add_employment_effects(\n    self,\n    scenarios: Union[str, List[str], dict],\n    elasticites_names: Optional[Union[List[str], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Adds employment effects to the simulation data.\n\n    Args:\n        scenarios (Union[str, List[str], dict]): The scenarios.\n        elasticites_names (Optional[Union[List[str], None]], optional): The names of the elasticities. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialisation de la slite des \u00e9lasticit\u00e9s \u00e0 parcourir\n    elasticites_names = (\n        elasticite_params[\"ELASTICITES\"].keys()\n        if elasticites_names is None\n        else elasticites_names\n    )\n    # Parcours des \u00e9lasticit\u00e9s en param\u00e8tres\n    for name_elasticite in tqdm(elasticites_names):\n        self.add_employment_effect(\n            scenarios=scenarios, name_elasticite=name_elasticite\n        )\n    # Suppression des variables d'\u00e9volution du cout du travail et de la masse salariale apr\u00e8s la cr\u00e9ation des tranches\n    self.data_simulation.drop(\n        np.concatenate(\n            [\n                [f\"evol_ct_{name}\", f\"evol_ms_{name}\"]\n                for name in self.scenarios_names(scenarios=scenarios)\n            ]\n        ).tolist(),\n        axis=1,\n        inplace=True,\n    )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.add_labor_costs_variables","title":"add_labor_costs_variables","text":"<pre><code>add_labor_costs_variables(scenarios: Union[str, List[str], dict]) -&gt; None\n</code></pre> <p>Adds labor costs variables to the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def add_labor_costs_variables(self, scenarios: Union[str, List[str], dict]) -&gt; None:\n    \"\"\"\n    Adds labor costs variables to the simulation data.\n\n    Args:\n        scenarios (Union[str, List[str], dict]): The scenarios.\n\n    Returns:\n        None\n    \"\"\"\n    # Ajout du salaire brut\n    self.data_simulation[\"salaire_brut\"] = self.data_simulation[\n        [\"salaire_de_base\", \"remuneration_apprenti\"]\n    ].sum(axis=1)\n    # Suppresion des colonnes inutiles\n    self.data_simulation.drop(\n        [\"salaire_de_base\", \"remuneration_apprenti\"], axis=1, inplace=True\n    )\n    # Ajout du montant de cotisations sociales\n    self.data_simulation[\"cotisations_sociales\"] = (\n        self.data_simulation[\"salaire_super_brut\"]\n        - self.data_simulation[\"salaire_brut\"]\n    )\n    # Ajout de tranches de salaire brut exprim\u00e9 en multiples du SMIC\n    self.data_simulation[\"tranche_salaire_brut_smic\"] = (\n        np.floor(self.data_simulation[\"salaire_brut_smic\"] * 10) / 10\n    )\n\n    # Calcul de tranches d'\u00e9volution du cout du travail et de la masse salariale\n    for name in tqdm(self.scenarios_names(scenarios=scenarios)):\n        # Ajout du montant de cotisations sociales\n        self.data_simulation[f\"cotisations_sociales_{name}\"] = (\n            self.data_simulation[f\"salaire_super_brut_{name}\"]\n            - self.data_simulation[\"salaire_brut\"]\n        )\n        # Suppression du salaire super brut\n        self.data_simulation.drop(\n            f\"salaire_super_brut_{name}\", axis=1, inplace=True\n        )\n        # Cr\u00e9ation de tranches d'\u00e9volution de la masse salariale\n        self.data_simulation[f\"tranche_evol_ct_{name}\"] = (\n            np.floor(self.data_simulation[f\"evol_ct_{name}\"] * 100) / 100\n        )\n        # Cr\u00e9ation de tranches d'\u00e9volution du cout du travail\n        self.data_simulation[f\"tranche_evol_ms_{name}\"] = (\n            np.floor(self.data_simulation[f\"evol_ms_{name}\"] * 100) / 100\n        )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.build","title":"build","text":"<pre><code>build(year: int, scenarios: dict, name_firm_elasticite: str, elasticite_names: Optional[Union[List[str], None]] = None) -&gt; None\n</code></pre> <p>Builds the description dataset.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <code>scenarios</code> <code>dict</code> <p>The scenarios.</p> required <code>name_firm_elasticite</code> <code>str</code> <p>The name of the firm elasticity.</p> required <code>elasticite_names</code> <code>Optional[Union[List[str], None]]</code> <p>The names of the elasticities. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def build(\n    self,\n    year: int,\n    scenarios: dict,\n    name_firm_elasticite: str,\n    elasticite_names: Optional[Union[List[str], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Builds the description dataset.\n\n    Args:\n        year (int): The year.\n        scenarios (dict): The scenarios.\n        name_firm_elasticite (str): The name of the firm elasticity.\n        elasticite_names (Optional[Union[List[str], None]], optional): The names of the elasticities. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # Construction des donn\u00e9es de simulation\n    self.build_data_simulation(year=year, scenarios=scenarios)\n    # Ajout des variables de cout du travail\n    self.add_labor_costs_variables(scenarios=scenarios)\n    # Ajout des effets emploi\n    self.add_employment_effects(\n        scenarios=scenarios, elasticites_names=elasticite_names\n    )\n    # Combinaisons des effets individuels et au niveau de l'entreprise\n    self.combine_firm_indiv_effects(\n        scenarios=scenarios, name_firm_elasticite=name_firm_elasticite\n    )\n    # Ajout des variables auxiliaires issues des DADS et de FARE\n    self.merge_data_simulation_dads_fare(year=year)\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.build_data_dads","title":"build_data_dads","text":"<pre><code>build_data_dads(year: int) -&gt; None\n</code></pre> <p>Builds the DADS data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def build_data_dads(self, year: int) -&gt; None:\n    \"\"\"\n    Builds the DADS data.\n\n    Args:\n        year (int): The year.\n\n    Returns:\n        None\n    \"\"\"\n    # Filtre sur les lignes (s\u00e9lection des postes principaux de l'ann\u00e9e du mill\u00e9sime)\n    filter_dads = [(\"annee\", \"==\", f\"{year}\"), (\"pps\", \"==\", \"1\")]\n\n    # Chargement des donn\u00e9es\n    self.data_dads = load_dads(\n        project=self.project,\n        year=year,\n        columns=description_params[\"DADS\"][\"COLONNES\"],\n        filters=filter_dads,\n    )\n\n    # Suppression des colonnes inutiles\n    self.data_dads.drop([\"annee\", \"pps\"], axis=1, inplace=True)\n\n    # Suppression des duplicats par SIREN\n    self.data_dads.drop_duplicates(subset=[\"siren\"], keep=\"first\", inplace=True)\n    # Conversion en num\u00e9riques\n    self.data_dads[\"siren\"] = pd.to_numeric(\n        self.data_dads[\"siren\"], errors=\"coerce\"\n    )\n    # Suppression des Nan\n    self.data_dads.dropna(subset=[\"siren\"], how=\"any\", inplace=True)\n    # Ajout d'une variante excluant l'int\u00e9rim et le nettoyage\n    # Interim\n    self.data_dads[\"a17_interim_nettoyage\"] = np.where(\n        self.data_dads[\"apen\"].isin([\"7820Z\"]), \"interim\", self.data_dads[\"a17\"]\n    )\n    # Nettoyage\n    self.data_dads[\"a17_interim_nettoyage\"] = np.where(\n        self.data_dads[\"apen\"].isin([\"8121Z\", \"8122Z\", \"8129A\", \"8129B\"]),\n        \"nettoyage\",\n        self.data_dads[\"a17_interim_nettoyage\"],\n    )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.build_data_fare","title":"build_data_fare","text":"<pre><code>build_data_fare(year: int) -&gt; None\n</code></pre> <p>Builds the FARE data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def build_data_fare(self, year: int) -&gt; None:\n    \"\"\"\n    Builds the FARE data.\n\n    Args:\n        year (int): The year.\n\n    Returns:\n        None\n    \"\"\"\n    # Filtre sur les unit\u00e9s l\u00e9gales\n    filter_fare = [(\"diff_ul\", \"==\", \"1\")]\n    # Chargement des donn\u00e9es\n    self.data_fare = load_fare(\n        project=self.project,\n        year=year,\n        columns=description_params[\"FARE\"][\"COLONNES\"],\n        filters=filter_fare,\n    )\n\n    # Suppression de diff_ul\n    self.data_fare.drop(\"diff_ul\", axis=1, inplace=True)\n    # Suppression des duplicates par SIREN\n    self.data_fare.drop_duplicates(subset=[\"siren\"], keep=\"first\", inplace=True)\n    # Conversion en types num\u00e9riques et suppression des Nan\n    self.data_fare[\"siren\"] = pd.to_numeric(\n        self.data_fare[\"siren\"], errors=\"coerce\"\n    )\n    self.data_fare.dropna(subset=[\"siren\"], how=\"any\", inplace=True)\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.build_data_simulation","title":"build_data_simulation","text":"<pre><code>build_data_simulation(year: int, scenarios: Union[str, List[str], dict], taux_bascule_vm: Optional[Union[float, None]] = None) -&gt; None\n</code></pre> <p>Builds the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios.</p> required <code>taux_bascule_vm</code> <code>Optional[Union[float, None]]</code> <p>The rate of switching \"versement mobilit\u00e9\" to another tax base. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def build_data_simulation(\n    self,\n    year: int,\n    scenarios: Union[str, List[str], dict],\n    taux_bascule_vm: Optional[Union[float, None]] = None,\n) -&gt; None:\n    \"\"\"\n    Builds the simulation data.\n\n    Args:\n        year (int): The year.\n        scenarios (Union[str, List[str], dict]): The scenarios.\n        taux_bascule_vm (Optional[Union[float, None]], optional): The rate of switching \"versement mobilit\u00e9\" to another tax base. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # Disjonction de cas suivant qu'un jeu de donn\u00e9es est ou non fourni en argument\n    if (\n        os.path.exists(\n            os.path.join(FILE_PATH.parents[2], f\"data/data_simulation_{year}.csv\")\n        )\n        is not None\n    ):\n        self._build_data_simulation_from_dataframe(year=year, scenarios=scenarios)\n    else:\n        self._init_data_simulation(\n            year=year, scenarios=scenarios, taux_bascule_vm=taux_bascule_vm\n        )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.combine_firm_indiv_effect","title":"combine_firm_indiv_effect","text":"<pre><code>combine_firm_indiv_effect(scenarios: dict, name_indiv_elasticite: str, name_firm_elasticite: str, add_weights: bool) -&gt; None\n</code></pre> <p>Combines firm and individual employment effects.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios.</p> required <code>name_indiv_elasticite</code> <code>str</code> <p>The name of the individual elasticity.</p> required <code>name_firm_elasticite</code> <code>str</code> <p>The name of the firm elasticity.</p> required <code>add_weights</code> <code>bool</code> <p>Whether to add weights.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def combine_firm_indiv_effect(\n    self,\n    scenarios: dict,\n    name_indiv_elasticite: str,\n    name_firm_elasticite: str,\n    add_weights: bool,\n) -&gt; None:\n    \"\"\"\n    Combines firm and individual employment effects.\n\n    Args:\n        scenarios (dict): The scenarios.\n        name_indiv_elasticite (str): The name of the individual elasticity.\n        name_firm_elasticite (str): The name of the firm elasticity.\n        add_weights (bool): Whether to add weights.\n\n    Returns:\n        None\n    \"\"\"\n    # Parcours des sc\u00e9narios\n    for name in self.scenarios_names(scenarios=scenarios):\n        # Ajout de l'effet emploi\n        self.data_simulation[\n            f\"effet_emploi_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n        ] = self.data_simulation[\n            [\n                f\"effet_emploi_{name_indiv_elasticite}_{name}\",\n                f\"effet_emploi_{name_firm_elasticite}_{name}\",\n            ]\n        ].sum(\n            axis=1\n        )\n        # Ajout des poids\n        if add_weights:\n            # Reconstitution des quotit\u00e9s individus et entreprise\n            self.data_simulation[\n                f\"quotite_de_travail_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n            ] = (\n                self.data_simulation[\"quotite_de_travail\"]\n                + self.data_simulation[\n                    f\"effet_emploi_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n                ]\n            )\n            # Cr\u00e9ation des poids idoines\n            self.data_simulation[\n                f\"weights_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n            ] = np.maximum(\n                self.data_simulation[\"weights\"]\n                * self.data_simulation[\n                    f\"quotite_de_travail_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\"\n                ]\n                / self.data_simulation[\"quotite_de_travail\"],\n                0,\n            )\n            # Suppression de la quotit\u00e9 de travail\n            self.data_simulation.drop(\n                f\"quotite_de_travail_{name_indiv_elasticite}_{name_firm_elasticite}_{name}\",\n                axis=1,\n                inplace=True,\n            )\n        # Suppression de la quotit\u00e9 de travail individuelle et de l'effet emploi individuel\n        self.data_simulation.drop(\n            [\n                f\"quotite_de_travail_{name_indiv_elasticite}_{name}\",\n                f\"effet_emploi_{name_indiv_elasticite}_{name}\",\n            ],\n            axis=1,\n            inplace=True,\n        )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.combine_firm_indiv_effects","title":"combine_firm_indiv_effects","text":"<pre><code>combine_firm_indiv_effects(scenarios: dict, name_firm_elasticite: str, elasticite_names: Optional[Union[List[str], None]] = None) -&gt; None\n</code></pre> <p>Combines firm and individual employment effects for all scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios.</p> required <code>name_firm_elasticite</code> <code>str</code> <p>The name of the firm elasticity.</p> required <code>elasticite_names</code> <code>Optional[Union[List[str], None]]</code> <p>The names of the elasticities. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def combine_firm_indiv_effects(\n    self,\n    scenarios: dict,\n    name_firm_elasticite: str,\n    elasticite_names: Optional[Union[List[str], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Combines firm and individual employment effects for all scenarios.\n\n    Args:\n        scenarios (dict): The scenarios.\n        name_firm_elasticite (str): The name of the firm elasticity.\n        elasticite_names (Optional[Union[List[str], None]], optional): The names of the elasticities. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialisation de la liste des \u00e9lasticit\u00e9s \u00e0 parcourir\n    list_elasticite_names = (\n        list(elasticite_params[\"ELASTICITES\"].keys())\n        if elasticite_names is None\n        else elasticite_names\n    )\n    # Initialisation de la liste des \u00e9lasticit\u00e9s \u00e0 combiner\n    list_elasticite_combine = []\n    # Parcours des \u00e9lasticit\u00e9s en param\u00e8tres afin de d\u00e9terminer celles au niveau individuel qu'il faut combiner et  s'il faut ou non y ajouter des poids\n    for name_elasticite in list_elasticite_names:\n        if (\n            elasticite_params[\"ELASTICITES\"][name_elasticite][\"type_elasticite\"]\n            == \"indiv\"\n        ) &amp; elasticite_params[\"ELASTICITES\"][name_elasticite][\"combine\"]:\n            list_elasticite_combine.append(\n                {\n                    \"name_indiv_elasticite\": name_elasticite,\n                    \"add_weights\": elasticite_params[\"ELASTICITES\"][\n                        name_elasticite\n                    ][\"add_weights\"],\n                }\n            )\n        elif (\n            elasticite_params[\"ELASTICITES\"][name_elasticite][\"type_elasticite\"]\n            == \"indiv\"\n        ):\n            # Suppression des variables inutiles\n            self.data_simulation.drop(\n                [\n                    f\"quotite_de_travail_{name_elasticite}_{name}\"\n                    for name in self.scenarios_names(scenarios=scenarios)\n                ],\n                axis=1,\n                inplace=True,\n            )\n    # Parcours des \u00e9lasticit\u00e9s individuelles et ajout des combinaisons\n    for elasticite_combine in tqdm(list_elasticite_combine):\n        self.combine_firm_indiv_effect(\n            scenarios=scenarios,\n            name_indiv_elasticite=elasticite_combine[\"name_indiv_elasticite\"],\n            name_firm_elasticite=name_firm_elasticite,\n            add_weights=elasticite_combine[\"add_weights\"],\n        )\n    # Suppression des effets emploi au niveau de l'entreprise associ\u00e9s \u00e0 chaque sc\u00e9nario\n    self.data_simulation.drop(\n        [\n            f\"effet_emploi_{name_firm_elasticite}_{name}\"\n            for name in self.scenarios_names(scenarios=scenarios)\n        ],\n        axis=1,\n        inplace=True,\n    )\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.first_round_effects","title":"first_round_effects","text":"<pre><code>first_round_effects(data: DataFrame, variable: str, name_elasticite: str, scenarios: Union[str, List[str], dict]) -&gt; DataFrame\n</code></pre> <p>Calculates first round effects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data.</p> required <code>variable</code> <code>str</code> <p>The variable.</p> required <code>name_elasticite</code> <code>str</code> <p>The name of the elasticity.</p> required <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The first round effects.</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def first_round_effects(\n    self,\n    data: pd.DataFrame,\n    variable: str,\n    name_elasticite: str,\n    scenarios: Union[str, List[str], dict],\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates first round effects.\n\n    Args:\n        data (pd.DataFrame): The data.\n        variable (str): The variable.\n        name_elasticite (str): The name of the elasticity.\n        scenarios (Union[str, List[str], dict]): The scenarios.\n\n    Returns:\n        (pd.DataFrame): The first round effects.\n    \"\"\"\n    # Variables manquantes\n    missing_variables = np.setdiff1d(\n        [variable]\n        + [\n            f\"{variable}_{name}\"\n            for name in self.scenarios_names(scenarios=scenarios)\n        ],\n        data.columns.tolist(),\n    ).tolist()\n    # Si la variable est affect\u00e9e par les diff\u00e9rents sc\u00e9narios\n    if missing_variables == []:\n        # Parcours des diff\u00e9rentes sc\u00e9narii\n        # Effets statiques\n        stat_des_0t = pd.Series(\n            data=[(data[variable] * data[\"weights\"]).sum()]\n            + [\n                (data[f\"{variable}_{name}\"] * data[\"weights\"]).sum()\n                for name in self.scenarios_names(scenarios=scenarios)\n            ],\n            index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n            name=f\"{variable} (statiques)\",\n        )\n        # Effets de premier tour\n        stat_des_1t = pd.Series(\n            data=[(data[variable] * data[f\"weights\"]).sum()]\n            + [\n                (\n                    data[f\"{variable}_{name}\"]\n                    * data[f\"weights_{name_elasticite}_{name}\"]\n                ).sum()\n                for name in self.scenarios_names(scenarios=scenarios)\n            ],\n            index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n            name=f\"{variable} (1er tour)\",\n        )\n        stat_des = pd.concat(\n            [stat_des_0t.to_frame(), stat_des_1t.to_frame()], axis=1, join=\"outer\"\n        )\n        # Diff\u00e9rence par rapport \u00e0 la situation actuelle\n        stat_des = pd.concat(\n            [\n                stat_des,\n                stat_des.subtract(other=stat_des.loc[\"Actuel\"]).add_prefix(\n                    \"variation_\"\n                ),\n            ],\n            axis=1,\n        )\n\n    else:\n        # Parcours des diff\u00e9rentes sc\u00e9narii\n        # Effets statiques\n        stat_des_0t = pd.Series(\n            data=[(data[variable] * data[\"weights\"]).sum()]\n            * (len(self.scenarios_names(scenarios=scenarios)) + 1),\n            index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n            name=f\"{variable} (statiques)\",\n        )\n        # Effets de premier tour\n        stat_des_1t = pd.Series(\n            data=[(data[variable] * data[f\"weights\"]).sum()]\n            + [\n                (data[variable] * data[f\"weights_{name_elasticite}_{name}\"]).sum()\n                for name in self.scenarios_names(scenarios=scenarios)\n            ],\n            index=[\"Actuel\"] + self.scenarios_names(scenarios=scenarios),\n            name=f\"{variable} (1er tour)\",\n        )\n        stat_des = pd.concat(\n            [stat_des_0t.to_frame(), stat_des_1t.to_frame()], axis=1, join=\"outer\"\n        )\n        # Diff\u00e9rence par rapport \u00e0 la situation actuelle\n        stat_des = pd.concat(\n            [\n                stat_des,\n                stat_des.subtract(other=stat_des.loc[\"Actuel\"]).add_prefix(\n                    \"variation_\"\n                ),\n            ],\n            axis=1,\n        )\n\n    return stat_des\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.merge_data_simulation_dads_fare","title":"merge_data_simulation_dads_fare","text":"<pre><code>merge_data_simulation_dads_fare(year: Optional[Union[int, None]] = None) -&gt; None\n</code></pre> <p>Merges the simulation, DADS, and FARE data.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>Optional[Union[int, None]]</code> <p>The year. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def merge_data_simulation_dads_fare(\n    self, year: Optional[Union[int, None]] = None\n) -&gt; None:\n    \"\"\"\n    Merges the simulation, DADS, and FARE data.\n\n    Args:\n        year (Optional[Union[int, None]], optional): The year. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # V\u00e9rification que l'ensemble des jeux de donn\u00e9es \u00e0 apparier sont en attribut de la classe\n    # data_dads\n    if not hasattr(self, \"data_dads\"):\n        self.build_data_dads(year=year)\n    # data_fare\n    if not hasattr(self, \"data_fare\"):\n        self.build_data_fare(year=year)\n\n    # Appariements\n    # Ajout des donn\u00e9es DADS\n    self.data_simulation = pd.merge(\n        left=self.data_simulation,\n        right=self.data_dads,\n        on=\"siren\",\n        how=\"left\",\n        validate=\"many_to_one\",\n        indicator=True,\n    )\n    # V\u00e9rification de la qualit\u00e9 de l'appariement\n    _serie_merge_check = self.data_simulation[\"_merge\"].value_counts()\n    # Logging\n    self.logger.info(\n        f\"Merge data_simulation &lt;- data_dads : both : {_serie_merge_check.loc['both']}, left_only : {_serie_merge_check.loc['left_only']}, right_only : {_serie_merge_check.loc['right_only']}\"\n    )\n    # Suppression de la colonne d'appariement\n    self.data_simulation.drop(\"_merge\", axis=1, inplace=True)\n\n    # Ajout des donn\u00e9es FARE\n    self.data_simulation = pd.merge(\n        left=self.data_simulation,\n        right=self.data_fare,\n        on=\"siren\",\n        how=\"left\",\n        validate=\"many_to_one\",\n        indicator=True,\n    )\n    # V\u00e9rification de la qualit\u00e9 de l'appariement\n    _serie_merge_check = self.data_simulation[\"_merge\"].value_counts()\n    # Logging\n    self.logger.info(\n        f\"Merge data_simulation &lt;- data_fare : both : {_serie_merge_check.loc['both']}, left_only : {_serie_merge_check.loc['left_only']}, right_only : {_serie_merge_check.loc['right_only']}\"\n    )\n    # Suppression de la colonne d'appariement\n    self.data_simulation.drop(\"_merge\", axis=1, inplace=True)\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.scenarios_names","title":"scenarios_names","text":"<pre><code>scenarios_names(scenarios: Union[str, List[str], dict]) -&gt; List[str]\n</code></pre> <p>Extracts the names of scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The names of the scenarios.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type of scenarios is not 'dict', 'list' or 'str'.</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def scenarios_names(self, scenarios: Union[str, List[str], dict]) -&gt; List[str]:\n    \"\"\"\n    Extracts the names of scenarios.\n\n    Args:\n        scenarios (Union[str, List[str], dict]): The scenarios.\n\n    Returns:\n        (List[str]): The names of the scenarios.\n\n    Raises:\n        ValueError: If the type of scenarios is not 'dict', 'list' or 'str'.\n    \"\"\"\n    # Extraction des noms des scenarios\n    if isinstance(scenarios, str):\n        scenarios_names = [scenarios]\n    elif isinstance(scenarios, dict):\n        scenarios_names = [name.lower() for name in scenarios.keys()]\n    elif isinstance(scenarios, list):\n        scenarios_names = [name.lower() for name in scenarios]\n    else:\n        raise ValueError(\n            f\"Invalid type for scenarios : {type(scenarios)}. Should be in 'dict', 'list' or 'str'\"\n        )\n\n    return scenarios_names\n</code></pre>"},{"location":"api/DescriptionBuilder/#bozio_wasmer_simulations.description.base.DescriptionBuilder.stat_des","title":"stat_des","text":"<pre><code>stat_des(year: int, list_var_groupby: List[str], list_var_of_interest: List[str], output_folder_path: PathLike, export_filename: str) -&gt; Union[Tuple[DataFrame, DataFrame], None]\n</code></pre> <p>Calculates descriptive statistics.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year.</p> required <code>list_var_groupby</code> <code>List[str]</code> <p>The variables to group by.</p> required <code>list_var_of_interest</code> <code>List[str]</code> <p>The variables of interest.</p> required <code>output_folder_path</code> <code>PathLike</code> <p>The path to the output folder.</p> required <code>export_filename</code> <code>str</code> <p>The name of the export file.</p> required <p>Returns:</p> Type Description <code>Union[Tuple[DataFrame, DataFrame], None]</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/description/base.py</code> <pre><code>def stat_des(\n    self,\n    year: int,\n    list_var_groupby: List[str],\n    list_var_of_interest: List[str],\n    output_folder_path: os.PathLike,\n    export_filename: str,\n) -&gt; Union[Tuple[pd.DataFrame, pd.DataFrame], None]:\n    \"\"\"\n    Calculates descriptive statistics.\n\n    Args:\n        year (int): The year.\n        list_var_groupby (List[str]): The variables to group by.\n        list_var_of_interest (List[str]): The variables of interest.\n        output_folder_path (os.PathLike): The path to the output folder.\n        export_filename (str): The name of the export file.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialisation de l'estimateur de statistiques descriptives\n    estimator = SecretStatEstimator(\n        data_source=self.data_simulation, \n        list_var_groupby=list_var_groupby, \n        list_var_of_interest=list_var_of_interest, \n        var_individu=\"ident_s\", \n        var_entreprise=\"siren\", \n        var_weights=\"weights\", \n        threshold_secret_stat_effectif_individu=5, \n        threshold_secret_stat_effectif_entreprise=3, \n        threshold_secret_stat_contrib_individu=0.8, \n        threshold_secret_stat_contrib_entreprise=0.85, \n        strategy='total'\n    )\n    # Construction de la statistique descriptive et du contr\u00f4le du secret statistique\n    data_stat_des, data_secret_stat = estimator.estimate_secret_stat(\n        iterable_operations=[\"sum\"], \n        include_total=True, \n        drop=True, \n        fill_value=np.nan, \n        nest=False\n    )\n\n    # Si un chemin et une nom de fichier sont fournis, le jeu de donn\u00e9es est export\u00e9\n    if (output_folder_path is not None) &amp; (export_filename is not None):\n        # Initialisation des chemins d'export des statistiques descriptives et du contr\u00f4le du secret statistique\n        path_stat_des = os.path.join(\n            FILE_PATH.parents[2],\n            \"outputs\",\n            f\"{datetime.today().strftime('%Y-%m-%d')}/stat_des/{output_folder_path}\",\n        )\n        path_secret_stat = os.path.join(\n            FILE_PATH.parents[2],\n            \"outputs\",\n            f\"{datetime.today().strftime('%Y-%m-%d')}/secret_stat/{output_folder_path}\",\n        )\n        # Cr\u00e9ation du chemin s'il n'existe pas\n        if (not os.path.exists(path_stat_des)) | (\n            not os.path.exists(path_secret_stat)\n        ):\n            os.makedirs(path_stat_des)\n            os.makedirs(path_secret_stat)\n        # Exportation\n        data_stat_des.to_excel(f\"{path_stat_des}/stat_des_{export_filename}.xlsx\")\n        data_secret_stat.to_excel(\n            f\"{path_secret_stat}/secret_stat_{export_filename}.xlsx\"\n        )\n    # Sinon ils sont retourn\u00e9s\n    else:\n        return data_stat_des, data_secret_stat\n</code></pre>"},{"location":"api/EmpiricalSimulator/","title":"EmpiricalSimulator","text":""},{"location":"api/EmpiricalSimulator/#bozio_wasmer_simulations.simulation.empirical.base.EmpiricalSimulator","title":"EmpiricalSimulator","text":"<p>A class used to simulate empirical data.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger instance.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>class EmpiricalSimulator:\n    \"\"\"\n    A class used to simulate empirical data.\n\n    Attributes:\n        logger (logging.Logger):\n            A logger instance.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[3], \"logs/empirical_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the EmpiricalSimulator object.\n\n        Args:\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/empirical_simulation.log').\n\n\n        \"\"\"\n        # Initialisation du logger\n        self.logger = _init_logger(filename=log_filename)\n\n    # Fonction d'it\u00e9ration d'une simulation\n    def iterate_simulation(\n        self,\n        data: pd.DataFrame,\n        tax_benefit_system: TaxBenefitSystem,\n        year: int,\n        list_var_simul: List[str],\n        list_var_exclude: Optional[List[str]] = [],\n        inplace: Optional[bool] = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Iterates a simulation.\n\n        Args:\n            data (pd.DataFrame): The data to simulate.\n            tax_benefit_system (FranceTaxBenefitSystem): The tax benefit system.\n            year (int): The year of the simulation.\n            list_var_simul (List[str]): The list of variables to simulate.\n            list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n            inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n        \"\"\"\n        # Disjonction de cas suivant la n\u00e9cessit\u00e9 de r\u00e9aliser une copie ind\u00e9pendante du jeu de donn\u00e9es\n        if inplace:\n            data_res = data\n        else:\n            data_res = data.copy()\n\n        # Initialisation des param\u00e8tres de la simulation\n        simulation = SimulationBuilder().build_default_simulation(\n            tax_benefit_system, len(data_res)\n        )\n        # Ajout de l'ensemble des donn\u00e9es\n        # /!\\ On ajout 'smic_proratis\u00e9' aux variables \u00e0 exclure de l'imputation pour contourner l'\u00e9cueil de la mauvaise transition entre valeurs mensuelles et annuelles # + ['smic_proratise']\n        # Finalement retir\u00e9 car les r\u00e9mu restent divis\u00e9es par 12 et ne sont pas intersect\u00e9es avec la dur\u00e9e du contrat\n        # Il s'agit sans doute d'un point \u00e0 am\u00e9liorer dans le package\n        for caracteristic in np.setdiff1d(data_res.columns, list_var_exclude):\n            try:  # if not (caracteristic in ['id', 'siren']) :\n                simulation.set_input(\n                    caracteristic, year, data_res[caracteristic].to_numpy()\n                )\n                # logging\n                self.logger.info(\n                    f\"Successfully initialized {caracteristic} in the french tax benefit system\"\n                )\n            except Exception as e:\n                # Logging\n                self.logger.warning(\n                    f\"Cannot initialize {caracteristic} in the french tax benefit system : {e}\"\n                )\n                pass\n        # Ajout des cotisations et des all\u00e8gements g\u00e9n\u00e9raux\n        for var_simul in tqdm(list_var_simul):\n            data_res[var_simul] = simulation.calculate_add(var_simul, year)\n            # Logging\n            self.logger.info(f\"Successfully simulated {var_simul} for period {year}\")\n\n        return data_res\n\n    # Fonction de simulation du SMIC proratis\u00e9\n    def simulate_smic_proratise(\n        self,\n        data: pd.DataFrame,\n        year: int,\n        list_var_exclude: Optional[List[str]] = [],\n        inplace: Optional[bool] = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates the prorated minimum wage.\n\n        Args:\n            data (pd.DataFrame): The data to simulate.\n            year (int): The year of the simulation.\n            list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n            inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n        \"\"\"\n        # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal fran\u00e7ais\n        tax_benefit_system = FranceTaxBenefitSystem()\n\n        # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e des donn\u00e9es\n        data = self.iterate_simulation(\n            data=data,\n            tax_benefit_system=tax_benefit_system,\n            year=year,\n            list_var_simul=[\"smic_proratise\"],\n            list_var_exclude=list_var_exclude,\n            inplace=inplace,\n        )\n\n        return data\n</code></pre>"},{"location":"api/EmpiricalSimulator/#bozio_wasmer_simulations.simulation.empirical.base.EmpiricalSimulator.iterate_simulation","title":"iterate_simulation","text":"<pre><code>iterate_simulation(data: DataFrame, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str], list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Iterates a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>tax_benefit_system</code> <code>FranceTaxBenefitSystem</code> <p>The tax benefit system.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>The list of variables to simulate.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def iterate_simulation(\n    self,\n    data: pd.DataFrame,\n    tax_benefit_system: TaxBenefitSystem,\n    year: int,\n    list_var_simul: List[str],\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Iterates a simulation.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        tax_benefit_system (FranceTaxBenefitSystem): The tax benefit system.\n        year (int): The year of the simulation.\n        list_var_simul (List[str]): The list of variables to simulate.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Disjonction de cas suivant la n\u00e9cessit\u00e9 de r\u00e9aliser une copie ind\u00e9pendante du jeu de donn\u00e9es\n    if inplace:\n        data_res = data\n    else:\n        data_res = data.copy()\n\n    # Initialisation des param\u00e8tres de la simulation\n    simulation = SimulationBuilder().build_default_simulation(\n        tax_benefit_system, len(data_res)\n    )\n    # Ajout de l'ensemble des donn\u00e9es\n    # /!\\ On ajout 'smic_proratis\u00e9' aux variables \u00e0 exclure de l'imputation pour contourner l'\u00e9cueil de la mauvaise transition entre valeurs mensuelles et annuelles # + ['smic_proratise']\n    # Finalement retir\u00e9 car les r\u00e9mu restent divis\u00e9es par 12 et ne sont pas intersect\u00e9es avec la dur\u00e9e du contrat\n    # Il s'agit sans doute d'un point \u00e0 am\u00e9liorer dans le package\n    for caracteristic in np.setdiff1d(data_res.columns, list_var_exclude):\n        try:  # if not (caracteristic in ['id', 'siren']) :\n            simulation.set_input(\n                caracteristic, year, data_res[caracteristic].to_numpy()\n            )\n            # logging\n            self.logger.info(\n                f\"Successfully initialized {caracteristic} in the french tax benefit system\"\n            )\n        except Exception as e:\n            # Logging\n            self.logger.warning(\n                f\"Cannot initialize {caracteristic} in the french tax benefit system : {e}\"\n            )\n            pass\n    # Ajout des cotisations et des all\u00e8gements g\u00e9n\u00e9raux\n    for var_simul in tqdm(list_var_simul):\n        data_res[var_simul] = simulation.calculate_add(var_simul, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {var_simul} for period {year}\")\n\n    return data_res\n</code></pre>"},{"location":"api/EmpiricalSimulator/#bozio_wasmer_simulations.simulation.empirical.base.EmpiricalSimulator.simulate_smic_proratise","title":"simulate_smic_proratise","text":"<pre><code>simulate_smic_proratise(data: DataFrame, year: int, list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Simulates the prorated minimum wage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def simulate_smic_proratise(\n    self,\n    data: pd.DataFrame,\n    year: int,\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the prorated minimum wage.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        year (int): The year of the simulation.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal fran\u00e7ais\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e des donn\u00e9es\n    data = self.iterate_simulation(\n        data=data,\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=[\"smic_proratise\"],\n        list_var_exclude=list_var_exclude,\n        inplace=inplace,\n    )\n\n    return data\n</code></pre>"},{"location":"api/Loader/","title":"Loader","text":""},{"location":"api/Loader/#bozio_wasmer_simulations.datasets.base.Loader","title":"Loader","text":"<p>A class used to load data from 'csv', 'sas7bdat' and 'parquet' file formats.</p> Source code in <code>bozio_wasmer_simulations/datasets/base.py</code> <pre><code>class Loader:\n    \"\"\"\n    A class used to load data from 'csv', 'sas7bdat' and 'parquet' file formats.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the Loader object.\n        \"\"\"\n        pass\n\n    # Fonction auxiliaire de d\u00e9duction d'un masque \u00e0 partir de filtres\n    @staticmethod\n    def _build_mask_from_filters(\n        data: pd.DataFrame, filters: Union[List[Tuple], List[List[Tuple]]]\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Builds a mask from filters for a given dataframe.\n\n        Args:\n            data (pd.DataFrame):\n                The dataframe to build the mask for.\n            filters (Union[List[Tuple], List[List[Tuple]]]):\n                The filters to apply. Each filter is a tuple of (column, operator, value).\n                If filters is a list of tuples, all filters are applied in conjunction.\n                If filters is a list of lists of tuples, each list is applied in disjunction.\n\n        Returns:\n            (pd.DataFrame): The mask that can be used to filter the dataframe.\n        \"\"\"\n        # Si filters est une liste de tuples\n        if all(isinstance(i, tuple) for i in filters) and isinstance(filters, list):\n            # Initialisation de la s\u00e9rie r\u00e9sultat\n            mask = pd.Series(True, index=data.index)\n            # Parcours des filters\n            for conjonction_filter in filters:\n                col, op, val = conjonction_filter\n                mask &amp;= eval(f\"data['{col}'] {op} {val}\")\n        # Si filters est une liste de liste de tuples\n        elif all(\n            isinstance(i, list) and all(isinstance(j, tuple) for j in i)\n            for i in filters\n        ) and isinstance(filters, list):\n            # Initialisation de la s\u00e9rie r\u00e9sultat\n            mask = pd.Series(False, index=data.index)\n            # Parcours des filtres\n            for disjonction_filter in filters:\n                if isinstance(disjonction_filter, tuple):\n                    col, op, val = disjonction_filter\n                    mask |= eval(f\"data['{col}'] {op} {val}\")\n                elif isinstance(disjonction_filter, list):\n                    submask = pd.Series(True, index=data.index)\n                    for conjonction_filter in disjonction_filter:\n                        col, op, val = conjonction_filter\n                        submask &amp;= eval(f\"data['{col}'] {op} {val}\")\n                    mask |= submask\n        else:\n            raise TypeError(\n                f\"Invalid type for 'filters' : {filters}. Shoud be in [List[Tuple], List[List[Tuple]]]\"\n            )\n        return mask\n\n    # Fonction de chargement des donn\u00e9es SAS\n    def read_sas(\n        self,\n        path: os.PathLike,\n        columns: Optional[Union[None, List[str]]] = None,\n        filters: Optional[Union[None, List[str], List[List[str]]]] = None,\n        **kwargs,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Loads data from a SAS file.\n\n        Args:\n            path (os.PathLike):\n                The path to the SAS file.\n            columns (Optional[Union[None, List[str]]], optional):\n                The columns to load. If None, all columns are loaded.\n            filters (Optional[Union[None, List[str], List[List[str]]]], optional):\n                The filters to apply. Each filter is a tuple of (column, operator, value).\n                If filters is a list of tuples, all filters are applied in conjunction.\n                If filters is a list of lists of tuples, each list is applied in disjunction.\n            **kwargs\n                Additional arguments to pass to the pyreadstat.read_sas7bdat function.\n\n        Returns:\n            (pd.DataFrame): The loaded data.\n        \"\"\"\n        # Chargement des donn\u00e9es\n        data, _ = pyreadstat.read_sas7bdat(path, usecols=columns, **kwargs)\n        # Filtrage des donn\u00e9es\n        if filters is not None:\n            data = data.loc[self._build_mask_from_filters(data=data, filters=filters)]\n        return data\n\n    # Fonction de chargement des donn\u00e9es CSV\n    def read_csv(\n        self,\n        path: os.PathLike,\n        columns: Optional[Union[None, List[str]]] = None,\n        filters: Optional[Union[None, List[str], List[List[str]]]] = None,\n        **kwargs,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Loads data from a CSV file.\n\n        Args:\n            path (os.PathLike):\n                The path to the CSV file.\n            columns (Optional[Union[None, List[str]]], optional):\n                The columns to load. If None, all columns are loaded.\n            filters (Optional[Union[None, List[str], List[List[str]]]], optional):\n                The filters to apply. Each filter is a tuple of (column, operator, value).\n                If filters is a list of tuples, all filters are applied in conjunction.\n                If filters is a list of lists of tuples, each list is applied in disjunction.\n            **kwargs\n                Additional arguments to pass to the pd.read_csv function.\n\n        Returns:\n            (pd.DataFrame): The loaded data.\n        \"\"\"\n        # Chargement des donn\u00e9es\n        data = pd.read_csv(path, usecols=columns, **kwargs)\n        # Filtrage des donn\u00e9es\n        if filters is not None:\n            data = data.loc[self._build_mask_from_filters(data=data, filters=filters)]\n        return data\n\n    # Fonction g\u00e9n\u00e9rale de chargement des donn\u00e9es\n    def load(\n        self,\n        path: os.PathLike,\n        columns: Optional[Union[None, List[str]]] = None,\n        filters: Optional[Union[None, List[str], List[List[str]]]] = None,\n        **kwargs,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Loads data from a file based on its extension.\n\n        Args:\n            path (os.PathLike):\n                The path to the file.\n            columns (Optional[Union[None, List[str]]], optional):\n                The columns to load. If None, all columns are loaded.\n            filters (Optional[Union[None, List[str], List[List[str]]]], optional):\n                The filters to apply. Each filter is a tuple of (column, operator, value).\n                If filters is a list of tuples, all filters are applied in conjunction.\n                If filters is a list of lists of tuples, each list is applied in disjunction.\n            **kwargs\n                Additional arguments to pass to the appropriate function.\n\n        Returns:\n            (pd.DataFrame): The loaded data.\n\n        Raises:\n            ValueError: If the file extension is not 'parquet', 'sas7bdat', or 'csv'.\n        \"\"\"\n        # Extraction de l'extension du fichier \u00e0 charger\n        extension = path.split(\".\")[-1]\n        # Distinction de la m\u00e9thode de chargement suivant l'extension\n        if (extension == \"parquet\") | (os.path.isdir(path)):\n            data = pd.read_parquet(path, columns=columns, filters=filters, **kwargs)\n        elif extension == \"sas7bdat\":\n            data = self.read_sas(path=path, columns=columns, filters=filters, **kwargs)\n        elif extension == \"csv\":\n            data = self.read_csv(path=path, columns=columns, filters=filters, **kwargs)\n        else:\n            raise ValueError(\n                f\"Unknown extention : {extension}. Should be in ['parquet', 'sas7bdat', 'csv']\"\n            )\n\n        return data\n</code></pre>"},{"location":"api/Loader/#bozio_wasmer_simulations.datasets.base.Loader.load","title":"load","text":"<pre><code>load(path: PathLike, columns: Optional[Union[None, List[str]]] = None, filters: Optional[Union[None, List[str], List[List[str]]]] = None, **kwargs) -&gt; DataFrame\n</code></pre> <p>Loads data from a file based on its extension.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the file.</p> required <code>columns</code> <code>Optional[Union[None, List[str]]]</code> <p>The columns to load. If None, all columns are loaded.</p> <code>None</code> <code>filters</code> <code>Optional[Union[None, List[str], List[List[str]]]]</code> <p>The filters to apply. Each filter is a tuple of (column, operator, value). If filters is a list of tuples, all filters are applied in conjunction. If filters is a list of lists of tuples, each list is applied in disjunction.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is not 'parquet', 'sas7bdat', or 'csv'.</p> Source code in <code>bozio_wasmer_simulations/datasets/base.py</code> <pre><code>def load(\n    self,\n    path: os.PathLike,\n    columns: Optional[Union[None, List[str]]] = None,\n    filters: Optional[Union[None, List[str], List[List[str]]]] = None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Loads data from a file based on its extension.\n\n    Args:\n        path (os.PathLike):\n            The path to the file.\n        columns (Optional[Union[None, List[str]]], optional):\n            The columns to load. If None, all columns are loaded.\n        filters (Optional[Union[None, List[str], List[List[str]]]], optional):\n            The filters to apply. Each filter is a tuple of (column, operator, value).\n            If filters is a list of tuples, all filters are applied in conjunction.\n            If filters is a list of lists of tuples, each list is applied in disjunction.\n        **kwargs\n            Additional arguments to pass to the appropriate function.\n\n    Returns:\n        (pd.DataFrame): The loaded data.\n\n    Raises:\n        ValueError: If the file extension is not 'parquet', 'sas7bdat', or 'csv'.\n    \"\"\"\n    # Extraction de l'extension du fichier \u00e0 charger\n    extension = path.split(\".\")[-1]\n    # Distinction de la m\u00e9thode de chargement suivant l'extension\n    if (extension == \"parquet\") | (os.path.isdir(path)):\n        data = pd.read_parquet(path, columns=columns, filters=filters, **kwargs)\n    elif extension == \"sas7bdat\":\n        data = self.read_sas(path=path, columns=columns, filters=filters, **kwargs)\n    elif extension == \"csv\":\n        data = self.read_csv(path=path, columns=columns, filters=filters, **kwargs)\n    else:\n        raise ValueError(\n            f\"Unknown extention : {extension}. Should be in ['parquet', 'sas7bdat', 'csv']\"\n        )\n\n    return data\n</code></pre>"},{"location":"api/Loader/#bozio_wasmer_simulations.datasets.base.Loader.read_csv","title":"read_csv","text":"<pre><code>read_csv(path: PathLike, columns: Optional[Union[None, List[str]]] = None, filters: Optional[Union[None, List[str], List[List[str]]]] = None, **kwargs) -&gt; DataFrame\n</code></pre> <p>Loads data from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the CSV file.</p> required <code>columns</code> <code>Optional[Union[None, List[str]]]</code> <p>The columns to load. If None, all columns are loaded.</p> <code>None</code> <code>filters</code> <code>Optional[Union[None, List[str], List[List[str]]]]</code> <p>The filters to apply. Each filter is a tuple of (column, operator, value). If filters is a list of tuples, all filters are applied in conjunction. If filters is a list of lists of tuples, each list is applied in disjunction.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The loaded data.</p> Source code in <code>bozio_wasmer_simulations/datasets/base.py</code> <pre><code>def read_csv(\n    self,\n    path: os.PathLike,\n    columns: Optional[Union[None, List[str]]] = None,\n    filters: Optional[Union[None, List[str], List[List[str]]]] = None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Loads data from a CSV file.\n\n    Args:\n        path (os.PathLike):\n            The path to the CSV file.\n        columns (Optional[Union[None, List[str]]], optional):\n            The columns to load. If None, all columns are loaded.\n        filters (Optional[Union[None, List[str], List[List[str]]]], optional):\n            The filters to apply. Each filter is a tuple of (column, operator, value).\n            If filters is a list of tuples, all filters are applied in conjunction.\n            If filters is a list of lists of tuples, each list is applied in disjunction.\n        **kwargs\n            Additional arguments to pass to the pd.read_csv function.\n\n    Returns:\n        (pd.DataFrame): The loaded data.\n    \"\"\"\n    # Chargement des donn\u00e9es\n    data = pd.read_csv(path, usecols=columns, **kwargs)\n    # Filtrage des donn\u00e9es\n    if filters is not None:\n        data = data.loc[self._build_mask_from_filters(data=data, filters=filters)]\n    return data\n</code></pre>"},{"location":"api/Loader/#bozio_wasmer_simulations.datasets.base.Loader.read_sas","title":"read_sas","text":"<pre><code>read_sas(path: PathLike, columns: Optional[Union[None, List[str]]] = None, filters: Optional[Union[None, List[str], List[List[str]]]] = None, **kwargs) -&gt; DataFrame\n</code></pre> <p>Loads data from a SAS file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the SAS file.</p> required <code>columns</code> <code>Optional[Union[None, List[str]]]</code> <p>The columns to load. If None, all columns are loaded.</p> <code>None</code> <code>filters</code> <code>Optional[Union[None, List[str], List[List[str]]]]</code> <p>The filters to apply. Each filter is a tuple of (column, operator, value). If filters is a list of tuples, all filters are applied in conjunction. If filters is a list of lists of tuples, each list is applied in disjunction.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The loaded data.</p> Source code in <code>bozio_wasmer_simulations/datasets/base.py</code> <pre><code>def read_sas(\n    self,\n    path: os.PathLike,\n    columns: Optional[Union[None, List[str]]] = None,\n    filters: Optional[Union[None, List[str], List[List[str]]]] = None,\n    **kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Loads data from a SAS file.\n\n    Args:\n        path (os.PathLike):\n            The path to the SAS file.\n        columns (Optional[Union[None, List[str]]], optional):\n            The columns to load. If None, all columns are loaded.\n        filters (Optional[Union[None, List[str], List[List[str]]]], optional):\n            The filters to apply. Each filter is a tuple of (column, operator, value).\n            If filters is a list of tuples, all filters are applied in conjunction.\n            If filters is a list of lists of tuples, each list is applied in disjunction.\n        **kwargs\n            Additional arguments to pass to the pyreadstat.read_sas7bdat function.\n\n    Returns:\n        (pd.DataFrame): The loaded data.\n    \"\"\"\n    # Chargement des donn\u00e9es\n    data, _ = pyreadstat.read_sas7bdat(path, usecols=columns, **kwargs)\n    # Filtrage des donn\u00e9es\n    if filters is not None:\n        data = data.loc[self._build_mask_from_filters(data=data, filters=filters)]\n    return data\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/","title":"PPVReintegrationSimulator","text":""},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator","title":"PPVReintegrationSimulator","text":"<p>A class for simulating the reintegration of the PPV in the base for exemptions.</p> <p>This class inherits from TheoreticalSimulator and provides methods for initializing a case with the PPV exempted or reintegrated, simulating variables of interest, simulating a reform, simulating multiple reforms, calculating the implicit tax rate, and building the dataset.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger for logging messages.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>class PPVReintegrationSimulator(TheoreticalSimulator):\n    \"\"\"\n    A class for simulating the reintegration of the PPV in the base for exemptions.\n\n    This class inherits from TheoreticalSimulator and provides methods for initializing a case with the PPV exempted or reintegrated,\n    simulating variables of interest, simulating a reform, simulating multiple reforms, calculating the implicit tax rate,\n    and building the dataset.\n\n    Attributes:\n        logger (logging.Logger):\n            A logger for logging messages.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        log_filename: os.PathLike = os.path.join(\n            FILE_PATH.parents[3], \"logs/ppv_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the ReformSimulation object.\n\n        Args:\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/ppv_simulation.log').\n\n        \"\"\"\n        # Initialisation du simulateur\n        super().__init__(log_filename=log_filename)\n\n    # Fonction auxiliaire d'extraction des noms de sc\u00e9narios\n    def scenarios_names(self, scenarios: Union[str, List[str], dict]) -&gt; List[str]:\n        \"\"\"\n        Extracts the names of the scenarios.\n\n        Args:\n            scenarios (Union[str, List[str], dict]):\n                The scenarios to extract the names from.\n\n        Returns:\n            (List[str]): The names of the scenarios.\n\n        Raises:\n            ValueError: If the type of scenarios is not 'dict', 'list', or 'str'.\n        \"\"\"\n        # Extraction des noms des scenarios\n        if isinstance(scenarios, str):\n            scenarios_names = [scenarios]\n        elif isinstance(scenarios, dict):\n            scenarios_names = [name.lower() for name in scenarios.keys()]\n        elif isinstance(scenarios, list):\n            scenarios_names = [name.lower() for name in scenarios]\n        else:\n            raise ValueError(\n                f\"Invalid type for scenarios : {type(scenarios)}. Should be in 'dict', 'list' or 'str'\"\n            )\n\n        return scenarios_names\n\n    # M\u00e9thode auxiliaire de construction du cas de base dans le cadre exon\u00e9r\u00e9\n    def init_case_ppv_exoneree(\n        self,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        ppv: float,\n    ) -&gt; None:\n        \"\"\"\n        Initializes a case with the PPV exempted.\n\n        Args:\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            ppv (float):\n                The amount of the PPV.\n\n        Returns:\n            None\n        \"\"\"\n        # Initialisation du cas de base\n        self.init_base_case(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Modification des param\u00e8tres de PPV\n        self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_exoneree\"][\n            2022\n        ] = ppv\n        self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_non_exoneree\"][\n            2022\n        ] = 0\n\n    # M\u00e9thode auxiliaire de construction du cas de base dans le cadre r\u00e9int\u00e9gr\u00e9\n    # /!\\\n    # 'axes' = [[\n    #         {'count' : simulation_count, 'name' : 'salaire_de_base', 'min' : value_smic, 'max' : simulation_max, 'period' : 2022},\n    #         {'count' : simulation_count, 'name' : 'assiette_allegement', 'min' : value_smic+montant_ppv, 'max' : simulation_max+montant_ppv, 'period' : 2022}\n    #     ]]\n    # N'est peut-\u00eatre pas \u00e9quivalent pour l'ann\u00e9e 2022 \u00e0 mettre 'prime_partage_valeur_non_exoneree' = ppv car elle n'est int\u00e9gr\u00e9e aux primes non exon\u00e9r\u00e9es qu'\u00e0 compter du 1er juillet\n    def init_case_ppv_reintegree(\n        self,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        ppv: float,\n    ) -&gt; None:\n        \"\"\"\n        Initializes a case with the PPV reintegrated.\n\n        Args:\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            ppv (float):\n                The amount of the PPV.\n        \"\"\"\n        # Initialisation du cas de base\n        self.init_base_case(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Modification des param\u00e8tres de PPV\n        self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_exoneree\"][\n            2022\n        ] = 0\n        self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_non_exoneree\"][\n            2022\n        ] = ppv\n\n    # Fonction auxiliaire de preprocessing du salaire de base\n    def _preprocess_salaire_de_base(\n        self, data: pd.DataFrame, year: int\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Preprocesses the gross salary.\n\n        Expresses the gross salary as a proportion of the SMIC.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            year (int):\n                The year for which the data is being processed.\n\n        Returns:\n            (pd.DataFrame): The preprocessed data.\n        \"\"\"\n        # Expression du salaire en proportion du SMIC\n        data[\"salaire_de_base_prop_smic\"] = data[\"salaire_de_base\"] / self.value_smic(\n            year=year\n        )\n\n        return data\n\n    # Fonction auxiliaire de preprocessing du salaire super brut\n    def _preprocess_salaire_super_brut(\n        self,\n        data: pd.DataFrame,\n        scenarios: Union[str, List[str], dict],\n        simulation_case: str,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Preprocesses the gross salary.\n\n        Calculates the gross salary for each scenario and drops the unnecessary columns.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            scenarios (Union[str, List[str], dict]):\n                The scenarios to simulate.\n            simulation_case (str):\n                The simulation case ('exoneree' or 'reintegree').\n\n        Returns:\n            (pd.DataFrame): The preprocessed data.\n        \"\"\"\n        # Parcours des sc\u00e9narios\n        for scenario in self.scenarios_names(scenarios=scenarios):\n            # Cr\u00e9ation du salaire super_brut\n            data[f\"{simulation_case}_salaire_super_brut_{scenario}\"] = (\n                data[f\"{simulation_case}_salaire_super_brut\"]\n                + data[f\"{simulation_case}_allegement_general\"]\n                - data[f\"{simulation_case}_new_allegement_{scenario}\"]\n            )\n            # Suppression du nouvel all\u00e8gement\n            data.drop(\n                f\"{simulation_case}_new_allegement_{scenario}\", axis=1, inplace=True\n            )\n        # Suppression de l'all\u00e8gement g\u00e9n\u00e9ral\n        data.drop(f\"{simulation_case}_allegement_general\", axis=1, inplace=True)\n\n        return data\n\n    # Fonction auxiliaire de simulation des variables d'int\u00e9r\u00eat\n    def core_simulation(\n        self,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        simulation_case: str,\n        ppv: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates the variables of interest.\n\n        Initializes the simulation case, initializes the tax-benefit system,\n        simulates the variables, postprocesses the simulated variables,\n        and preprocesses the gross salary.\n\n        Args:\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            simulation_case (str):\n                The simulation case ('exoneree' or 'reintegree').\n            ppv (float):\n                The amount of the PPV.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n\n        Raises:\n            ValueError: If the simulation case is not 'exoneree' or 'reintegree'.\n        \"\"\"\n        # Initialisation du cas de simulation\n        if simulation_case == \"exoneree\":\n            self.init_case_ppv_exoneree(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                ppv=ppv,\n            )\n        elif simulation_case == \"reintegree\":\n            self.init_case_ppv_reintegree(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                ppv=ppv,\n            )\n        else:\n            raise ValueError(\n                f\"Invalid value for 'simulation_case' : {simulation_case}. Should be in ['exoneree', 'reintegree']\"\n            )\n\n        # Initialisation du syst\u00e8me socio-fiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n        # Extraction des variables \u00e0 simuler\n        list_var_simul = params[\"VARIABLES_PPV\"]\n        # Simulation\n        data_simul = self.base_case_simulation(\n            tax_benefit_system=tax_benefit_system,\n            year=year,\n            list_var_simul=list_var_simul,\n        )\n        # Post-processing des variables simul\u00e9es\n        # Ajout de la prime partage de la valeur exon\u00e9r\u00e9e\n        data_simul[\"prime_partage_valeur_exoneree\"] = self.base_case[\"individus\"][\n            \"individu_1\"\n        ][\"prime_partage_valeur_exoneree\"][year]\n        # Postprocessing\n        data_simul = preprocess_simulated_variables(data=data_simul)\n\n        # Retraitement du salaire de base\n        data_simul = self._preprocess_salaire_de_base(data=data_simul, year=year)\n        # Logging\n        self.logger.info(\"Successfully preprocessed simulated variables\")\n\n        return data_simul[\n            [\n                \"salaire_de_base\",\n                \"salaire_de_base_prop_smic\",\n                \"salaire_super_brut\",\n                \"allegement_general\",\n                \"salaire_net\",\n            ]\n        ].add_prefix(prefix=f\"{simulation_case}_\")\n\n    # Fonction auxiliaire de simulation th\u00e9orique des r\u00e9formes\n    def simulate_reform(\n        self,\n        name: str,\n        reform_params: dict,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        simulation_case: str,\n        ppv: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates a reform.\n\n        Initializes the simulation case, initializes the tax-benefit system,\n        applies the reform, simulates the variables, and preprocesses the gross salary.\n\n        Args:\n            name (str):\n                The name of the reform.\n            reform_params (dict):\n                The parameters of the reform.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            simulation_case (str):\n                The simulation case ('exoneree' or 'reintegree').\n            ppv (float):\n                The amount of the PPV.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n\n        Raises:\n            ValueError: If the simulation case is not 'exoneree' or 'reintegree'.\n        \"\"\"\n        # Initialisation du cas de simulation\n        if simulation_case == \"exoneree\":\n            self.init_case_ppv_exoneree(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                ppv=ppv,\n            )\n        elif simulation_case == \"reintegree\":\n            self.init_case_ppv_reintegree(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                ppv=ppv,\n            )\n        else:\n            raise ValueError(\n                f\"Invalid value for 'simulation_case' : {simulation_case}. Should be in ['exoneree', 'reintegree']\"\n            )\n\n        # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n\n        # Application de la r\u00e9forme\n        reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n            tax_benefit_system=tax_benefit_system, dict_params=reform_params\n        )\n\n        # Logging\n        self.logger.info(\"Successfully updated the tax-benefit system\")\n\n        # Extraction du type de la r\u00e9forme\n        reform_type = reform_params[\"TYPE\"]\n\n        # It\u00e9ration de la simulation\n        data_simul = self.base_case_simulation(\n            tax_benefit_system=reformed_tax_benefit_system,\n            year=year,\n            list_var_simul=[\"salaire_de_base\", f\"new_allegement_{reform_type}\"],\n        )\n\n        # Renomination de la variable simul\u00e9e pour correspondre au nom du sc\u00e9nario\n        data_simul.rename(\n            {f\"new_allegement_{reform_type}\": f\"new_allegement_{name.lower()}\"},\n            axis=1,\n            inplace=True,\n        )\n\n        # Retraitement du salaire de base\n        data_simul = self._preprocess_salaire_de_base(data=data_simul, year=year)\n\n        return data_simul.add_prefix(prefix=f\"{simulation_case}_\")\n\n    # Fonction auxiliaire de simulation de plusieurs r\u00e9formes th\u00e9oriques\n    def iterate_reform_simulations(\n        self,\n        scenarios: Union[str, List[str], dict],\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        simulation_case: str,\n        ppv: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates multiple reforms.\n\n        Iterates over the scenarios and simulates each reform.\n        Concatenates the simulated data for all reforms.\n\n        Args:\n            scenarios (Union[str, List[str], dict]):\n                The scenarios to simulate.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            simulation_case (str):\n                The simulation case ('exoneree' or 'reintegree').\n            ppv (float):\n                The amount of the PPV.\n\n        Returns:\n            (pd.DataFrame): The simulated data for all reforms.\n        \"\"\"\n        # Initialisation de la liste r\u00e9sultat\n        list_data_simul = []\n        # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n        for i, scenario in tqdm(enumerate(self.scenarios_names(scenarios=scenarios))):\n            # It\u00e9ration des r\u00e9formes\n            data_simul = self.simulate_reform(\n                name=scenario,\n                reform_params=scenarios[scenario.upper()],\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                simulation_case=simulation_case,\n                ppv=ppv,\n            )\n            # Ajout \u00e0 la liste r\u00e9sultat\n            if i &gt; 0:\n                list_data_simul.append(\n                    data_simul.drop(\n                        [\n                            f\"{simulation_case}_salaire_de_base\",\n                            f\"{simulation_case}_salaire_de_base_prop_smic\",\n                        ],\n                        axis=1,\n                    )\n                )\n            else:\n                list_data_simul.append(data_simul)\n        # Concat\u00e9nation\n        data_simul = pd.concat(list_data_simul, axis=1, join=\"outer\")\n\n        return data_simul\n\n    # Fonction auxiliaire de calcul du taux de cotisation implicite\n    def calculate_taux_cotisation_implicite(\n        self,\n        data: pd.DataFrame,\n        scenarios: Union[str, List[str], dict],\n        simulation_case: str,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Calculates the implicit tax rate.\n\n        Calculates the implicit tax rate for each scenario and drops the unnecessary columns.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            scenarios (Union[str, List[str], dict]):\n                The scenarios to simulate.\n            simulation_case (str):\n                The simulation case ('exoneree' or 'reintegree').\n\n        Returns:\n            (pd.DataFrame): The data with the implicit tax rate calculated.\n        \"\"\"\n        # Parcours des sc\u00e9narios\n        for scenario in self.scenarios_names(scenarios=scenarios):\n            # Calcul du taux de cotisations implicite\n            data[f\"{simulation_case}_taux_cotisation_implicite_{scenario}\"] = (\n                data[f\"{simulation_case}_salaire_super_brut_{scenario}\"]\n                - data[f\"{simulation_case}_salaire_net\"]\n            ) / data[f\"{simulation_case}_salaire_super_brut_{scenario}\"]\n            # Suppression du salaire super_brut\n            data.drop(\n                f\"{simulation_case}_salaire_super_brut_{scenario}\", axis=1, inplace=True\n            )\n\n        return data\n\n    # Fonction de construction du jeu de donn\u00e9es\n    def build(\n        self,\n        scenarios: dict,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n        simulation_case: str,\n        ppv: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Builds the dataset.\n\n        Simulates the core variables and the reform variables, preprocesses the gross salary,\n        calculates the implicit tax rate, and returns the dataset.\n\n        Args:\n            scenarios (dict):\n                The scenarios to simulate.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n            simulation_case (str):\n                The simulation case ('exoneree' or 'reintegree').\n            ppv (float):\n                The amount of the PPV.\n\n        Returns:\n            (pd.DataFrame): The dataset.\n        \"\"\"\n        # Construction du sc\u00e9nario de base et concat\u00e9nration des simulations des sc\u00e9narios de r\u00e9forme\n        data_simul = pd.concat(\n            [\n                self.core_simulation(\n                    year=year,\n                    simulation_step_smic=simulation_step_smic,\n                    simulation_max_smic=simulation_max_smic,\n                    simulation_case=simulation_case,\n                    ppv=ppv,\n                ),\n                self.iterate_reform_simulations(\n                    scenarios=scenarios,\n                    year=year,\n                    simulation_step_smic=simulation_step_smic,\n                    simulation_max_smic=simulation_max_smic,\n                    simulation_case=simulation_case,\n                    ppv=ppv,\n                ).drop(\n                    [\n                        f\"{simulation_case}_salaire_de_base\",\n                        f\"{simulation_case}_salaire_de_base_prop_smic\",\n                    ],\n                    axis=1,\n                ),\n            ],\n            axis=1,\n            join=\"outer\",\n        )\n        # Construction des salaires super_bruts associ\u00e9s \u00e0 chaque sc\u00e9nario\n        data_simul = self._preprocess_salaire_super_brut(\n            data=data_simul, scenarios=scenarios, simulation_case=simulation_case\n        )\n\n        # Calcul du taux de cotisations implicite\n        # Pour le cas de base\n        data_simul[f\"{simulation_case}_taux_cotisation_implicite\"] = (\n            data_simul[f\"{simulation_case}_salaire_super_brut\"]\n            - data_simul[f\"{simulation_case}_salaire_net\"]\n        ) / data_simul[f\"{simulation_case}_salaire_super_brut\"]\n        # Suppression du salaire super brut\n        data_simul.drop(f\"{simulation_case}_salaire_super_brut\", axis=1, inplace=True)\n        # Pour les r\u00e9formes\n        data_simul = self.calculate_taux_cotisation_implicite(\n            data=data_simul, scenarios=scenarios, simulation_case=simulation_case\n        )\n        # Suppression du salaire net\n        data_simul.drop(f\"{simulation_case}_salaire_net\", axis=1, inplace=True)\n\n        return data_simul\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.base_case_simulation","title":"base_case_simulation","text":"<pre><code>base_case_simulation(tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]) -&gt; DataFrame\n</code></pre> <p>Performs a simulation on the base case.</p> <p>Parameters:</p> Name Type Description Default <code>tax_benefit_system</code> <code>TaxBenefitSystem</code> <p>The tax-benefit system to use for the simulation.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>A list of variables to simulate.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing the results of the simulation.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def base_case_simulation(\n    self, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Performs a simulation on the base case.\n\n    Args:\n        tax_benefit_system (TaxBenefitSystem):\n            The tax-benefit system to use for the simulation.\n        year (int):\n            The year for which the simulation is performed.\n        list_var_simul (List[str]):\n            A list of variables to simulate.\n\n    Returns:\n        (pd.DataFrame): A dataframe containing the results of the simulation.\n    \"\"\"\n    # Initialisation des param\u00e8tres de la simulation\n    simulation_builder = SimulationBuilder()\n    simulation = simulation_builder.build_from_entities(\n        tax_benefit_system, self.base_case\n    )\n    # Initialisation du dictionnaire r\u00e9sultat\n    dict_simul = {}\n    # It\u00e9ration sur la liste des variables \u00e0 simuler\n    for variable in list_var_simul:\n        dict_simul[variable] = simulation.calculate_add(variable, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {variable} for period {year}\")\n    # Conversion en dataFrame\n    data_simul = pd.DataFrame(dict_simul)\n\n    return data_simul\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.build","title":"build","text":"<pre><code>build(scenarios: dict, year: int, simulation_step_smic: float, simulation_max_smic: float, simulation_case: str, ppv: float) -&gt; DataFrame\n</code></pre> <p>Builds the dataset.</p> <p>Simulates the core variables and the reform variables, preprocesses the gross salary, calculates the implicit tax rate, and returns the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios to simulate.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_case</code> <code>str</code> <p>The simulation case ('exoneree' or 'reintegree').</p> required <code>ppv</code> <code>float</code> <p>The amount of the PPV.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The dataset.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def build(\n    self,\n    scenarios: dict,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    simulation_case: str,\n    ppv: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Builds the dataset.\n\n    Simulates the core variables and the reform variables, preprocesses the gross salary,\n    calculates the implicit tax rate, and returns the dataset.\n\n    Args:\n        scenarios (dict):\n            The scenarios to simulate.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        simulation_case (str):\n            The simulation case ('exoneree' or 'reintegree').\n        ppv (float):\n            The amount of the PPV.\n\n    Returns:\n        (pd.DataFrame): The dataset.\n    \"\"\"\n    # Construction du sc\u00e9nario de base et concat\u00e9nration des simulations des sc\u00e9narios de r\u00e9forme\n    data_simul = pd.concat(\n        [\n            self.core_simulation(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                simulation_case=simulation_case,\n                ppv=ppv,\n            ),\n            self.iterate_reform_simulations(\n                scenarios=scenarios,\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n                simulation_case=simulation_case,\n                ppv=ppv,\n            ).drop(\n                [\n                    f\"{simulation_case}_salaire_de_base\",\n                    f\"{simulation_case}_salaire_de_base_prop_smic\",\n                ],\n                axis=1,\n            ),\n        ],\n        axis=1,\n        join=\"outer\",\n    )\n    # Construction des salaires super_bruts associ\u00e9s \u00e0 chaque sc\u00e9nario\n    data_simul = self._preprocess_salaire_super_brut(\n        data=data_simul, scenarios=scenarios, simulation_case=simulation_case\n    )\n\n    # Calcul du taux de cotisations implicite\n    # Pour le cas de base\n    data_simul[f\"{simulation_case}_taux_cotisation_implicite\"] = (\n        data_simul[f\"{simulation_case}_salaire_super_brut\"]\n        - data_simul[f\"{simulation_case}_salaire_net\"]\n    ) / data_simul[f\"{simulation_case}_salaire_super_brut\"]\n    # Suppression du salaire super brut\n    data_simul.drop(f\"{simulation_case}_salaire_super_brut\", axis=1, inplace=True)\n    # Pour les r\u00e9formes\n    data_simul = self.calculate_taux_cotisation_implicite(\n        data=data_simul, scenarios=scenarios, simulation_case=simulation_case\n    )\n    # Suppression du salaire net\n    data_simul.drop(f\"{simulation_case}_salaire_net\", axis=1, inplace=True)\n\n    return data_simul\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.calculate_taux_cotisation_implicite","title":"calculate_taux_cotisation_implicite","text":"<pre><code>calculate_taux_cotisation_implicite(data: DataFrame, scenarios: Union[str, List[str], dict], simulation_case: str) -&gt; DataFrame\n</code></pre> <p>Calculates the implicit tax rate.</p> <p>Calculates the implicit tax rate for each scenario and drops the unnecessary columns.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The input data.</p> required <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios to simulate.</p> required <code>simulation_case</code> <code>str</code> <p>The simulation case ('exoneree' or 'reintegree').</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The data with the implicit tax rate calculated.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def calculate_taux_cotisation_implicite(\n    self,\n    data: pd.DataFrame,\n    scenarios: Union[str, List[str], dict],\n    simulation_case: str,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the implicit tax rate.\n\n    Calculates the implicit tax rate for each scenario and drops the unnecessary columns.\n\n    Args:\n        data (pd.DataFrame):\n            The input data.\n        scenarios (Union[str, List[str], dict]):\n            The scenarios to simulate.\n        simulation_case (str):\n            The simulation case ('exoneree' or 'reintegree').\n\n    Returns:\n        (pd.DataFrame): The data with the implicit tax rate calculated.\n    \"\"\"\n    # Parcours des sc\u00e9narios\n    for scenario in self.scenarios_names(scenarios=scenarios):\n        # Calcul du taux de cotisations implicite\n        data[f\"{simulation_case}_taux_cotisation_implicite_{scenario}\"] = (\n            data[f\"{simulation_case}_salaire_super_brut_{scenario}\"]\n            - data[f\"{simulation_case}_salaire_net\"]\n        ) / data[f\"{simulation_case}_salaire_super_brut_{scenario}\"]\n        # Suppression du salaire super_brut\n        data.drop(\n            f\"{simulation_case}_salaire_super_brut_{scenario}\", axis=1, inplace=True\n        )\n\n    return data\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.core_simulation","title":"core_simulation","text":"<pre><code>core_simulation(year: int, simulation_step_smic: float, simulation_max_smic: float, simulation_case: str, ppv: float) -&gt; DataFrame\n</code></pre> <p>Simulates the variables of interest.</p> <p>Initializes the simulation case, initializes the tax-benefit system, simulates the variables, postprocesses the simulated variables, and preprocesses the gross salary.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_case</code> <code>str</code> <p>The simulation case ('exoneree' or 'reintegree').</p> required <code>ppv</code> <code>float</code> <p>The amount of the PPV.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the simulation case is not 'exoneree' or 'reintegree'.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def core_simulation(\n    self,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    simulation_case: str,\n    ppv: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the variables of interest.\n\n    Initializes the simulation case, initializes the tax-benefit system,\n    simulates the variables, postprocesses the simulated variables,\n    and preprocesses the gross salary.\n\n    Args:\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        simulation_case (str):\n            The simulation case ('exoneree' or 'reintegree').\n        ppv (float):\n            The amount of the PPV.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n\n    Raises:\n        ValueError: If the simulation case is not 'exoneree' or 'reintegree'.\n    \"\"\"\n    # Initialisation du cas de simulation\n    if simulation_case == \"exoneree\":\n        self.init_case_ppv_exoneree(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n            ppv=ppv,\n        )\n    elif simulation_case == \"reintegree\":\n        self.init_case_ppv_reintegree(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n            ppv=ppv,\n        )\n    else:\n        raise ValueError(\n            f\"Invalid value for 'simulation_case' : {simulation_case}. Should be in ['exoneree', 'reintegree']\"\n        )\n\n    # Initialisation du syst\u00e8me socio-fiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction des variables \u00e0 simuler\n    list_var_simul = params[\"VARIABLES_PPV\"]\n    # Simulation\n    data_simul = self.base_case_simulation(\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=list_var_simul,\n    )\n    # Post-processing des variables simul\u00e9es\n    # Ajout de la prime partage de la valeur exon\u00e9r\u00e9e\n    data_simul[\"prime_partage_valeur_exoneree\"] = self.base_case[\"individus\"][\n        \"individu_1\"\n    ][\"prime_partage_valeur_exoneree\"][year]\n    # Postprocessing\n    data_simul = preprocess_simulated_variables(data=data_simul)\n\n    # Retraitement du salaire de base\n    data_simul = self._preprocess_salaire_de_base(data=data_simul, year=year)\n    # Logging\n    self.logger.info(\"Successfully preprocessed simulated variables\")\n\n    return data_simul[\n        [\n            \"salaire_de_base\",\n            \"salaire_de_base_prop_smic\",\n            \"salaire_super_brut\",\n            \"allegement_general\",\n            \"salaire_net\",\n        ]\n    ].add_prefix(prefix=f\"{simulation_case}_\")\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.init_base_case","title":"init_base_case","text":"<pre><code>init_base_case(year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; None\n</code></pre> <p>Initializes a base case for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def init_base_case(\n    self, year: int, simulation_step_smic: float, simulation_max_smic: float\n) -&gt; None:\n    \"\"\"\n    Initializes a base case for simulation.\n\n    Args:\n        year (int):\n            The year for which the simulation is performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction de la valeur moyenne de SMIC sur l'ann\u00e9e\n    value_smic = self.value_smic(year=year)\n    # Calcul de la valeur maximale de la simulation et de la valeur du pas\n    simulation_max = simulation_max_smic * value_smic\n    simulation_step = simulation_step_smic * value_smic\n    # Calcul du nombre d'observations dans la simulation entre le min (1 SMIC) et le max avec le pas sp\u00e9cifi\u00e9\n    simulation_count = ceil((simulation_max - value_smic) / simulation_step) + 1\n    # D\u00e9finition des caract\u00e9ristiques de l'individu\n    self.base_case = {\n        \"individus\": {\n            \"individu_1\": {\n                \"effectif_entreprise\": {year: 200},\n                \"depcom_entreprise\": {year: \"93001\"},\n                \"contrat_de_travail_debut\": {year: \"2009-03-16\"},\n                \"heures_remunerees_volume\": {year: 1820},\n                \"prime_exceptionnelle_pouvoir_achat\": {year: 0},\n                \"quotite_de_travail\": {year: 12},\n                \"prime_partage_valeur_exoneree\": {year: 0},\n                \"prime_partage_valeur_non_exoneree\": {year: 0},\n                \"age\": {year: 40},\n                \"secteur_activite_employeur\": {\n                    year: \"non_agricole\"\n                },  # {year : TypesSecteurActivite.non_agricole},\n                \"exoneration_cotisations_employeur_tode_eligibilite\": {year: False},\n                \"choix_exoneration_cotisations_employeur_agricole\": {year: False},\n                \"travailleur_occasionnel_agricole\": {year: False},\n                \"zone_restructuration_defense\": {year: False},\n                \"zone_revitalisation_rurale\": {year: False},\n                \"categorie_salarie\": {\n                    year: \"prive_non_cadre\"\n                },  # {year : TypesCategorieSalarie.prive_non_cadre},\n                \"contrat_de_travail\": {\n                    year: \"temps_plein\"\n                },  # {year : TypesContratDeTravail.temps_plein},\n                \"contrat_de_travail_fin\": {year: \"2099-12-31\"},\n                \"contrat_de_travail_type\": {\n                    year: \"cdi\"\n                },  # {year : TypesContrat.cdi},\n                \"salarie_regime_alsace_moselle\": {year: False},\n                #'salaire_de_base'\n                \"remuneration_apprenti\": {year: 0},\n                \"apprentissage_contrat_debut\": {year: \"1970-01-01\"},\n                \"apprenti\": {year: False},\n                \"stage_duree_heures\": {year: 0},\n                \"stage_gratification\": {year: 0},\n                \"taux_versement_transport\": {year: 0.032},\n                \"taux_accident_travail\": {year: 0.0212},\n            }\n        },\n        \"menages\": {\n            \"menage_1\": {\n                \"personne_de_reference\": [\"individu_1\"],\n                \"depcom\": {year: \"93001\"},\n            },\n        },\n        \"familles\": {\"famille_1\": {\"parents\": [\"individu_1\"]}},\n        \"foyers_fiscaux\": {\"foyer_fiscal_1\": {\"declarants\": [\"individu_1\"]}},\n        \"axes\": [\n            [\n                {\n                    \"count\": simulation_count,\n                    \"name\": \"salaire_de_base\",\n                    \"min\": value_smic,\n                    \"max\": simulation_max,\n                    \"period\": year,\n                }\n            ]\n        ],\n    }\n\n    # Logging\n    self.logger.info(\"Successfully initialized a test case\")\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.init_case_ppv_exoneree","title":"init_case_ppv_exoneree","text":"<pre><code>init_case_ppv_exoneree(year: int, simulation_step_smic: float, simulation_max_smic: float, ppv: float) -&gt; None\n</code></pre> <p>Initializes a case with the PPV exempted.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>ppv</code> <code>float</code> <p>The amount of the PPV.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def init_case_ppv_exoneree(\n    self,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    ppv: float,\n) -&gt; None:\n    \"\"\"\n    Initializes a case with the PPV exempted.\n\n    Args:\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        ppv (float):\n            The amount of the PPV.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialisation du cas de base\n    self.init_base_case(\n        year=year,\n        simulation_step_smic=simulation_step_smic,\n        simulation_max_smic=simulation_max_smic,\n    )\n    # Modification des param\u00e8tres de PPV\n    self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_exoneree\"][\n        2022\n    ] = ppv\n    self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_non_exoneree\"][\n        2022\n    ] = 0\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.init_case_ppv_reintegree","title":"init_case_ppv_reintegree","text":"<pre><code>init_case_ppv_reintegree(year: int, simulation_step_smic: float, simulation_max_smic: float, ppv: float) -&gt; None\n</code></pre> <p>Initializes a case with the PPV reintegrated.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>ppv</code> <code>float</code> <p>The amount of the PPV.</p> required Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def init_case_ppv_reintegree(\n    self,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    ppv: float,\n) -&gt; None:\n    \"\"\"\n    Initializes a case with the PPV reintegrated.\n\n    Args:\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        ppv (float):\n            The amount of the PPV.\n    \"\"\"\n    # Initialisation du cas de base\n    self.init_base_case(\n        year=year,\n        simulation_step_smic=simulation_step_smic,\n        simulation_max_smic=simulation_max_smic,\n    )\n    # Modification des param\u00e8tres de PPV\n    self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_exoneree\"][\n        2022\n    ] = 0\n    self.base_case[\"individus\"][\"individu_1\"][\"prime_partage_valeur_non_exoneree\"][\n        2022\n    ] = ppv\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.iterate_reform_simulations","title":"iterate_reform_simulations","text":"<pre><code>iterate_reform_simulations(scenarios: Union[str, List[str], dict], year: int, simulation_step_smic: float, simulation_max_smic: float, simulation_case: str, ppv: float) -&gt; DataFrame\n</code></pre> <p>Simulates multiple reforms.</p> <p>Iterates over the scenarios and simulates each reform. Concatenates the simulated data for all reforms.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios to simulate.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_case</code> <code>str</code> <p>The simulation case ('exoneree' or 'reintegree').</p> required <code>ppv</code> <code>float</code> <p>The amount of the PPV.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data for all reforms.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def iterate_reform_simulations(\n    self,\n    scenarios: Union[str, List[str], dict],\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    simulation_case: str,\n    ppv: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates multiple reforms.\n\n    Iterates over the scenarios and simulates each reform.\n    Concatenates the simulated data for all reforms.\n\n    Args:\n        scenarios (Union[str, List[str], dict]):\n            The scenarios to simulate.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        simulation_case (str):\n            The simulation case ('exoneree' or 'reintegree').\n        ppv (float):\n            The amount of the PPV.\n\n    Returns:\n        (pd.DataFrame): The simulated data for all reforms.\n    \"\"\"\n    # Initialisation de la liste r\u00e9sultat\n    list_data_simul = []\n    # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n    for i, scenario in tqdm(enumerate(self.scenarios_names(scenarios=scenarios))):\n        # It\u00e9ration des r\u00e9formes\n        data_simul = self.simulate_reform(\n            name=scenario,\n            reform_params=scenarios[scenario.upper()],\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n            simulation_case=simulation_case,\n            ppv=ppv,\n        )\n        # Ajout \u00e0 la liste r\u00e9sultat\n        if i &gt; 0:\n            list_data_simul.append(\n                data_simul.drop(\n                    [\n                        f\"{simulation_case}_salaire_de_base\",\n                        f\"{simulation_case}_salaire_de_base_prop_smic\",\n                    ],\n                    axis=1,\n                )\n            )\n        else:\n            list_data_simul.append(data_simul)\n    # Concat\u00e9nation\n    data_simul = pd.concat(list_data_simul, axis=1, join=\"outer\")\n\n    return data_simul\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.plot","title":"plot","text":"<pre><code>plot(data: DataFrame, x: str, hue: Union[str, List[str]], x_label: Optional[Union[str, None]] = None, y_label: Optional[Union[str, None]] = None, hue_label: Optional[Union[str, None]] = None, labels: Optional[Dict[str, str]] = {}, export_key: Optional[Union[PathLike, None]] = None, show: Optional[bool] = True) -&gt; None\n</code></pre> <p>Plots the results of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to plot.</p> required <code>x</code> <code>str</code> <p>The variable to use for the x-axis.</p> required <code>hue</code> <code>Union[str, List[str]]</code> <p>The variable(s) to use for the hue.</p> required <code>x_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the x-axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the y-axis. Defaults to None.</p> <code>None</code> <code>hue_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the hue. Defaults to None.</p> <code>None</code> <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary of labels to apply to the data. Defaults to {}.</p> <code>{}</code> <code>export_key</code> <code>Optional[Union[PathLike, None]]</code> <p>The path to save the plot to. Defaults to None.</p> <code>None</code> <code>show</code> <code>Optional[bool]</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def plot(\n    self,\n    data: pd.DataFrame,\n    x: str,\n    hue: Union[str, List[str]],\n    x_label: Optional[Union[str, None]] = None,\n    y_label: Optional[Union[str, None]] = None,\n    hue_label: Optional[Union[str, None]] = None,\n    labels: Optional[Dict[str, str]] = {},\n    export_key: Optional[Union[os.PathLike, None]] = None,\n    show: Optional[bool] = True,\n) -&gt; None:\n    \"\"\"\n    Plots the results of the simulation.\n\n    Args:\n        data (pd.DataFrame):\n            The data to plot.\n        x (str):\n            The variable to use for the x-axis.\n        hue (Union[str, List[str]]):\n            The variable(s) to use for the hue.\n        x_label (Optional[Union[str, None]], optional):\n            The label for the x-axis. Defaults to None.\n        y_label (Optional[Union[str, None]], optional):\n            The label for the y-axis. Defaults to None.\n        hue_label (Optional[Union[str, None]], optional):\n            The label for the hue. Defaults to None.\n        labels (Optional[Dict[str, str]], optional):\n            A dictionary of labels to apply to the data. Defaults to {}.\n        export_key (Optional[Union[os.PathLike, None]], optional):\n            The path to save the plot to. Defaults to None.\n        show (Optional[bool], optional):\n            Whether to display the plot. Defaults to True.\n\n    Returns:\n        None\n    \"\"\"\n    # Conversion des arguments en liste\n    if isinstance(hue, str):\n        hue = [hue]\n\n    # Cr\u00e9ation des noms \u00e0 partir des labels\n    id_name = x_label if (x_label is not None) else x\n    var_name = hue_label if (hue_label is not None) else \"Variable\"\n    value_name = y_label if (y_label is not None) else \"Valeur\"\n\n    # R\u00e9organisation du jeu de donn\u00e9es\n    data_graph = pd.melt(\n        frame=data,\n        id_vars=x,\n        value_vars=hue,\n        var_name=var_name,\n        value_name=value_name,\n    ).rename({x: id_name}, axis=1)\n    # Application des labels\n    data_graph[var_name] = (\n        data_graph[var_name].map(labels).fillna(data_graph[var_name])\n    )\n\n    # Initialisation de la figure\n    fig, ax = plt.subplots()\n    # Construction du graphique\n    sns.lineplot(data=data_graph, x=id_name, y=value_name, hue=var_name)\n    # Formattage de l'axe des ordonn\u00e9es\n    if all([\"_prop_\" in var_hue for var_hue in hue]):\n        ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))\n    # Exportation\n    if export_key is not None:\n        plt.savefig(export_key, bbox_inches=\"tight\")\n\n    # Logging\n    self.logger.info(f\"Successfully build graph\")\n\n    if show:\n        plt.show()\n    else:\n        plt.close(\"all\")\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.scenarios_names","title":"scenarios_names","text":"<pre><code>scenarios_names(scenarios: Union[str, List[str], dict]) -&gt; List[str]\n</code></pre> <p>Extracts the names of the scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>Union[str, List[str], dict]</code> <p>The scenarios to extract the names from.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The names of the scenarios.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type of scenarios is not 'dict', 'list', or 'str'.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def scenarios_names(self, scenarios: Union[str, List[str], dict]) -&gt; List[str]:\n    \"\"\"\n    Extracts the names of the scenarios.\n\n    Args:\n        scenarios (Union[str, List[str], dict]):\n            The scenarios to extract the names from.\n\n    Returns:\n        (List[str]): The names of the scenarios.\n\n    Raises:\n        ValueError: If the type of scenarios is not 'dict', 'list', or 'str'.\n    \"\"\"\n    # Extraction des noms des scenarios\n    if isinstance(scenarios, str):\n        scenarios_names = [scenarios]\n    elif isinstance(scenarios, dict):\n        scenarios_names = [name.lower() for name in scenarios.keys()]\n    elif isinstance(scenarios, list):\n        scenarios_names = [name.lower() for name in scenarios]\n    else:\n        raise ValueError(\n            f\"Invalid type for scenarios : {type(scenarios)}. Should be in 'dict', 'list' or 'str'\"\n        )\n\n    return scenarios_names\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.simulate_reform","title":"simulate_reform","text":"<pre><code>simulate_reform(name: str, reform_params: dict, year: int, simulation_step_smic: float, simulation_max_smic: float, simulation_case: str, ppv: float) -&gt; DataFrame\n</code></pre> <p>Simulates a reform.</p> <p>Initializes the simulation case, initializes the tax-benefit system, applies the reform, simulates the variables, and preprocesses the gross salary.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the reform.</p> required <code>reform_params</code> <code>dict</code> <p>The parameters of the reform.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_case</code> <code>str</code> <p>The simulation case ('exoneree' or 'reintegree').</p> required <code>ppv</code> <code>float</code> <p>The amount of the PPV.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the simulation case is not 'exoneree' or 'reintegree'.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/ppv.py</code> <pre><code>def simulate_reform(\n    self,\n    name: str,\n    reform_params: dict,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n    simulation_case: str,\n    ppv: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates a reform.\n\n    Initializes the simulation case, initializes the tax-benefit system,\n    applies the reform, simulates the variables, and preprocesses the gross salary.\n\n    Args:\n        name (str):\n            The name of the reform.\n        reform_params (dict):\n            The parameters of the reform.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n        simulation_case (str):\n            The simulation case ('exoneree' or 'reintegree').\n        ppv (float):\n            The amount of the PPV.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n\n    Raises:\n        ValueError: If the simulation case is not 'exoneree' or 'reintegree'.\n    \"\"\"\n    # Initialisation du cas de simulation\n    if simulation_case == \"exoneree\":\n        self.init_case_ppv_exoneree(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n            ppv=ppv,\n        )\n    elif simulation_case == \"reintegree\":\n        self.init_case_ppv_reintegree(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n            ppv=ppv,\n        )\n    else:\n        raise ValueError(\n            f\"Invalid value for 'simulation_case' : {simulation_case}. Should be in ['exoneree', 'reintegree']\"\n        )\n\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Application de la r\u00e9forme\n    reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n        tax_benefit_system=tax_benefit_system, dict_params=reform_params\n    )\n\n    # Logging\n    self.logger.info(\"Successfully updated the tax-benefit system\")\n\n    # Extraction du type de la r\u00e9forme\n    reform_type = reform_params[\"TYPE\"]\n\n    # It\u00e9ration de la simulation\n    data_simul = self.base_case_simulation(\n        tax_benefit_system=reformed_tax_benefit_system,\n        year=year,\n        list_var_simul=[\"salaire_de_base\", f\"new_allegement_{reform_type}\"],\n    )\n\n    # Renomination de la variable simul\u00e9e pour correspondre au nom du sc\u00e9nario\n    data_simul.rename(\n        {f\"new_allegement_{reform_type}\": f\"new_allegement_{name.lower()}\"},\n        axis=1,\n        inplace=True,\n    )\n\n    # Retraitement du salaire de base\n    data_simul = self._preprocess_salaire_de_base(data=data_simul, year=year)\n\n    return data_simul.add_prefix(prefix=f\"{simulation_case}_\")\n</code></pre>"},{"location":"api/PPVReintegrationSimulator/#bozio_wasmer_simulations.simulation.theoretical.ppv.PPVReintegrationSimulator.value_smic","title":"value_smic","text":"<pre><code>value_smic(year: int) -&gt; float\n</code></pre> <p>Calculates the value of the SMIC for the given year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the SMIC value is calculated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the SMIC for the given year.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def value_smic(self, year: int) -&gt; float:\n    \"\"\"\n    Calculates the value of the SMIC for the given year.\n\n    Args:\n        year (int):\n            The year for which the SMIC value is calculated.\n\n    Returns:\n        (float): The value of the SMIC for the given year.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    value_smic = sum(\n        [\n            tax_benefit_system.get_parameters_at_instant(\n                instant=f\"{year}-{month}\"\n            ).marche_travail.salaire_minimum.smic.smic_b_mensuel\n            for month in [str(m).zfill(2) for m in range(1, 13)]\n        ]\n    )\n    # Logging\n    self.logger.info(f\"The SMIC value computed for {year} is {value_smic} \u20ac\")\n\n    return value_smic\n</code></pre>"},{"location":"api/ReformSimulation/","title":"ReformSimulation","text":""},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation","title":"ReformSimulation","text":"<p>A class used to build and simulate reform data.</p> <p>This class inherits from EmpiricalSimulator and provides methods to build and simulate reform data. It includes methods to build simulation data, simulate reforms, and iterate over multiple reform simulations.</p> <p>Attributes:</p> Name Type Description <code>log_filename</code> <code>PathLike</code> <p>The path to the log file for the simulation. Default is a path in the logs directory.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>class ReformSimulation(EmpiricalSimulator):\n    \"\"\"\n    A class used to build and simulate reform data.\n\n    This class inherits from EmpiricalSimulator and provides methods to build and simulate reform data.\n    It includes methods to build simulation data, simulate reforms, and iterate over multiple reform simulations.\n\n    Attributes:\n        log_filename (os.PathLike, optional):\n            The path to the log file for the simulation. Default is a path in the logs directory.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[3], \"logs/reform_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the ReformSimulation object.\n\n        Args:\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/reform_simulation.log').\n\n        Returns:\n            None\n        \"\"\"\n        # Initialisation du simulateur\n        super().__init__(log_filename=log_filename)\n\n    # Fonction auxilaire de construction des donn\u00e9es contenant les r\u00e9sultats d'une simulation \u00e0 partir de laquelle d\u00e9river une r\u00e9forme\n    def build_data_simulation(\n        self,\n        data: Optional[Union[pd.DataFrame, None]] = None,\n        path: Optional[Union[os.PathLike, None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Builds the simulation data.\n\n        If data is provided, it uses _build_data_simulation_from_dataframe to build the simulation data.\n        If not, it reads the data from the provided path.\n\n        Args:\n            data (pd.DataFrame, optional):\n                The data to use for building the simulation data. If None, the data is read from the path.\n            path (os.PathLike, optional):\n                The path to the data file. Used if data is None.\n\n        Returns:\n            None\n        \"\"\"\n        if data is not None:\n            self._build_data_simulation_from_dataframe(data=data)\n        else:\n            self.data_simulation = pd.read_csv(path)\n\n    # Fonction auxiliaire de construction des donn\u00e9es de simulation \u00e0 partir d'un DataFrame\n    def _build_data_simulation_from_dataframe(self, data: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Builds the simulation data from a DataFrame.\n\n        Checks if the DataFrame contains all the required variables. If it does, it sets the data as the simulation data.\n        If it doesn't, it logs an error and raises a ValueError.\n\n        Args:\n            data (pd.DataFrame):\n                The DataFrame to use for building the simulation data.\n\n        Returns:\n            None\n        \"\"\"\n        # V\u00e9rification que l'ensemble des variables attendues sont dans le jeu de donn\u00e9es\n        # Variables manquantes\n        missing_variables = np.setdiff1d(\n            params[\"VARIABLES\"], data.columns.tolist()\n        ).tolist()\n        if missing_variables == []:\n            self.data_simulation = data\n            # Logging\n            self.logger.info(\"Successfully build data_simulation\")\n        else:\n            # Logging\n            self.logger.error(\n                f\"Given DataFrame should contain {missing_variables} as columns\"\n            )\n            # Erreur\n            raise ValueError(\n                f\"Given DataFrame should contain {missing_variables} as columns\"\n            )\n\n    # Fonction auxiliaire d'it\u00e9ration d'une simulation de r\u00e9forme\n    def simulate_reform(\n        self,\n        name: str,\n        reform_params: dict,\n        year: int,\n        taux_bascule_vm: Optional[Union[float, None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Simulates a reform.\n\n        Applies the reform to the simulation data and calculates new variables. The new variables are added to the simulation data.\n\n        Args:\n            name (str):\n                The name of the reform.\n            reform_params (dict):\n                The parameters of the reform.\n            year (int):\n                The year for the simulation.\n            taux_bascule_vm (float, optional):\n                The rate of the \"versement mobilit\u00e9\" (VM) switch. If provided, new variables are calculated for the VM switch.\n\n        Returns:\n            None\n        \"\"\"\n        # Simulation du SMIC proratis\u00e9\n        if \"smic_proratise\" not in self.data_simulation.columns:\n            self.data_simulation = self.simulate_smic_proratise(\n                data=self.data_simulation, year=year, list_var_exclude=[], inplace=True\n            )\n\n        # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n\n        # Application de la r\u00e9forme\n        reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n            tax_benefit_system=tax_benefit_system, dict_params=reform_params\n        )\n\n        # Extraction du type de la r\u00e9forme\n        reform_type = reform_params[\"TYPE\"]\n        # It\u00e9ration de la simulation\n        self.data_simulation = self.iterate_simulation(\n            data=self.data_simulation,\n            tax_benefit_system=reformed_tax_benefit_system,\n            year=year,\n            list_var_simul=[f\"new_allegement_{reform_type}\"],\n            list_var_exclude=params[\"REFORM\"][\"VAR_EXCLUDE\"],\n            inplace=True,\n        )\n\n        # Renomination de la variable simul\u00e9e pour correspondre au nom du sc\u00e9nario\n        self.data_simulation.rename(\n            {f\"new_allegement_{reform_type}\": f\"new_allegement_{name.lower()}\"},\n            axis=1,\n            inplace=True,\n        )\n        # Somme des exon\u00e9rations et all\u00e8gements\n        self.data_simulation[f\"exonerations_et_allegements_{name.lower()}\"] = (\n            self.data_simulation[\n                [\"exonerations\", f\"new_allegement_{name.lower()}\"]\n            ].sum(axis=1)\n        )\n        # Calcul du salaire brut avec la r\u00e9forme\n        self.data_simulation[f\"salaire_super_brut_{name.lower()}\"] = (\n            self.data_simulation[\"salaire_super_brut_hors_allegements\"]\n            - self.data_simulation[f\"exonerations_et_allegements_{name.lower()}\"]\n            + self.data_simulation[\"prime_partage_valeur_exoneree\"]\n        )\n        # Construction des variables de variation du co\u00fbt du travail\n        self.data_simulation = build_data_evol_ct(\n            data_source=self.data_simulation,\n            col_new_ct=f\"salaire_super_brut_{name.lower()}\",\n            col_ct=\"salaire_super_brut\",\n            to_concat=True,\n        )\n        # Logging\n        self.logger.info(\n            f\"Successfully built variables related to labor costs variations inducted by the reform\"\n        )\n\n        # Construction d'un nouveau co\u00fbt du travail associ\u00e9 \u00e0 la bascule d'une fraction du versement transport\n        if taux_bascule_vm is not None:\n            self.data_simulation[f\"salaire_super_brut_vm_{name.lower()}\"] = (\n                self.data_simulation[\"salaire_super_brut_hors_allegements\"]\n                + self.data_simulation[\"versement_transport\"] * (1 - taux_bascule_vm)\n                - self.data_simulation[f\"exonerations_et_allegements_{name.lower()}\"]\n                + self.data_simulation[\"prime_partage_valeur_exoneree\"]\n            )\n            # Construction des variables de variation du co\u00fbt du travail\n            self.data_simulation = build_data_evol_ct(\n                data_source=self.data_simulation,\n                col_new_ct=f\"salaire_super_brut_vm_{name.lower()}\",\n                col_ct=\"salaire_super_brut\",\n                to_concat=True,\n            )\n            # Logging\n            self.logger.info(\n                f\"Successfully built variables related to labor costs variations inducted by the reform and the vm\"\n            )\n\n    # Fonction auxiliaire de d'it\u00e9ration de l'ensemble des simulations de r\u00e9formes\n    def iterate_reform_simulations(\n        self,\n        scenarios: dict,\n        year: int,\n        taux_bascule_vm: Optional[Union[float, None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Iterates over multiple reform simulations.\n\n        Simulates each reform in the provided scenarios. The results are added to the simulation data.\n\n        Args:\n            scenarios (dict):\n                The scenarios to simulate. Each scenario is a dictionary of reform parameters.\n            year (int):\n                The year for the simulation.\n            taux_bascule_vm (float, optional):\n                The rate of the value-added tax (VM) switch. If provided, new variables are calculated for the VM switch.\n\n        Returns:\n            None\n        \"\"\"\n        # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n        for scenario in tqdm(scenarios.keys()):\n            # It\u00e9ration des r\u00e9formes\n            self.simulate_reform(\n                name=scenario,\n                reform_params=scenarios[scenario],\n                year=year,\n                taux_bascule_vm=taux_bascule_vm,\n            )\n\n    # Fonction de construction du jeu de donn\u00e9es\n    def build(\n        self,\n        scenarios: dict,\n        year: int,\n        taux_bascule_vm: Optional[Union[float, None]] = None,\n        data: Optional[Union[pd.DataFrame, None]] = None,\n        path: Optional[Union[os.PathLike, None]] = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Builds the reform simulation data.\n\n        Calls build_data_simulation and iterate_reform_simulations to build the simulation data.\n\n        Args:\n            scenarios (dict):\n                The scenarios to simulate. Each scenario is a dictionary of reform parameters.\n            year (int):\n                The year for the simulation.\n            taux_bascule_vm (float, optional):\n                The rate of the value-added tax (VM) switch. If provided, new variables are calculated for the VM switch.\n            data (pd.DataFrame, optional):\n                The data to use for building the simulation data. If None, the data is read from the path.\n            path (os.PathLike, optional):\n                The path to the data file. Used if data is None.\n\n        Returns:\n            (pd.DataFrame): The simulation data.\n        \"\"\"\n        # Ajout du jeu de donn\u00e9es de simulations\n        self.build_data_simulation(data=data, path=path)\n        # It\u00e9ration des simulations de r\u00e9formes\n        self.iterate_reform_simulations(\n            scenarios=scenarios, year=year, taux_bascule_vm=taux_bascule_vm\n        )\n\n        return self.data_simulation\n</code></pre>"},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation.build","title":"build","text":"<pre><code>build(scenarios: dict, year: int, taux_bascule_vm: Optional[Union[float, None]] = None, data: Optional[Union[DataFrame, None]] = None, path: Optional[Union[PathLike, None]] = None) -&gt; DataFrame\n</code></pre> <p>Builds the reform simulation data.</p> <p>Calls build_data_simulation and iterate_reform_simulations to build the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios to simulate. Each scenario is a dictionary of reform parameters.</p> required <code>year</code> <code>int</code> <p>The year for the simulation.</p> required <code>taux_bascule_vm</code> <code>float</code> <p>The rate of the value-added tax (VM) switch. If provided, new variables are calculated for the VM switch.</p> <code>None</code> <code>data</code> <code>DataFrame</code> <p>The data to use for building the simulation data. If None, the data is read from the path.</p> <code>None</code> <code>path</code> <code>PathLike</code> <p>The path to the data file. Used if data is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulation data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def build(\n    self,\n    scenarios: dict,\n    year: int,\n    taux_bascule_vm: Optional[Union[float, None]] = None,\n    data: Optional[Union[pd.DataFrame, None]] = None,\n    path: Optional[Union[os.PathLike, None]] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Builds the reform simulation data.\n\n    Calls build_data_simulation and iterate_reform_simulations to build the simulation data.\n\n    Args:\n        scenarios (dict):\n            The scenarios to simulate. Each scenario is a dictionary of reform parameters.\n        year (int):\n            The year for the simulation.\n        taux_bascule_vm (float, optional):\n            The rate of the value-added tax (VM) switch. If provided, new variables are calculated for the VM switch.\n        data (pd.DataFrame, optional):\n            The data to use for building the simulation data. If None, the data is read from the path.\n        path (os.PathLike, optional):\n            The path to the data file. Used if data is None.\n\n    Returns:\n        (pd.DataFrame): The simulation data.\n    \"\"\"\n    # Ajout du jeu de donn\u00e9es de simulations\n    self.build_data_simulation(data=data, path=path)\n    # It\u00e9ration des simulations de r\u00e9formes\n    self.iterate_reform_simulations(\n        scenarios=scenarios, year=year, taux_bascule_vm=taux_bascule_vm\n    )\n\n    return self.data_simulation\n</code></pre>"},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation.build_data_simulation","title":"build_data_simulation","text":"<pre><code>build_data_simulation(data: Optional[Union[DataFrame, None]] = None, path: Optional[Union[PathLike, None]] = None) -&gt; None\n</code></pre> <p>Builds the simulation data.</p> <p>If data is provided, it uses _build_data_simulation_from_dataframe to build the simulation data. If not, it reads the data from the provided path.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to use for building the simulation data. If None, the data is read from the path.</p> <code>None</code> <code>path</code> <code>PathLike</code> <p>The path to the data file. Used if data is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def build_data_simulation(\n    self,\n    data: Optional[Union[pd.DataFrame, None]] = None,\n    path: Optional[Union[os.PathLike, None]] = None,\n) -&gt; None:\n    \"\"\"\n    Builds the simulation data.\n\n    If data is provided, it uses _build_data_simulation_from_dataframe to build the simulation data.\n    If not, it reads the data from the provided path.\n\n    Args:\n        data (pd.DataFrame, optional):\n            The data to use for building the simulation data. If None, the data is read from the path.\n        path (os.PathLike, optional):\n            The path to the data file. Used if data is None.\n\n    Returns:\n        None\n    \"\"\"\n    if data is not None:\n        self._build_data_simulation_from_dataframe(data=data)\n    else:\n        self.data_simulation = pd.read_csv(path)\n</code></pre>"},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation.iterate_reform_simulations","title":"iterate_reform_simulations","text":"<pre><code>iterate_reform_simulations(scenarios: dict, year: int, taux_bascule_vm: Optional[Union[float, None]] = None) -&gt; None\n</code></pre> <p>Iterates over multiple reform simulations.</p> <p>Simulates each reform in the provided scenarios. The results are added to the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios to simulate. Each scenario is a dictionary of reform parameters.</p> required <code>year</code> <code>int</code> <p>The year for the simulation.</p> required <code>taux_bascule_vm</code> <code>float</code> <p>The rate of the value-added tax (VM) switch. If provided, new variables are calculated for the VM switch.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def iterate_reform_simulations(\n    self,\n    scenarios: dict,\n    year: int,\n    taux_bascule_vm: Optional[Union[float, None]] = None,\n) -&gt; None:\n    \"\"\"\n    Iterates over multiple reform simulations.\n\n    Simulates each reform in the provided scenarios. The results are added to the simulation data.\n\n    Args:\n        scenarios (dict):\n            The scenarios to simulate. Each scenario is a dictionary of reform parameters.\n        year (int):\n            The year for the simulation.\n        taux_bascule_vm (float, optional):\n            The rate of the value-added tax (VM) switch. If provided, new variables are calculated for the VM switch.\n\n    Returns:\n        None\n    \"\"\"\n    # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n    for scenario in tqdm(scenarios.keys()):\n        # It\u00e9ration des r\u00e9formes\n        self.simulate_reform(\n            name=scenario,\n            reform_params=scenarios[scenario],\n            year=year,\n            taux_bascule_vm=taux_bascule_vm,\n        )\n</code></pre>"},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation.iterate_simulation","title":"iterate_simulation","text":"<pre><code>iterate_simulation(data: DataFrame, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str], list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Iterates a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>tax_benefit_system</code> <code>FranceTaxBenefitSystem</code> <p>The tax benefit system.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>The list of variables to simulate.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def iterate_simulation(\n    self,\n    data: pd.DataFrame,\n    tax_benefit_system: TaxBenefitSystem,\n    year: int,\n    list_var_simul: List[str],\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Iterates a simulation.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        tax_benefit_system (FranceTaxBenefitSystem): The tax benefit system.\n        year (int): The year of the simulation.\n        list_var_simul (List[str]): The list of variables to simulate.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Disjonction de cas suivant la n\u00e9cessit\u00e9 de r\u00e9aliser une copie ind\u00e9pendante du jeu de donn\u00e9es\n    if inplace:\n        data_res = data\n    else:\n        data_res = data.copy()\n\n    # Initialisation des param\u00e8tres de la simulation\n    simulation = SimulationBuilder().build_default_simulation(\n        tax_benefit_system, len(data_res)\n    )\n    # Ajout de l'ensemble des donn\u00e9es\n    # /!\\ On ajout 'smic_proratis\u00e9' aux variables \u00e0 exclure de l'imputation pour contourner l'\u00e9cueil de la mauvaise transition entre valeurs mensuelles et annuelles # + ['smic_proratise']\n    # Finalement retir\u00e9 car les r\u00e9mu restent divis\u00e9es par 12 et ne sont pas intersect\u00e9es avec la dur\u00e9e du contrat\n    # Il s'agit sans doute d'un point \u00e0 am\u00e9liorer dans le package\n    for caracteristic in np.setdiff1d(data_res.columns, list_var_exclude):\n        try:  # if not (caracteristic in ['id', 'siren']) :\n            simulation.set_input(\n                caracteristic, year, data_res[caracteristic].to_numpy()\n            )\n            # logging\n            self.logger.info(\n                f\"Successfully initialized {caracteristic} in the french tax benefit system\"\n            )\n        except Exception as e:\n            # Logging\n            self.logger.warning(\n                f\"Cannot initialize {caracteristic} in the french tax benefit system : {e}\"\n            )\n            pass\n    # Ajout des cotisations et des all\u00e8gements g\u00e9n\u00e9raux\n    for var_simul in tqdm(list_var_simul):\n        data_res[var_simul] = simulation.calculate_add(var_simul, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {var_simul} for period {year}\")\n\n    return data_res\n</code></pre>"},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation.simulate_reform","title":"simulate_reform","text":"<pre><code>simulate_reform(name: str, reform_params: dict, year: int, taux_bascule_vm: Optional[Union[float, None]] = None) -&gt; None\n</code></pre> <p>Simulates a reform.</p> <p>Applies the reform to the simulation data and calculates new variables. The new variables are added to the simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the reform.</p> required <code>reform_params</code> <code>dict</code> <p>The parameters of the reform.</p> required <code>year</code> <code>int</code> <p>The year for the simulation.</p> required <code>taux_bascule_vm</code> <code>float</code> <p>The rate of the \"versement mobilit\u00e9\" (VM) switch. If provided, new variables are calculated for the VM switch.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def simulate_reform(\n    self,\n    name: str,\n    reform_params: dict,\n    year: int,\n    taux_bascule_vm: Optional[Union[float, None]] = None,\n) -&gt; None:\n    \"\"\"\n    Simulates a reform.\n\n    Applies the reform to the simulation data and calculates new variables. The new variables are added to the simulation data.\n\n    Args:\n        name (str):\n            The name of the reform.\n        reform_params (dict):\n            The parameters of the reform.\n        year (int):\n            The year for the simulation.\n        taux_bascule_vm (float, optional):\n            The rate of the \"versement mobilit\u00e9\" (VM) switch. If provided, new variables are calculated for the VM switch.\n\n    Returns:\n        None\n    \"\"\"\n    # Simulation du SMIC proratis\u00e9\n    if \"smic_proratise\" not in self.data_simulation.columns:\n        self.data_simulation = self.simulate_smic_proratise(\n            data=self.data_simulation, year=year, list_var_exclude=[], inplace=True\n        )\n\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Application de la r\u00e9forme\n    reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n        tax_benefit_system=tax_benefit_system, dict_params=reform_params\n    )\n\n    # Extraction du type de la r\u00e9forme\n    reform_type = reform_params[\"TYPE\"]\n    # It\u00e9ration de la simulation\n    self.data_simulation = self.iterate_simulation(\n        data=self.data_simulation,\n        tax_benefit_system=reformed_tax_benefit_system,\n        year=year,\n        list_var_simul=[f\"new_allegement_{reform_type}\"],\n        list_var_exclude=params[\"REFORM\"][\"VAR_EXCLUDE\"],\n        inplace=True,\n    )\n\n    # Renomination de la variable simul\u00e9e pour correspondre au nom du sc\u00e9nario\n    self.data_simulation.rename(\n        {f\"new_allegement_{reform_type}\": f\"new_allegement_{name.lower()}\"},\n        axis=1,\n        inplace=True,\n    )\n    # Somme des exon\u00e9rations et all\u00e8gements\n    self.data_simulation[f\"exonerations_et_allegements_{name.lower()}\"] = (\n        self.data_simulation[\n            [\"exonerations\", f\"new_allegement_{name.lower()}\"]\n        ].sum(axis=1)\n    )\n    # Calcul du salaire brut avec la r\u00e9forme\n    self.data_simulation[f\"salaire_super_brut_{name.lower()}\"] = (\n        self.data_simulation[\"salaire_super_brut_hors_allegements\"]\n        - self.data_simulation[f\"exonerations_et_allegements_{name.lower()}\"]\n        + self.data_simulation[\"prime_partage_valeur_exoneree\"]\n    )\n    # Construction des variables de variation du co\u00fbt du travail\n    self.data_simulation = build_data_evol_ct(\n        data_source=self.data_simulation,\n        col_new_ct=f\"salaire_super_brut_{name.lower()}\",\n        col_ct=\"salaire_super_brut\",\n        to_concat=True,\n    )\n    # Logging\n    self.logger.info(\n        f\"Successfully built variables related to labor costs variations inducted by the reform\"\n    )\n\n    # Construction d'un nouveau co\u00fbt du travail associ\u00e9 \u00e0 la bascule d'une fraction du versement transport\n    if taux_bascule_vm is not None:\n        self.data_simulation[f\"salaire_super_brut_vm_{name.lower()}\"] = (\n            self.data_simulation[\"salaire_super_brut_hors_allegements\"]\n            + self.data_simulation[\"versement_transport\"] * (1 - taux_bascule_vm)\n            - self.data_simulation[f\"exonerations_et_allegements_{name.lower()}\"]\n            + self.data_simulation[\"prime_partage_valeur_exoneree\"]\n        )\n        # Construction des variables de variation du co\u00fbt du travail\n        self.data_simulation = build_data_evol_ct(\n            data_source=self.data_simulation,\n            col_new_ct=f\"salaire_super_brut_vm_{name.lower()}\",\n            col_ct=\"salaire_super_brut\",\n            to_concat=True,\n        )\n        # Logging\n        self.logger.info(\n            f\"Successfully built variables related to labor costs variations inducted by the reform and the vm\"\n        )\n</code></pre>"},{"location":"api/ReformSimulation/#bozio_wasmer_simulations.simulation.empirical.base.ReformSimulation.simulate_smic_proratise","title":"simulate_smic_proratise","text":"<pre><code>simulate_smic_proratise(data: DataFrame, year: int, list_var_exclude: Optional[List[str]] = [], inplace: Optional[bool] = True) -&gt; DataFrame\n</code></pre> <p>Simulates the prorated minimum wage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to simulate.</p> required <code>year</code> <code>int</code> <p>The year of the simulation.</p> required <code>list_var_exclude</code> <code>Optional[List[str]]</code> <p>The list of variables to exclude. Defaults to [].</p> <code>[]</code> <code>inplace</code> <code>Optional[bool]</code> <p>Whether to perform the simulation in place. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/base.py</code> <pre><code>def simulate_smic_proratise(\n    self,\n    data: pd.DataFrame,\n    year: int,\n    list_var_exclude: Optional[List[str]] = [],\n    inplace: Optional[bool] = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the prorated minimum wage.\n\n    Args:\n        data (pd.DataFrame): The data to simulate.\n        year (int): The year of the simulation.\n        list_var_exclude (Optional[List[str]], optional): The list of variables to exclude. Defaults to [].\n        inplace (Optional[bool], optional): Whether to perform the simulation in place. Defaults to True.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal fran\u00e7ais\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Simulation du SMIC proratis\u00e9 pour l'ann\u00e9e des donn\u00e9es\n    data = self.iterate_simulation(\n        data=data,\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=[\"smic_proratise\"],\n        list_var_exclude=list_var_exclude,\n        inplace=inplace,\n    )\n\n    return data\n</code></pre>"},{"location":"api/TheoreticalSimulation/","title":"TheoreticalSimulation","text":""},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation","title":"TheoreticalSimulation","text":"<p>A class for performing theoretical simulations of reforms.</p> <p>This class inherits from TheoreticalSimulator and provides methods for simulating variables of interest, simulating a reform, and simulating multiple reforms.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger for logging messages.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>class TheoreticalSimulation(TheoreticalSimulator):\n    \"\"\"\n    A class for performing theoretical simulations of reforms.\n\n    This class inherits from TheoreticalSimulator and provides methods for simulating variables of interest,\n    simulating a reform, and simulating multiple reforms.\n\n    Attributes:\n        logger (logging.Logger):\n            A logger for logging messages.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[3], \"logs/theoretical_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the ReformSimulation object.\n\n        Args:\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/theoretical_simulation.log').\n\n        \"\"\"\n        # Initialisation du simulateur\n        super().__init__(log_filename=log_filename)\n\n    # Fonction auxiliaire de retraitement de l'assiette d'all\u00e8gements\n    def _preprocess_assiette_allegement(\n        self, data: pd.DataFrame, year: int, list_var: List[str]\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Preprocesses the allegement base.\n\n        Expresses all quantities as a proportion of the allegement base.\n        Expresses the allegement base as a proportion of the SMIC.\n\n        Args:\n            data (pd.DataFrame):\n                The input data.\n            year (int):\n                The year for which the data is being processed.\n            list_var (List[str]):\n                A list of variables to process.\n\n        Returns:\n            (pd.DataFrame): The preprocessed data.\n        \"\"\"\n        # Expression de l'ensemble des grandeurs en proportion de l'assiette d'all\u00e8gements\n        list_var_prop = np.setdiff1d(list_var, [\"assiette_allegement\"]).tolist()\n        data[[f\"{var}_prop_assiette\" for var in list_var_prop]] = data[\n            list_var_prop\n        ].divide(other=data[\"assiette_allegement\"], axis=0)\n        # Expression de l'assiette d'all\u00e8gements en proportion du SMIC\n        data[\"assiette_allegement_prop_smic\"] = data[\n            \"assiette_allegement\"\n        ] / self.value_smic(year=year)\n\n        # Logging\n        self.logger.info(f\"Successfully preprocessed 'assiette_allegement'\")\n\n        return data\n\n    # Fonction auxiliaire de simulation des variables d'int\u00e9r\u00eat\n    def core_simulation(\n        self, year: int, simulation_step_smic: float, simulation_max_smic: float\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates the variables of interest.\n\n        Initializes the simulation case, initializes the tax-benefit system,\n        simulates the variables, postprocesses the simulated variables,\n        and preprocesses the allegement base.\n\n        Args:\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n        \"\"\"\n        # Initialisation du cas de simulation\n        self.init_base_case(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Initialisation du syst\u00e8me socio-fiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n        # Extraction des variables \u00e0 simuler\n        list_var_simul = params[\"VARIABLES\"]\n        # Simulation\n        data_simul = self.base_case_simulation(\n            tax_benefit_system=tax_benefit_system,\n            year=year,\n            list_var_simul=list_var_simul,\n        )\n        # Post-processing des variables simul\u00e9es\n        # Ajout de la prime partage de la valeur exon\u00e9r\u00e9e\n        data_simul[\"prime_partage_valeur_exoneree\"] = self.base_case[\"individus\"][\n            \"individu_1\"\n        ][\"prime_partage_valeur_exoneree\"][year]\n        # Postprocessing\n        data_simul = preprocess_simulated_variables(data=data_simul)\n        # Logging\n        self.logger.info(\"Successfully preprocessed simulated variables\")\n        # Retraitement de l'assiette d'all\u00e8gements\n        data_simul = self._preprocess_assiette_allegement(\n            data=data_simul, year=year, list_var=data_simul.columns.tolist()\n        )\n\n        return data_simul\n\n    # Fonction auxiliaire de simulation th\u00e9orique des r\u00e9formes\n    def simulate_reform(\n        self,\n        name: str,\n        reform_params: dict,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates a reform.\n\n        Initializes the simulation case, initializes the tax-benefit system,\n        applies the reform, simulates the variables, and preprocesses the allegement base.\n\n        Args:\n            name (str):\n                The name of the reform.\n            reform_params (dict):\n                The parameters of the reform.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n\n        Returns:\n            (pd.DataFrame): The simulated data.\n        \"\"\"\n        # Initialisation du cas de simulation\n        if not hasattr(self, \"base_case\"):\n            self.init_base_case(\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n            )\n\n        # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n        tax_benefit_system = FranceTaxBenefitSystem()\n\n        # Application de la r\u00e9forme\n        reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n            tax_benefit_system=tax_benefit_system, dict_params=reform_params\n        )\n\n        # Logging\n        self.logger.info(\"Successfully updated the tax-benefit system\")\n\n        # Extraction du type de la r\u00e9forme\n        reform_type = reform_params[\"TYPE\"]\n\n        # It\u00e9ration de la simulation\n        data_simul = self.base_case_simulation(\n            tax_benefit_system=reformed_tax_benefit_system,\n            year=year,\n            list_var_simul=[\"assiette_allegement\", f\"new_allegement_{reform_type}\"],\n        )\n\n        # Renomination de la variable simul\u00e9e pour correspondre au nom du sc\u00e9nario\n        data_simul.rename(\n            {f\"new_allegement_{reform_type}\": f\"new_allegement_{name.lower()}\"},\n            axis=1,\n            inplace=True,\n        )\n\n        # Retraitement de l'assiette d'all\u00e8gements\n        data_simul = self._preprocess_assiette_allegement(\n            data=data_simul,\n            year=year,\n            list_var=[\"assiette_allegement\", f\"new_allegement_{name.lower()}\"],\n        )\n\n        return data_simul\n\n    # Fonction auxiliaire de simulation de plusieurs r\u00e9formes th\u00e9oriques\n    def iterate_reform_simulations(\n        self,\n        scenarios: dict,\n        year: int,\n        simulation_step_smic: float,\n        simulation_max_smic: float,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Simulates multiple reforms.\n\n        Iterates over the scenarios and simulates each reform.\n        Concatenates the simulated data for all reforms.\n\n        Args:\n            scenarios (dict):\n                The scenarios to simulate.\n            year (int):\n                The year for which the simulation is being performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n\n        Returns:\n            (pd.DataFrame): The simulated data for all reforms.\n        \"\"\"\n        # Initialisation de la liste r\u00e9sultat\n        list_data_simul = []\n        # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n        for i, scenario in tqdm(enumerate(scenarios.keys())):\n            # It\u00e9ration des r\u00e9formes\n            data_simul = self.simulate_reform(\n                name=scenario,\n                reform_params=scenarios[scenario],\n                year=year,\n                simulation_step_smic=simulation_step_smic,\n                simulation_max_smic=simulation_max_smic,\n            )\n            # Ajout \u00e0 la liste r\u00e9sultat\n            if i &gt; 0:\n                list_data_simul.append(\n                    data_simul.drop(\n                        [\"assiette_allegement\", \"assiette_allegement_prop_smic\"], axis=1\n                    )\n                )\n            else:\n                list_data_simul.append(data_simul)\n        # Concat\u00e9nation\n        data_simul = pd.concat(list_data_simul, axis=1, join=\"outer\")\n\n        return data_simul\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.base_case_simulation","title":"base_case_simulation","text":"<pre><code>base_case_simulation(tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]) -&gt; DataFrame\n</code></pre> <p>Performs a simulation on the base case.</p> <p>Parameters:</p> Name Type Description Default <code>tax_benefit_system</code> <code>TaxBenefitSystem</code> <p>The tax-benefit system to use for the simulation.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>A list of variables to simulate.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing the results of the simulation.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def base_case_simulation(\n    self, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Performs a simulation on the base case.\n\n    Args:\n        tax_benefit_system (TaxBenefitSystem):\n            The tax-benefit system to use for the simulation.\n        year (int):\n            The year for which the simulation is performed.\n        list_var_simul (List[str]):\n            A list of variables to simulate.\n\n    Returns:\n        (pd.DataFrame): A dataframe containing the results of the simulation.\n    \"\"\"\n    # Initialisation des param\u00e8tres de la simulation\n    simulation_builder = SimulationBuilder()\n    simulation = simulation_builder.build_from_entities(\n        tax_benefit_system, self.base_case\n    )\n    # Initialisation du dictionnaire r\u00e9sultat\n    dict_simul = {}\n    # It\u00e9ration sur la liste des variables \u00e0 simuler\n    for variable in list_var_simul:\n        dict_simul[variable] = simulation.calculate_add(variable, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {variable} for period {year}\")\n    # Conversion en dataFrame\n    data_simul = pd.DataFrame(dict_simul)\n\n    return data_simul\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.core_simulation","title":"core_simulation","text":"<pre><code>core_simulation(year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; DataFrame\n</code></pre> <p>Simulates the variables of interest.</p> <p>Initializes the simulation case, initializes the tax-benefit system, simulates the variables, postprocesses the simulated variables, and preprocesses the allegement base.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def core_simulation(\n    self, year: int, simulation_step_smic: float, simulation_max_smic: float\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the variables of interest.\n\n    Initializes the simulation case, initializes the tax-benefit system,\n    simulates the variables, postprocesses the simulated variables,\n    and preprocesses the allegement base.\n\n    Args:\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation du cas de simulation\n    self.init_base_case(\n        year=year,\n        simulation_step_smic=simulation_step_smic,\n        simulation_max_smic=simulation_max_smic,\n    )\n    # Initialisation du syst\u00e8me socio-fiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction des variables \u00e0 simuler\n    list_var_simul = params[\"VARIABLES\"]\n    # Simulation\n    data_simul = self.base_case_simulation(\n        tax_benefit_system=tax_benefit_system,\n        year=year,\n        list_var_simul=list_var_simul,\n    )\n    # Post-processing des variables simul\u00e9es\n    # Ajout de la prime partage de la valeur exon\u00e9r\u00e9e\n    data_simul[\"prime_partage_valeur_exoneree\"] = self.base_case[\"individus\"][\n        \"individu_1\"\n    ][\"prime_partage_valeur_exoneree\"][year]\n    # Postprocessing\n    data_simul = preprocess_simulated_variables(data=data_simul)\n    # Logging\n    self.logger.info(\"Successfully preprocessed simulated variables\")\n    # Retraitement de l'assiette d'all\u00e8gements\n    data_simul = self._preprocess_assiette_allegement(\n        data=data_simul, year=year, list_var=data_simul.columns.tolist()\n    )\n\n    return data_simul\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.init_base_case","title":"init_base_case","text":"<pre><code>init_base_case(year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; None\n</code></pre> <p>Initializes a base case for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def init_base_case(\n    self, year: int, simulation_step_smic: float, simulation_max_smic: float\n) -&gt; None:\n    \"\"\"\n    Initializes a base case for simulation.\n\n    Args:\n        year (int):\n            The year for which the simulation is performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction de la valeur moyenne de SMIC sur l'ann\u00e9e\n    value_smic = self.value_smic(year=year)\n    # Calcul de la valeur maximale de la simulation et de la valeur du pas\n    simulation_max = simulation_max_smic * value_smic\n    simulation_step = simulation_step_smic * value_smic\n    # Calcul du nombre d'observations dans la simulation entre le min (1 SMIC) et le max avec le pas sp\u00e9cifi\u00e9\n    simulation_count = ceil((simulation_max - value_smic) / simulation_step) + 1\n    # D\u00e9finition des caract\u00e9ristiques de l'individu\n    self.base_case = {\n        \"individus\": {\n            \"individu_1\": {\n                \"effectif_entreprise\": {year: 200},\n                \"depcom_entreprise\": {year: \"93001\"},\n                \"contrat_de_travail_debut\": {year: \"2009-03-16\"},\n                \"heures_remunerees_volume\": {year: 1820},\n                \"prime_exceptionnelle_pouvoir_achat\": {year: 0},\n                \"quotite_de_travail\": {year: 12},\n                \"prime_partage_valeur_exoneree\": {year: 0},\n                \"prime_partage_valeur_non_exoneree\": {year: 0},\n                \"age\": {year: 40},\n                \"secteur_activite_employeur\": {\n                    year: \"non_agricole\"\n                },  # {year : TypesSecteurActivite.non_agricole},\n                \"exoneration_cotisations_employeur_tode_eligibilite\": {year: False},\n                \"choix_exoneration_cotisations_employeur_agricole\": {year: False},\n                \"travailleur_occasionnel_agricole\": {year: False},\n                \"zone_restructuration_defense\": {year: False},\n                \"zone_revitalisation_rurale\": {year: False},\n                \"categorie_salarie\": {\n                    year: \"prive_non_cadre\"\n                },  # {year : TypesCategorieSalarie.prive_non_cadre},\n                \"contrat_de_travail\": {\n                    year: \"temps_plein\"\n                },  # {year : TypesContratDeTravail.temps_plein},\n                \"contrat_de_travail_fin\": {year: \"2099-12-31\"},\n                \"contrat_de_travail_type\": {\n                    year: \"cdi\"\n                },  # {year : TypesContrat.cdi},\n                \"salarie_regime_alsace_moselle\": {year: False},\n                #'salaire_de_base'\n                \"remuneration_apprenti\": {year: 0},\n                \"apprentissage_contrat_debut\": {year: \"1970-01-01\"},\n                \"apprenti\": {year: False},\n                \"stage_duree_heures\": {year: 0},\n                \"stage_gratification\": {year: 0},\n                \"taux_versement_transport\": {year: 0.032},\n                \"taux_accident_travail\": {year: 0.0212},\n            }\n        },\n        \"menages\": {\n            \"menage_1\": {\n                \"personne_de_reference\": [\"individu_1\"],\n                \"depcom\": {year: \"93001\"},\n            },\n        },\n        \"familles\": {\"famille_1\": {\"parents\": [\"individu_1\"]}},\n        \"foyers_fiscaux\": {\"foyer_fiscal_1\": {\"declarants\": [\"individu_1\"]}},\n        \"axes\": [\n            [\n                {\n                    \"count\": simulation_count,\n                    \"name\": \"salaire_de_base\",\n                    \"min\": value_smic,\n                    \"max\": simulation_max,\n                    \"period\": year,\n                }\n            ]\n        ],\n    }\n\n    # Logging\n    self.logger.info(\"Successfully initialized a test case\")\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.iterate_reform_simulations","title":"iterate_reform_simulations","text":"<pre><code>iterate_reform_simulations(scenarios: dict, year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; DataFrame\n</code></pre> <p>Simulates multiple reforms.</p> <p>Iterates over the scenarios and simulates each reform. Concatenates the simulated data for all reforms.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>dict</code> <p>The scenarios to simulate.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data for all reforms.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def iterate_reform_simulations(\n    self,\n    scenarios: dict,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates multiple reforms.\n\n    Iterates over the scenarios and simulates each reform.\n    Concatenates the simulated data for all reforms.\n\n    Args:\n        scenarios (dict):\n            The scenarios to simulate.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n\n    Returns:\n        (pd.DataFrame): The simulated data for all reforms.\n    \"\"\"\n    # Initialisation de la liste r\u00e9sultat\n    list_data_simul = []\n    # It\u00e9ration sur les sc\u00e9narii r\u00e9f\u00e9renc\u00e9s dans le jeu de donn\u00e9es de param\u00e8tres\n    for i, scenario in tqdm(enumerate(scenarios.keys())):\n        # It\u00e9ration des r\u00e9formes\n        data_simul = self.simulate_reform(\n            name=scenario,\n            reform_params=scenarios[scenario],\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n        # Ajout \u00e0 la liste r\u00e9sultat\n        if i &gt; 0:\n            list_data_simul.append(\n                data_simul.drop(\n                    [\"assiette_allegement\", \"assiette_allegement_prop_smic\"], axis=1\n                )\n            )\n        else:\n            list_data_simul.append(data_simul)\n    # Concat\u00e9nation\n    data_simul = pd.concat(list_data_simul, axis=1, join=\"outer\")\n\n    return data_simul\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.plot","title":"plot","text":"<pre><code>plot(data: DataFrame, x: str, hue: Union[str, List[str]], x_label: Optional[Union[str, None]] = None, y_label: Optional[Union[str, None]] = None, hue_label: Optional[Union[str, None]] = None, labels: Optional[Dict[str, str]] = {}, export_key: Optional[Union[PathLike, None]] = None, show: Optional[bool] = True) -&gt; None\n</code></pre> <p>Plots the results of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to plot.</p> required <code>x</code> <code>str</code> <p>The variable to use for the x-axis.</p> required <code>hue</code> <code>Union[str, List[str]]</code> <p>The variable(s) to use for the hue.</p> required <code>x_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the x-axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the y-axis. Defaults to None.</p> <code>None</code> <code>hue_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the hue. Defaults to None.</p> <code>None</code> <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary of labels to apply to the data. Defaults to {}.</p> <code>{}</code> <code>export_key</code> <code>Optional[Union[PathLike, None]]</code> <p>The path to save the plot to. Defaults to None.</p> <code>None</code> <code>show</code> <code>Optional[bool]</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def plot(\n    self,\n    data: pd.DataFrame,\n    x: str,\n    hue: Union[str, List[str]],\n    x_label: Optional[Union[str, None]] = None,\n    y_label: Optional[Union[str, None]] = None,\n    hue_label: Optional[Union[str, None]] = None,\n    labels: Optional[Dict[str, str]] = {},\n    export_key: Optional[Union[os.PathLike, None]] = None,\n    show: Optional[bool] = True,\n) -&gt; None:\n    \"\"\"\n    Plots the results of the simulation.\n\n    Args:\n        data (pd.DataFrame):\n            The data to plot.\n        x (str):\n            The variable to use for the x-axis.\n        hue (Union[str, List[str]]):\n            The variable(s) to use for the hue.\n        x_label (Optional[Union[str, None]], optional):\n            The label for the x-axis. Defaults to None.\n        y_label (Optional[Union[str, None]], optional):\n            The label for the y-axis. Defaults to None.\n        hue_label (Optional[Union[str, None]], optional):\n            The label for the hue. Defaults to None.\n        labels (Optional[Dict[str, str]], optional):\n            A dictionary of labels to apply to the data. Defaults to {}.\n        export_key (Optional[Union[os.PathLike, None]], optional):\n            The path to save the plot to. Defaults to None.\n        show (Optional[bool], optional):\n            Whether to display the plot. Defaults to True.\n\n    Returns:\n        None\n    \"\"\"\n    # Conversion des arguments en liste\n    if isinstance(hue, str):\n        hue = [hue]\n\n    # Cr\u00e9ation des noms \u00e0 partir des labels\n    id_name = x_label if (x_label is not None) else x\n    var_name = hue_label if (hue_label is not None) else \"Variable\"\n    value_name = y_label if (y_label is not None) else \"Valeur\"\n\n    # R\u00e9organisation du jeu de donn\u00e9es\n    data_graph = pd.melt(\n        frame=data,\n        id_vars=x,\n        value_vars=hue,\n        var_name=var_name,\n        value_name=value_name,\n    ).rename({x: id_name}, axis=1)\n    # Application des labels\n    data_graph[var_name] = (\n        data_graph[var_name].map(labels).fillna(data_graph[var_name])\n    )\n\n    # Initialisation de la figure\n    fig, ax = plt.subplots()\n    # Construction du graphique\n    sns.lineplot(data=data_graph, x=id_name, y=value_name, hue=var_name)\n    # Formattage de l'axe des ordonn\u00e9es\n    if all([\"_prop_\" in var_hue for var_hue in hue]):\n        ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))\n    # Exportation\n    if export_key is not None:\n        plt.savefig(export_key, bbox_inches=\"tight\")\n\n    # Logging\n    self.logger.info(f\"Successfully build graph\")\n\n    if show:\n        plt.show()\n    else:\n        plt.close(\"all\")\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.simulate_reform","title":"simulate_reform","text":"<pre><code>simulate_reform(name: str, reform_params: dict, year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; DataFrame\n</code></pre> <p>Simulates a reform.</p> <p>Initializes the simulation case, initializes the tax-benefit system, applies the reform, simulates the variables, and preprocesses the allegement base.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the reform.</p> required <code>reform_params</code> <code>dict</code> <p>The parameters of the reform.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is being performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The simulated data.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def simulate_reform(\n    self,\n    name: str,\n    reform_params: dict,\n    year: int,\n    simulation_step_smic: float,\n    simulation_max_smic: float,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates a reform.\n\n    Initializes the simulation case, initializes the tax-benefit system,\n    applies the reform, simulates the variables, and preprocesses the allegement base.\n\n    Args:\n        name (str):\n            The name of the reform.\n        reform_params (dict):\n            The parameters of the reform.\n        year (int):\n            The year for which the simulation is being performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n\n    Returns:\n        (pd.DataFrame): The simulated data.\n    \"\"\"\n    # Initialisation du cas de simulation\n    if not hasattr(self, \"base_case\"):\n        self.init_base_case(\n            year=year,\n            simulation_step_smic=simulation_step_smic,\n            simulation_max_smic=simulation_max_smic,\n        )\n\n    # Initialisation des param\u00e8tres du syst\u00e8me sociofiscal\n    tax_benefit_system = FranceTaxBenefitSystem()\n\n    # Application de la r\u00e9forme\n    reformed_tax_benefit_system = create_and_apply_structural_reform_ag(\n        tax_benefit_system=tax_benefit_system, dict_params=reform_params\n    )\n\n    # Logging\n    self.logger.info(\"Successfully updated the tax-benefit system\")\n\n    # Extraction du type de la r\u00e9forme\n    reform_type = reform_params[\"TYPE\"]\n\n    # It\u00e9ration de la simulation\n    data_simul = self.base_case_simulation(\n        tax_benefit_system=reformed_tax_benefit_system,\n        year=year,\n        list_var_simul=[\"assiette_allegement\", f\"new_allegement_{reform_type}\"],\n    )\n\n    # Renomination de la variable simul\u00e9e pour correspondre au nom du sc\u00e9nario\n    data_simul.rename(\n        {f\"new_allegement_{reform_type}\": f\"new_allegement_{name.lower()}\"},\n        axis=1,\n        inplace=True,\n    )\n\n    # Retraitement de l'assiette d'all\u00e8gements\n    data_simul = self._preprocess_assiette_allegement(\n        data=data_simul,\n        year=year,\n        list_var=[\"assiette_allegement\", f\"new_allegement_{name.lower()}\"],\n    )\n\n    return data_simul\n</code></pre>"},{"location":"api/TheoreticalSimulation/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulation.value_smic","title":"value_smic","text":"<pre><code>value_smic(year: int) -&gt; float\n</code></pre> <p>Calculates the value of the SMIC for the given year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the SMIC value is calculated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the SMIC for the given year.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def value_smic(self, year: int) -&gt; float:\n    \"\"\"\n    Calculates the value of the SMIC for the given year.\n\n    Args:\n        year (int):\n            The year for which the SMIC value is calculated.\n\n    Returns:\n        (float): The value of the SMIC for the given year.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    value_smic = sum(\n        [\n            tax_benefit_system.get_parameters_at_instant(\n                instant=f\"{year}-{month}\"\n            ).marche_travail.salaire_minimum.smic.smic_b_mensuel\n            for month in [str(m).zfill(2) for m in range(1, 13)]\n        ]\n    )\n    # Logging\n    self.logger.info(f\"The SMIC value computed for {year} is {value_smic} \u20ac\")\n\n    return value_smic\n</code></pre>"},{"location":"api/TheoreticalSimulator/","title":"TheoreticalSimulator","text":""},{"location":"api/TheoreticalSimulator/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulator","title":"TheoreticalSimulator","text":"<p>A class for performing theoretical simulations.</p> <p>This class provides methods for initializing a base case, simulating the base case, and plotting the results.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>A logger for logging messages.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>class TheoreticalSimulator:\n    \"\"\"\n    A class for performing theoretical simulations.\n\n    This class provides methods for initializing a base case, simulating the base case, and plotting the results.\n\n    Attributes:\n        logger (logging.Logger):\n            A logger for logging messages.\n\n    \"\"\"\n\n    # Initialisation\n    def __init__(\n        self,\n        log_filename: Optional[os.PathLike] = os.path.join(\n            FILE_PATH.parents[3], \"logs/theoretical_simulation.log\"\n        ),\n    ) -&gt; None:\n        \"\"\"\n        Constructs all the necessary attributes for the EmpiricalSimulator object.\n\n        Args:\n            log_filename (os.PathLike, optional): The path to the log file. Defaults to os.path.join(FILE_PATH.parents[3], 'logs/empirical_simulation.log').\n\n        \"\"\"\n        # Initialisation du logger\n        self.logger = _init_logger(filename=log_filename)\n\n    # Fonction auxiliaire de calcul de la valeur du SMIC\n    def value_smic(self, year: int) -&gt; float:\n        \"\"\"\n        Calculates the value of the SMIC for the given year.\n\n        Args:\n            year (int):\n                The year for which the SMIC value is calculated.\n\n        Returns:\n            (float): The value of the SMIC for the given year.\n        \"\"\"\n        # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n        tax_benefit_system = FranceTaxBenefitSystem()\n        value_smic = sum(\n            [\n                tax_benefit_system.get_parameters_at_instant(\n                    instant=f\"{year}-{month}\"\n                ).marche_travail.salaire_minimum.smic.smic_b_mensuel\n                for month in [str(m).zfill(2) for m in range(1, 13)]\n            ]\n        )\n        # Logging\n        self.logger.info(f\"The SMIC value computed for {year} is {value_smic} \u20ac\")\n\n        return value_smic\n\n    # Initialisation d'un cas de base pour r\u00e9aliser une simulation\n    def init_base_case(\n        self, year: int, simulation_step_smic: float, simulation_max_smic: float\n    ) -&gt; None:\n        \"\"\"\n        Initializes a base case for simulation.\n\n        Args:\n            year (int):\n                The year for which the simulation is performed.\n            simulation_step_smic (float):\n                The step size for the simulation, as a multiple of the SMIC value.\n            simulation_max_smic (float):\n                The maximum value for the simulation, as a multiple of the SMIC value.\n        \"\"\"\n        # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n        tax_benefit_system = FranceTaxBenefitSystem()\n        # Extraction de la valeur moyenne de SMIC sur l'ann\u00e9e\n        value_smic = self.value_smic(year=year)\n        # Calcul de la valeur maximale de la simulation et de la valeur du pas\n        simulation_max = simulation_max_smic * value_smic\n        simulation_step = simulation_step_smic * value_smic\n        # Calcul du nombre d'observations dans la simulation entre le min (1 SMIC) et le max avec le pas sp\u00e9cifi\u00e9\n        simulation_count = ceil((simulation_max - value_smic) / simulation_step) + 1\n        # D\u00e9finition des caract\u00e9ristiques de l'individu\n        self.base_case = {\n            \"individus\": {\n                \"individu_1\": {\n                    \"effectif_entreprise\": {year: 200},\n                    \"depcom_entreprise\": {year: \"93001\"},\n                    \"contrat_de_travail_debut\": {year: \"2009-03-16\"},\n                    \"heures_remunerees_volume\": {year: 1820},\n                    \"prime_exceptionnelle_pouvoir_achat\": {year: 0},\n                    \"quotite_de_travail\": {year: 12},\n                    \"prime_partage_valeur_exoneree\": {year: 0},\n                    \"prime_partage_valeur_non_exoneree\": {year: 0},\n                    \"age\": {year: 40},\n                    \"secteur_activite_employeur\": {\n                        year: \"non_agricole\"\n                    },  # {year : TypesSecteurActivite.non_agricole},\n                    \"exoneration_cotisations_employeur_tode_eligibilite\": {year: False},\n                    \"choix_exoneration_cotisations_employeur_agricole\": {year: False},\n                    \"travailleur_occasionnel_agricole\": {year: False},\n                    \"zone_restructuration_defense\": {year: False},\n                    \"zone_revitalisation_rurale\": {year: False},\n                    \"categorie_salarie\": {\n                        year: \"prive_non_cadre\"\n                    },  # {year : TypesCategorieSalarie.prive_non_cadre},\n                    \"contrat_de_travail\": {\n                        year: \"temps_plein\"\n                    },  # {year : TypesContratDeTravail.temps_plein},\n                    \"contrat_de_travail_fin\": {year: \"2099-12-31\"},\n                    \"contrat_de_travail_type\": {\n                        year: \"cdi\"\n                    },  # {year : TypesContrat.cdi},\n                    \"salarie_regime_alsace_moselle\": {year: False},\n                    #'salaire_de_base'\n                    \"remuneration_apprenti\": {year: 0},\n                    \"apprentissage_contrat_debut\": {year: \"1970-01-01\"},\n                    \"apprenti\": {year: False},\n                    \"stage_duree_heures\": {year: 0},\n                    \"stage_gratification\": {year: 0},\n                    \"taux_versement_transport\": {year: 0.032},\n                    \"taux_accident_travail\": {year: 0.0212},\n                }\n            },\n            \"menages\": {\n                \"menage_1\": {\n                    \"personne_de_reference\": [\"individu_1\"],\n                    \"depcom\": {year: \"93001\"},\n                },\n            },\n            \"familles\": {\"famille_1\": {\"parents\": [\"individu_1\"]}},\n            \"foyers_fiscaux\": {\"foyer_fiscal_1\": {\"declarants\": [\"individu_1\"]}},\n            \"axes\": [\n                [\n                    {\n                        \"count\": simulation_count,\n                        \"name\": \"salaire_de_base\",\n                        \"min\": value_smic,\n                        \"max\": simulation_max,\n                        \"period\": year,\n                    }\n                ]\n            ],\n        }\n\n        # Logging\n        self.logger.info(\"Successfully initialized a test case\")\n\n    # Fonction auxilaire d'it\u00e9ration d'une simulation sur un cas\n    def base_case_simulation(\n        self, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Performs a simulation on the base case.\n\n        Args:\n            tax_benefit_system (TaxBenefitSystem):\n                The tax-benefit system to use for the simulation.\n            year (int):\n                The year for which the simulation is performed.\n            list_var_simul (List[str]):\n                A list of variables to simulate.\n\n        Returns:\n            (pd.DataFrame): A dataframe containing the results of the simulation.\n        \"\"\"\n        # Initialisation des param\u00e8tres de la simulation\n        simulation_builder = SimulationBuilder()\n        simulation = simulation_builder.build_from_entities(\n            tax_benefit_system, self.base_case\n        )\n        # Initialisation du dictionnaire r\u00e9sultat\n        dict_simul = {}\n        # It\u00e9ration sur la liste des variables \u00e0 simuler\n        for variable in list_var_simul:\n            dict_simul[variable] = simulation.calculate_add(variable, year)\n            # Logging\n            self.logger.info(f\"Successfully simulated {variable} for period {year}\")\n        # Conversion en dataFrame\n        data_simul = pd.DataFrame(dict_simul)\n\n        return data_simul\n\n    # Fonction auxiliaire de trac\u00e9 des graphiques\n    def plot(\n        self,\n        data: pd.DataFrame,\n        x: str,\n        hue: Union[str, List[str]],\n        x_label: Optional[Union[str, None]] = None,\n        y_label: Optional[Union[str, None]] = None,\n        hue_label: Optional[Union[str, None]] = None,\n        labels: Optional[Dict[str, str]] = {},\n        export_key: Optional[Union[os.PathLike, None]] = None,\n        show: Optional[bool] = True,\n    ) -&gt; None:\n        \"\"\"\n        Plots the results of the simulation.\n\n        Args:\n            data (pd.DataFrame):\n                The data to plot.\n            x (str):\n                The variable to use for the x-axis.\n            hue (Union[str, List[str]]):\n                The variable(s) to use for the hue.\n            x_label (Optional[Union[str, None]], optional):\n                The label for the x-axis. Defaults to None.\n            y_label (Optional[Union[str, None]], optional):\n                The label for the y-axis. Defaults to None.\n            hue_label (Optional[Union[str, None]], optional):\n                The label for the hue. Defaults to None.\n            labels (Optional[Dict[str, str]], optional):\n                A dictionary of labels to apply to the data. Defaults to {}.\n            export_key (Optional[Union[os.PathLike, None]], optional):\n                The path to save the plot to. Defaults to None.\n            show (Optional[bool], optional):\n                Whether to display the plot. Defaults to True.\n\n        Returns:\n            None\n        \"\"\"\n        # Conversion des arguments en liste\n        if isinstance(hue, str):\n            hue = [hue]\n\n        # Cr\u00e9ation des noms \u00e0 partir des labels\n        id_name = x_label if (x_label is not None) else x\n        var_name = hue_label if (hue_label is not None) else \"Variable\"\n        value_name = y_label if (y_label is not None) else \"Valeur\"\n\n        # R\u00e9organisation du jeu de donn\u00e9es\n        data_graph = pd.melt(\n            frame=data,\n            id_vars=x,\n            value_vars=hue,\n            var_name=var_name,\n            value_name=value_name,\n        ).rename({x: id_name}, axis=1)\n        # Application des labels\n        data_graph[var_name] = (\n            data_graph[var_name].map(labels).fillna(data_graph[var_name])\n        )\n\n        # Initialisation de la figure\n        fig, ax = plt.subplots()\n        # Construction du graphique\n        sns.lineplot(data=data_graph, x=id_name, y=value_name, hue=var_name)\n        # Formattage de l'axe des ordonn\u00e9es\n        if all([\"_prop_\" in var_hue for var_hue in hue]):\n            ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))\n        # Exportation\n        if export_key is not None:\n            plt.savefig(export_key, bbox_inches=\"tight\")\n\n        # Logging\n        self.logger.info(f\"Successfully build graph\")\n\n        if show:\n            plt.show()\n        else:\n            plt.close(\"all\")\n</code></pre>"},{"location":"api/TheoreticalSimulator/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulator.base_case_simulation","title":"base_case_simulation","text":"<pre><code>base_case_simulation(tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]) -&gt; DataFrame\n</code></pre> <p>Performs a simulation on the base case.</p> <p>Parameters:</p> Name Type Description Default <code>tax_benefit_system</code> <code>TaxBenefitSystem</code> <p>The tax-benefit system to use for the simulation.</p> required <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>list_var_simul</code> <code>List[str]</code> <p>A list of variables to simulate.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing the results of the simulation.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def base_case_simulation(\n    self, tax_benefit_system: TaxBenefitSystem, year: int, list_var_simul: List[str]\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Performs a simulation on the base case.\n\n    Args:\n        tax_benefit_system (TaxBenefitSystem):\n            The tax-benefit system to use for the simulation.\n        year (int):\n            The year for which the simulation is performed.\n        list_var_simul (List[str]):\n            A list of variables to simulate.\n\n    Returns:\n        (pd.DataFrame): A dataframe containing the results of the simulation.\n    \"\"\"\n    # Initialisation des param\u00e8tres de la simulation\n    simulation_builder = SimulationBuilder()\n    simulation = simulation_builder.build_from_entities(\n        tax_benefit_system, self.base_case\n    )\n    # Initialisation du dictionnaire r\u00e9sultat\n    dict_simul = {}\n    # It\u00e9ration sur la liste des variables \u00e0 simuler\n    for variable in list_var_simul:\n        dict_simul[variable] = simulation.calculate_add(variable, year)\n        # Logging\n        self.logger.info(f\"Successfully simulated {variable} for period {year}\")\n    # Conversion en dataFrame\n    data_simul = pd.DataFrame(dict_simul)\n\n    return data_simul\n</code></pre>"},{"location":"api/TheoreticalSimulator/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulator.init_base_case","title":"init_base_case","text":"<pre><code>init_base_case(year: int, simulation_step_smic: float, simulation_max_smic: float) -&gt; None\n</code></pre> <p>Initializes a base case for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the simulation is performed.</p> required <code>simulation_step_smic</code> <code>float</code> <p>The step size for the simulation, as a multiple of the SMIC value.</p> required <code>simulation_max_smic</code> <code>float</code> <p>The maximum value for the simulation, as a multiple of the SMIC value.</p> required Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def init_base_case(\n    self, year: int, simulation_step_smic: float, simulation_max_smic: float\n) -&gt; None:\n    \"\"\"\n    Initializes a base case for simulation.\n\n    Args:\n        year (int):\n            The year for which the simulation is performed.\n        simulation_step_smic (float):\n            The step size for the simulation, as a multiple of the SMIC value.\n        simulation_max_smic (float):\n            The maximum value for the simulation, as a multiple of the SMIC value.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    # Extraction de la valeur moyenne de SMIC sur l'ann\u00e9e\n    value_smic = self.value_smic(year=year)\n    # Calcul de la valeur maximale de la simulation et de la valeur du pas\n    simulation_max = simulation_max_smic * value_smic\n    simulation_step = simulation_step_smic * value_smic\n    # Calcul du nombre d'observations dans la simulation entre le min (1 SMIC) et le max avec le pas sp\u00e9cifi\u00e9\n    simulation_count = ceil((simulation_max - value_smic) / simulation_step) + 1\n    # D\u00e9finition des caract\u00e9ristiques de l'individu\n    self.base_case = {\n        \"individus\": {\n            \"individu_1\": {\n                \"effectif_entreprise\": {year: 200},\n                \"depcom_entreprise\": {year: \"93001\"},\n                \"contrat_de_travail_debut\": {year: \"2009-03-16\"},\n                \"heures_remunerees_volume\": {year: 1820},\n                \"prime_exceptionnelle_pouvoir_achat\": {year: 0},\n                \"quotite_de_travail\": {year: 12},\n                \"prime_partage_valeur_exoneree\": {year: 0},\n                \"prime_partage_valeur_non_exoneree\": {year: 0},\n                \"age\": {year: 40},\n                \"secteur_activite_employeur\": {\n                    year: \"non_agricole\"\n                },  # {year : TypesSecteurActivite.non_agricole},\n                \"exoneration_cotisations_employeur_tode_eligibilite\": {year: False},\n                \"choix_exoneration_cotisations_employeur_agricole\": {year: False},\n                \"travailleur_occasionnel_agricole\": {year: False},\n                \"zone_restructuration_defense\": {year: False},\n                \"zone_revitalisation_rurale\": {year: False},\n                \"categorie_salarie\": {\n                    year: \"prive_non_cadre\"\n                },  # {year : TypesCategorieSalarie.prive_non_cadre},\n                \"contrat_de_travail\": {\n                    year: \"temps_plein\"\n                },  # {year : TypesContratDeTravail.temps_plein},\n                \"contrat_de_travail_fin\": {year: \"2099-12-31\"},\n                \"contrat_de_travail_type\": {\n                    year: \"cdi\"\n                },  # {year : TypesContrat.cdi},\n                \"salarie_regime_alsace_moselle\": {year: False},\n                #'salaire_de_base'\n                \"remuneration_apprenti\": {year: 0},\n                \"apprentissage_contrat_debut\": {year: \"1970-01-01\"},\n                \"apprenti\": {year: False},\n                \"stage_duree_heures\": {year: 0},\n                \"stage_gratification\": {year: 0},\n                \"taux_versement_transport\": {year: 0.032},\n                \"taux_accident_travail\": {year: 0.0212},\n            }\n        },\n        \"menages\": {\n            \"menage_1\": {\n                \"personne_de_reference\": [\"individu_1\"],\n                \"depcom\": {year: \"93001\"},\n            },\n        },\n        \"familles\": {\"famille_1\": {\"parents\": [\"individu_1\"]}},\n        \"foyers_fiscaux\": {\"foyer_fiscal_1\": {\"declarants\": [\"individu_1\"]}},\n        \"axes\": [\n            [\n                {\n                    \"count\": simulation_count,\n                    \"name\": \"salaire_de_base\",\n                    \"min\": value_smic,\n                    \"max\": simulation_max,\n                    \"period\": year,\n                }\n            ]\n        ],\n    }\n\n    # Logging\n    self.logger.info(\"Successfully initialized a test case\")\n</code></pre>"},{"location":"api/TheoreticalSimulator/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulator.plot","title":"plot","text":"<pre><code>plot(data: DataFrame, x: str, hue: Union[str, List[str]], x_label: Optional[Union[str, None]] = None, y_label: Optional[Union[str, None]] = None, hue_label: Optional[Union[str, None]] = None, labels: Optional[Dict[str, str]] = {}, export_key: Optional[Union[PathLike, None]] = None, show: Optional[bool] = True) -&gt; None\n</code></pre> <p>Plots the results of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to plot.</p> required <code>x</code> <code>str</code> <p>The variable to use for the x-axis.</p> required <code>hue</code> <code>Union[str, List[str]]</code> <p>The variable(s) to use for the hue.</p> required <code>x_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the x-axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the y-axis. Defaults to None.</p> <code>None</code> <code>hue_label</code> <code>Optional[Union[str, None]]</code> <p>The label for the hue. Defaults to None.</p> <code>None</code> <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary of labels to apply to the data. Defaults to {}.</p> <code>{}</code> <code>export_key</code> <code>Optional[Union[PathLike, None]]</code> <p>The path to save the plot to. Defaults to None.</p> <code>None</code> <code>show</code> <code>Optional[bool]</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def plot(\n    self,\n    data: pd.DataFrame,\n    x: str,\n    hue: Union[str, List[str]],\n    x_label: Optional[Union[str, None]] = None,\n    y_label: Optional[Union[str, None]] = None,\n    hue_label: Optional[Union[str, None]] = None,\n    labels: Optional[Dict[str, str]] = {},\n    export_key: Optional[Union[os.PathLike, None]] = None,\n    show: Optional[bool] = True,\n) -&gt; None:\n    \"\"\"\n    Plots the results of the simulation.\n\n    Args:\n        data (pd.DataFrame):\n            The data to plot.\n        x (str):\n            The variable to use for the x-axis.\n        hue (Union[str, List[str]]):\n            The variable(s) to use for the hue.\n        x_label (Optional[Union[str, None]], optional):\n            The label for the x-axis. Defaults to None.\n        y_label (Optional[Union[str, None]], optional):\n            The label for the y-axis. Defaults to None.\n        hue_label (Optional[Union[str, None]], optional):\n            The label for the hue. Defaults to None.\n        labels (Optional[Dict[str, str]], optional):\n            A dictionary of labels to apply to the data. Defaults to {}.\n        export_key (Optional[Union[os.PathLike, None]], optional):\n            The path to save the plot to. Defaults to None.\n        show (Optional[bool], optional):\n            Whether to display the plot. Defaults to True.\n\n    Returns:\n        None\n    \"\"\"\n    # Conversion des arguments en liste\n    if isinstance(hue, str):\n        hue = [hue]\n\n    # Cr\u00e9ation des noms \u00e0 partir des labels\n    id_name = x_label if (x_label is not None) else x\n    var_name = hue_label if (hue_label is not None) else \"Variable\"\n    value_name = y_label if (y_label is not None) else \"Valeur\"\n\n    # R\u00e9organisation du jeu de donn\u00e9es\n    data_graph = pd.melt(\n        frame=data,\n        id_vars=x,\n        value_vars=hue,\n        var_name=var_name,\n        value_name=value_name,\n    ).rename({x: id_name}, axis=1)\n    # Application des labels\n    data_graph[var_name] = (\n        data_graph[var_name].map(labels).fillna(data_graph[var_name])\n    )\n\n    # Initialisation de la figure\n    fig, ax = plt.subplots()\n    # Construction du graphique\n    sns.lineplot(data=data_graph, x=id_name, y=value_name, hue=var_name)\n    # Formattage de l'axe des ordonn\u00e9es\n    if all([\"_prop_\" in var_hue for var_hue in hue]):\n        ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))\n    # Exportation\n    if export_key is not None:\n        plt.savefig(export_key, bbox_inches=\"tight\")\n\n    # Logging\n    self.logger.info(f\"Successfully build graph\")\n\n    if show:\n        plt.show()\n    else:\n        plt.close(\"all\")\n</code></pre>"},{"location":"api/TheoreticalSimulator/#bozio_wasmer_simulations.simulation.theoretical.base.TheoreticalSimulator.value_smic","title":"value_smic","text":"<pre><code>value_smic(year: int) -&gt; float\n</code></pre> <p>Calculates the value of the SMIC for the given year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The year for which the SMIC value is calculated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the SMIC for the given year.</p> Source code in <code>bozio_wasmer_simulations/simulation/theoretical/base.py</code> <pre><code>def value_smic(self, year: int) -&gt; float:\n    \"\"\"\n    Calculates the value of the SMIC for the given year.\n\n    Args:\n        year (int):\n            The year for which the SMIC value is calculated.\n\n    Returns:\n        (float): The value of the SMIC for the given year.\n    \"\"\"\n    # Initialisation du syst\u00e8me socio-fiscal contenant les valeurs de SMIC en param\u00e8tres\n    tax_benefit_system = FranceTaxBenefitSystem()\n    value_smic = sum(\n        [\n            tax_benefit_system.get_parameters_at_instant(\n                instant=f\"{year}-{month}\"\n            ).marche_travail.salaire_minimum.smic.smic_b_mensuel\n            for month in [str(m).zfill(2) for m in range(1, 13)]\n        ]\n    )\n    # Logging\n    self.logger.info(f\"The SMIC value computed for {year} is {value_smic} \u20ac\")\n\n    return value_smic\n</code></pre>"},{"location":"api/add_weights_eqtp_accos/","title":"add_weights_eqtp_accos","text":""},{"location":"api/add_weights_eqtp_accos/#bozio_wasmer_simulations.simulation.empirical.weights.add_weights_eqtp_accos","title":"add_weights_eqtp_accos","text":"<pre><code>add_weights_eqtp_accos(data_dads: DataFrame, year: int, var_eqtp: str, var_sal_brut: str, var_smic_proratise: str = 'smic_proratise') -&gt; DataFrame\n</code></pre> <p>Adds weights to the data based on ACOSS data.</p> <p>This function calculates the salary as a proportion of the SMIC and creates salary brackets. It then calculates the current weights and the target weights based on ACOSS data. The weights are calculated as the ratio of the target weights to the current weights. The function returns the data with the weights added.</p> <p>Parameters:</p> Name Type Description Default <code>data_dads</code> <code>DataFrame</code> <p>The input data.</p> required <code>year</code> <code>int</code> <p>The year for which the weights are calculated.</p> required <code>var_eqtp</code> <code>str</code> <p>The name of the variable containing the employment data.</p> required <code>var_sal_brut</code> <code>str</code> <p>The name of the variable containing the gross salary data.</p> required <code>var_smic_proratise</code> <code>str</code> <p>The name of the variable containing the prorated SMIC data. Default is 'smic_proratise'.</p> <code>'smic_proratise'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The input data with the weights added.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/weights.py</code> <pre><code>def add_weights_eqtp_accos(\n    data_dads: pd.DataFrame,\n    year: int,\n    var_eqtp: str,\n    var_sal_brut: str,\n    var_smic_proratise: str = \"smic_proratise\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Adds weights to the data based on ACOSS data.\n\n    This function calculates the salary as a proportion of the SMIC and creates salary brackets.\n    It then calculates the current weights and the target weights based on ACOSS data.\n    The weights are calculated as the ratio of the target weights to the current weights.\n    The function returns the data with the weights added.\n\n    Args:\n        data_dads (pd.DataFrame):\n            The input data.\n        year (int):\n            The year for which the weights are calculated.\n        var_eqtp (str):\n            The name of the variable containing the employment data.\n        var_sal_brut (str):\n            The name of the variable containing the gross salary data.\n        var_smic_proratise (str, optional):\n            The name of the variable containing the prorated SMIC data. Default is 'smic_proratise'.\n\n    Returns:\n        (pd.DataFrame): The input data with the weights added.\n    \"\"\"\n    # Salaire en proportion du SMIC\n    if \"salaire_brut_smic\" not in data_dads.columns:\n        data_dads[\"salaire_brut_smic\"] = (\n            data_dads[var_sal_brut] / data_dads[var_smic_proratise]\n        )\n\n    # Cr\u00e9ation de tranche de salaire brut en proportion du SMIC\n    data_dads[\"tranche_salaire_brut_smic_100\"] = (\n        np.floor(data_dads[\"salaire_brut_smic\"] * 100) / 100\n    )\n    data_dads[\"tranche_salaire_brut_smic_10\"] = (\n        np.floor(data_dads[\"salaire_brut_smic\"] * 10) / 10\n    )\n    data_dads[\"tranche_salaire_brut_smic_1\"] = np.floor(data_dads[\"salaire_brut_smic\"])\n    # Combination des tranches de 10 % et de 1 % en dessous de 2 SMIC et de 1 au dessus de 10 SMIC\n    data_dads[\"tranche_salaire_brut_smic_100\"] = np.where(\n        data_dads[\"salaire_brut_smic\"] &lt; 2,\n        data_dads[\"tranche_salaire_brut_smic_100\"],\n        data_dads[\"tranche_salaire_brut_smic_10\"],\n    )\n    data_dads[\"tranche_salaire_brut_smic_100\"] = np.where(\n        data_dads[\"salaire_brut_smic\"] &gt; 10,\n        data_dads[\"tranche_salaire_brut_smic_1\"],\n        data_dads[\"tranche_salaire_brut_smic_100\"],\n    )\n    # Suppression des tranches de 10 % et de 1\n    data_dads.drop(\n        [\"tranche_salaire_brut_smic_10\", \"tranche_salaire_brut_smic_1\"],\n        axis=1,\n        inplace=True,\n    )\n    # Cr\u00e9ation des tranches entre 5 et 7.5 et entre 7,5 et 10\n    data_dads.loc[\n        (data_dads[\"salaire_brut_smic\"] &gt;= 5) &amp; (data_dads[\"salaire_brut_smic\"] &lt; 7.5),\n        \"tranche_salaire_brut_smic_100\",\n    ] = 5\n    data_dads.loc[\n        (data_dads[\"salaire_brut_smic\"] &gt;= 7.5) &amp; (data_dads[\"salaire_brut_smic\"] &lt; 10),\n        \"tranche_salaire_brut_smic_10\",\n    ] = 7.5\n\n    # Ajout des poids\n    # Calcul des poids actuels\n    # data_weights = data_dads.groupby('tranche_salaire_brut_smic_10')[['salaire_de_base']].sum().rename({'salaire_de_base' : 'current_weight'}, axis=1).reset_index()\n    data_weights = (\n        data_dads.groupby(\"tranche_salaire_brut_smic_100\")[[var_eqtp]]\n        .sum()\n        .rename({var_eqtp: \"current_weight\"}, axis=1)\n        .reset_index()\n    )\n\n    # Poids de l'ann\u00e9e\n    data_weights_acoss = pd.read_excel(\n        os.path.join(FILE_PATH.parents[3], f\"data/distributions_{year}_missionBW.xlsx\"),\n        sheet_name=\"distributions\",\n        skiprows=3,\n    )\n    # S\u00e9lection et renomination des colonnes d'int\u00e9r\u00eat\n    data_weights_acoss = data_weights_acoss[\n        [\"\u00c9tiquettes de lignes\", \"Somme de etp_f2\"]\n    ].rename(\n        {\n            \"\u00c9tiquettes de lignes\": \"tranche_salaire_brut_smic_100\",\n            \"Somme de etp_f2\": \"target_weight\",\n        },\n        axis=1,\n    )\n    # Conversion en num\u00e9rique\n    data_weights_acoss[\"tranche_salaire_brut_smic_100\"] = pd.to_numeric(\n        data_weights_acoss[\"tranche_salaire_brut_smic_100\"], errors=\"coerce\"\n    )\n    # Suppression des lignes de total imput\u00e9es par dans Nan\n    data_weights_acoss.dropna(\n        subset=[\"tranche_salaire_brut_smic_100\"], axis=0, how=\"any\", inplace=True\n    )\n    data_weights_acoss = data_weights_acoss.groupby(\n        \"tranche_salaire_brut_smic_100\", as_index=False\n    )[[\"target_weight\"]].sum()\n    # Appariement\n    data_weights = pd.merge(\n        left=data_weights,\n        right=data_weights_acoss,\n        on=\"tranche_salaire_brut_smic_100\",\n        how=\"outer\",\n        validate=\"one_to_one\",\n    ).fillna(0)\n    # Cr\u00e9ation des poids\n    data_weights[\"weights\"] = (\n        data_weights[\"target_weight\"] / data_weights[\"current_weight\"]\n    )\n    # Retraitement des + infini\n    data_weights.loc[np.isinf(data_weights[\"weights\"]), \"weights\"] = 0\n    # Appariement avec les DADS\n    data_dads = pd.merge(\n        left=data_dads,\n        right=data_weights[[\"tranche_salaire_brut_smic_100\", \"weights\"]],\n        how=\"left\",\n        on=\"tranche_salaire_brut_smic_100\",\n        validate=\"many_to_one\",\n    ).drop(\"tranche_salaire_brut_smic_100\", axis=1)\n\n    # Non pond\u00e9ration des salari\u00e9s sous le SMIC\n    data_dads.loc[data_dads[\"salaire_brut_smic\"] &lt; 1, \"weights\"] = 0\n    # Ajout des poids des entreprises\n    data_dads = pd.merge(\n        left=data_dads,\n        right=data_dads.groupby(\"siren\", as_index=False)[\"weights\"]\n        .sum()\n        .rename({\"weights\": \"firm_total_weights\"}, axis=1),\n        on=\"siren\",\n        validate=\"many_to_one\",\n    )\n\n    return data_dads\n</code></pre>"},{"location":"api/build_data_evol_ct/","title":"build_data_evol_ct","text":""},{"location":"api/build_data_evol_ct/#bozio_wasmer_simulations.description.datasets.build_data_evol_ct","title":"build_data_evol_ct","text":"<pre><code>build_data_evol_ct(data_source: DataFrame, col_new_ct: str, to_concat: bool, col_ct: str = 'salaire_super_brut')\n</code></pre> <p>Creates variables of interest concerning the evolution of the cost of labor.</p> <p>Parameters:</p> Name Type Description Default <code>data_source</code> <code>DataFrame</code> <p>The source data.</p> required <code>col_new_ct</code> <code>str</code> <p>The column of the new cost of labor.</p> required <code>to_concat</code> <code>bool</code> <p>Whether to concatenate the result to the source data.</p> required <code>col_ct</code> <code>str</code> <p>The column of the cost of labor. Defaults to 'salaire_super_brut'.</p> <code>'salaire_super_brut'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The data with the cost of labor evolution variables.</p> Source code in <code>bozio_wasmer_simulations/description/datasets.py</code> <pre><code>def build_data_evol_ct(\n    data_source: pd.DataFrame,\n    col_new_ct: str,\n    to_concat: bool,\n    col_ct: str = \"salaire_super_brut\",\n):\n    \"\"\"\n    Creates variables of interest concerning the evolution of the cost of labor.\n\n    Args:\n        data_source (pd.DataFrame): The source data.\n        col_new_ct (str): The column of the new cost of labor.\n        to_concat (bool): Whether to concatenate the result to the source data.\n        col_ct (str, optional): The column of the cost of labor. Defaults to 'salaire_super_brut'.\n\n    Returns:\n        (pd.DataFrame): The data with the cost of labor evolution variables.\n    \"\"\"\n    # Copie ind\u00e9pendante des grandeurs d'int\u00e9r\u00eat du jeu de donn\u00e9es\n    data_evol_ct = data_source[[\"siren\", \"weights\", col_new_ct, col_ct]].copy()\n\n    # Cr\u00e9ation du suffixe\n    suffix = col_new_ct[(col_new_ct.find(col_ct) + len(col_ct) + 1) :]\n\n    # Calcul de la diff\u00e9rence du co\u00fbt du travail\n    data_evol_ct[f\"diff_ct_{suffix}\"] = data_evol_ct[col_new_ct] - data_evol_ct[col_ct]\n\n    # Calcul de l'\u00e9volution des salaires\n    data_evol_ct[f\"evol_ct_{suffix}\"] = (\n        data_evol_ct[col_new_ct] - data_evol_ct[col_ct]\n    ) / data_evol_ct[col_ct]\n\n    # Ajout de l'\u00e9volution de la masse salariale au niveau de l'entreprise\n    # Calcul de grandeurs d'int\u00e9r\u00eat\n    data_evol_ct[f\"diff_pond_ct_{suffix}\"] = (\n        data_evol_ct[col_new_ct] - data_evol_ct[col_ct]\n    ).multiply(other=data_evol_ct[\"weights\"])\n    data_evol_ct[\"pond_ct\"] = data_evol_ct[col_ct].multiply(\n        other=data_evol_ct[\"weights\"]\n    )\n    data_effet_siren = (\n        data_evol_ct.groupby(\"siren\")[f\"diff_pond_ct_{suffix}\"]\n        .sum()\n        .divide(other=data_evol_ct.groupby(\"siren\")[\"pond_ct\"].sum())\n        .reset_index()\n        .rename({0: f\"evol_ms_{suffix}\"}, axis=1)\n    )\n    # Appariement de la variation de la masse salariale par siren\n    data_evol_ct = pd.merge(\n        left=data_evol_ct,\n        right=data_effet_siren,\n        on=\"siren\",\n        how=\"left\",\n        validate=\"many_to_one\",\n    )\n    # Suppression de la base des effets au niveau du Siren\n    del data_effet_siren\n\n    if to_concat:\n        # Concat\u00e9narion au jeu de donn\u00e9es d'origine\n        data_source = pd.concat(\n            [\n                data_source,\n                data_evol_ct.drop(\n                    [\n                        \"siren\",\n                        \"weights\",\n                        col_new_ct,\n                        col_ct,\n                        f\"diff_pond_ct_{suffix}\",\n                        \"pond_ct\",\n                    ],\n                    axis=1,\n                ),\n            ],\n            axis=1,\n            join=\"outer\",\n        )\n        # Suppression des jeux de donn\u00e9es des \u00e9volutions\n        del data_evol_ct\n        return data_source\n    else:\n        return data_evol_ct\n</code></pre>"},{"location":"api/build_data_evol_emploi/","title":"build_data_evol_emploi","text":""},{"location":"api/build_data_evol_emploi/#bozio_wasmer_simulations.description.datasets.build_data_evol_emploi","title":"build_data_evol_emploi","text":"<pre><code>build_data_evol_emploi(data_source: DataFrame, col_new_ct: str, col_evol: str, y0_elasticite: float, seuil_pallier_elasticite_smic: float, pallier_elasticite: float, name_elasticite: str, keep_elast: bool, to_concat: bool, col_ct='salaire_super_brut')\n</code></pre> <p>Creates variables of interest concerning the employment effects of reforms.</p> <p>Parameters:</p> Name Type Description Default <code>data_source</code> <code>DataFrame</code> <p>The source data.</p> required <code>col_new_ct</code> <code>str</code> <p>The column of the new cost of labor.</p> required <code>col_evol</code> <code>str</code> <p>The column of the evolution.</p> required <code>y0_elasticite</code> <code>float</code> <p>The initial value of the elasticity.</p> required <code>seuil_pallier_elasticite_smic</code> <code>float</code> <p>The threshold of the elasticity in SMIC.</p> required <code>pallier_elasticite</code> <code>float</code> <p>The step of the elasticity.</p> required <code>name_elasticite</code> <code>str</code> <p>The name of the elasticity.</p> required <code>keep_elast</code> <code>bool</code> <p>Whether to keep the elasticity.</p> required <code>to_concat</code> <code>bool</code> <p>Whether to concatenate the result to the source data.</p> required <code>col_ct</code> <code>str</code> <p>The column of the cost of labor. Defaults to 'salaire_super_brut'.</p> <code>'salaire_super_brut'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The data with the employment effects variables.</p> Source code in <code>bozio_wasmer_simulations/description/datasets.py</code> <pre><code>def build_data_evol_emploi(\n    data_source: pd.DataFrame,\n    col_new_ct: str,\n    col_evol: str,\n    y0_elasticite: float,\n    seuil_pallier_elasticite_smic: float,\n    pallier_elasticite: float,\n    name_elasticite: str,\n    keep_elast: bool,\n    to_concat: bool,\n    col_ct=\"salaire_super_brut\",\n):\n    \"\"\"\n    Creates variables of interest concerning the employment effects of reforms.\n\n    Args:\n        data_source (pd.DataFrame): The source data.\n        col_new_ct (str): The column of the new cost of labor.\n        col_evol (str): The column of the evolution.\n        y0_elasticite (float): The initial value of the elasticity.\n        seuil_pallier_elasticite_smic (float): The threshold of the elasticity in SMIC.\n        pallier_elasticite (float): The step of the elasticity.\n        name_elasticite (str): The name of the elasticity.\n        keep_elast (bool): Whether to keep the elasticity.\n        to_concat (bool): Whether to concatenate the result to the source data.\n        col_ct (str, optional): The column of the cost of labor. Defaults to 'salaire_super_brut'.\n\n    Returns:\n        (pd.DataFrame): The data with the employment effects variables.\n    \"\"\"\n    # Copie ind\u00e9pendante du jeu de donn\u00e9es\n    data_emploi = data_source[\n        [\"salaire_brut_smic\", \"quotite_de_travail\", col_evol]\n    ].copy()\n\n    # Cr\u00e9ation du suffixe\n    suffix = col_new_ct[(col_new_ct.find(col_ct) + len(col_ct) + 1) :]\n    # Calcul de l'\u00e9lasticit\u00e9 emploi (en nombre d'EQTP) selon la m\u00e9thode suivante\n    # y0_elasticite au niveau du smic, pallier_elasticite \u00e0 partir de seuil_pallier_elasticite_smic smic et on tire une droite entre les deux\n    data_emploi[f\"elast_{name_elasticite}\"] = np.maximum(\n        y0_elasticite,\n        np.where(\n            data_emploi[\"salaire_brut_smic\"] &lt; seuil_pallier_elasticite_smic,\n            (\n                y0_elasticite\n                + (pallier_elasticite - y0_elasticite)\n                / (seuil_pallier_elasticite_smic - 1)\n                * (data_emploi[\"salaire_brut_smic\"] - 1)\n            ),\n            pallier_elasticite,\n        ),\n    )\n\n    # Ajout de l'effet emploi\n    data_emploi[f\"effet_emploi_{name_elasticite}_{suffix}\"] = (\n        data_emploi[\"quotite_de_travail\"]\n        * data_emploi[f\"elast_{name_elasticite}\"]\n        * data_emploi[col_evol]\n    )\n\n    # D\u00e9duction de la quotit\u00e9 de travail associ\u00e9e\n    data_emploi[f\"quotite_de_travail_{name_elasticite}_{suffix}\"] = (\n        data_emploi[\"quotite_de_travail\"]\n        + data_emploi[f\"effet_emploi_{name_elasticite}_{suffix}\"]\n    )\n\n    if to_concat:\n        # Concat\u00e9nation\n        if not keep_elast:\n            data_source = pd.concat(\n                [\n                    data_source,\n                    data_emploi.drop(\n                        [\n                            \"salaire_brut_smic\",\n                            \"quotite_de_travail\",\n                            f\"elast_{name_elasticite}\",\n                            col_evol,\n                        ],\n                        axis=1,\n                    ),\n                ],\n                axis=1,\n                join=\"outer\",\n            )\n        else:\n            data_source = pd.concat(\n                [\n                    data_source,\n                    data_emploi.drop(\n                        [\"salaire_brut_smic\", \"quotite_de_travail\", col_evol], axis=1\n                    ),\n                ],\n                axis=1,\n                join=\"outer\",\n            )\n        # Suppression du jeu de donn\u00e9es des emplois\n        del data_emploi\n        return data_source\n    else:\n        return data_emploi\n</code></pre>"},{"location":"api/create_and_apply_structural_reform_ag/","title":"create_and_apply_structural_reform_ag","text":""},{"location":"api/create_and_apply_structural_reform_ag/#bozio_wasmer_simulations.simulation.empirical.reform.create_and_apply_structural_reform_ag","title":"create_and_apply_structural_reform_ag","text":"<pre><code>create_and_apply_structural_reform_ag(tax_benefit_system, dict_params, period='2000-01-01')\n</code></pre> <p>Creates and applies a structural reform to add a new exemption.</p> <p>Depending on the type of general exemption to add, this function modifies the parameters of the tax-benefit system and adds a new variable to calculate. The type of exemption can be 'fillon', 'convexe_fillon', 'allocations_familiales', or 'maladie'.</p> <p>Parameters:</p> Name Type Description Default <code>tax_benefit_system</code> <code>TaxBenefitSystem</code> <p>The initial tax-benefit system.</p> required <code>dict_params</code> <code>dict</code> <p>A dictionary containing the parameters of the reform. The 'TYPE' key indicates the type of exemption to add.</p> required <code>period</code> <code>str</code> <p>The period for which the parameters are defined. Default is '2000-01-01'.</p> <code>'2000-01-01'</code> <p>Returns:</p> Type Description <code>TaxBenefitSystem</code> <p>The reformed tax-benefit system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type of exemption is not 'fillon', 'convexe_fillon', 'allocations_familiales', or 'maladie'.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/reform.py</code> <pre><code>def create_and_apply_structural_reform_ag(\n    tax_benefit_system, dict_params, period=\"2000-01-01\"\n):\n    \"\"\"\n    Creates and applies a structural reform to add a new exemption.\n\n    Depending on the type of general exemption to add, this function modifies the parameters of the tax-benefit system\n    and adds a new variable to calculate. The type of exemption can be 'fillon', 'convexe_fillon', 'allocations_familiales',\n    or 'maladie'.\n\n    Args:\n        tax_benefit_system (TaxBenefitSystem):\n            The initial tax-benefit system.\n        dict_params (dict):\n            A dictionary containing the parameters of the reform. The 'TYPE' key indicates the type of exemption to add.\n        period (str, optional):\n            The period for which the parameters are defined. Default is '2000-01-01'.\n\n    Returns:\n        (TaxBenefitSystem): The reformed tax-benefit system.\n\n    Raises:\n        ValueError: If the type of exemption is not 'fillon', 'convexe_fillon', 'allocations_familiales', or 'maladie'.\n    \"\"\"\n\n    # Distinction suivant le type d'all\u00e8gement g\u00e9n\u00e9ral \u00e0 ajouter\n    if dict_params[\"TYPE\"] == \"fillon\":\n        # D\u00e9finition de la fonction de modification des param\u00e8tres\n        def modify_new_fillon_parameters(parameters):\n            # D\u00e9finition des param\u00e8tres \u00e0 ajouter\n            reform_parameters_subtree = ParameterNode(\n                name=\"new_fillon\",\n                data={\n                    \"ensemble_des_entreprises\": {\n                        \"plafond\": {\n                            \"values\": {\n                                period: {\"value\": dict_params[\"PARAMS\"][\"PLAFOND\"]}\n                            }\n                        },\n                        \"entreprises_de_50_salaries_et_plus\": {\n                            \"values\": {\n                                period: {\n                                    \"value\": dict_params[\"PARAMS\"][\n                                        \"TAUX_50_SALARIES_ET_PLUS\"\n                                    ]\n                                }\n                            }\n                        },\n                        \"entreprises_de_moins_de_50_salaries\": {\n                            \"values\": {\n                                period: {\n                                    \"value\": dict_params[\"PARAMS\"][\n                                        \"TAUX_MOINS_DE_50_SALARIES\"\n                                    ]\n                                }\n                            }\n                        },\n                    }\n                },\n            )\n            # Ajout des param\u00e8tres au noeud d'int\u00e9ret\n            parameters.prelevements_sociaux.reductions_cotisations_sociales.add_child(\n                \"new_fillon\", reform_parameters_subtree\n            )\n\n            return parameters\n\n        # D\u00e9finition de la classe de r\u00e9forme\n        class StructuralReformFillon(Reform):\n            name = \"Ajout d'un nouvel all\u00e8gement g\u00e9n\u00e9ral de type 'All\u00e8gement Fillon'\"\n\n            # Application de la r\u00e9forme\n            def apply(self):\n                # Ajout des param\u00e8tres des all\u00e8gements de cotisation\n                self.modify_parameters(modifier_function=modify_new_fillon_parameters)\n                # Ajout de la variable \u00e0 calculer\n                self.add_variable(new_allegement_fillon)\n\n        # Application de la r\u00e9forme au syst\u00e8me socio-fiscal\n        reformed_tax_benefit_system = StructuralReformFillon(tax_benefit_system)\n\n        return reformed_tax_benefit_system\n\n    elif dict_params[\"TYPE\"] == \"convexe_fillon\":\n        # D\u00e9finition de la fonction de modification des param\u00e8tres\n        def modify_convexe_fillon_parameters(parameters):\n            # D\u00e9finition des param\u00e8tres \u00e0 ajouter\n            reform_parameters_subtree = ParameterNode(\n                name=\"convexe_fillon\",\n                data={\n                    \"ensemble_des_entreprises\": {\n                        \"plafond\": {\n                            \"values\": {\n                                period: {\"value\": dict_params[\"PARAMS\"][\"PLAFOND\"]}\n                            }\n                        },\n                        \"entreprises_de_50_salaries_et_plus\": {\n                            \"values\": {\n                                period: {\n                                    \"value\": dict_params[\"PARAMS\"][\n                                        \"TAUX_50_SALARIES_ET_PLUS\"\n                                    ]\n                                }\n                            }\n                        },\n                        \"entreprises_de_moins_de_50_salaries\": {\n                            \"values\": {\n                                period: {\n                                    \"value\": dict_params[\"PARAMS\"][\n                                        \"TAUX_MOINS_DE_50_SALARIES\"\n                                    ]\n                                }\n                            }\n                        },\n                        \"exposant\": {\n                            \"values\": {\n                                period: {\"value\": dict_params[\"PARAMS\"][\"EXPOSANT\"]}\n                            }\n                        },\n                    }\n                },\n            )\n            # Ajout des param\u00e8tres au noeud d'int\u00e9ret\n            parameters.prelevements_sociaux.reductions_cotisations_sociales.add_child(\n                \"convexe_fillon\", reform_parameters_subtree\n            )\n\n            return parameters\n\n        # D\u00e9finition de la classe de r\u00e9forme\n        class StructuralReformConvexeFillon(Reform):\n            name = \"Ajout d'un nouvel all\u00e8gement g\u00e9n\u00e9ral de type 'All\u00e8gement Fillon' dont la convexit\u00e9 est modifi\u00e9e\"\n\n            # Application de la r\u00e9forme\n            def apply(self):\n                # Ajout des param\u00e8tres des all\u00e8gements de cotisation\n                self.modify_parameters(\n                    modifier_function=modify_convexe_fillon_parameters\n                )\n                # Ajout de la variable \u00e0 calculer\n                self.add_variable(new_allegement_convexe_fillon)\n\n        # Application de la r\u00e9forme au syst\u00e8me socio-fiscal\n        reformed_tax_benefit_system = StructuralReformConvexeFillon(tax_benefit_system)\n\n        return reformed_tax_benefit_system\n\n    elif dict_params[\"TYPE\"] == \"allocations_familiales\":\n\n        # D\u00e9finition de la fonction de modification des param\u00e8tres\n        def modify_new_allocations_familiales_parameters(parameters):\n            # D\u00e9finition des param\u00e8tres \u00e0 ajouter\n            reform_parameters_subtree = ParameterNode(\n                name=\"new_allegement_cotisation_allocations_familiales\",\n                data={\n                    \"plafond_smic\": {\n                        \"values\": {period: {\"value\": dict_params[\"PARAMS\"][\"PLAFOND\"]}}\n                    },\n                    \"reduction\": {\n                        \"values\": {period: {\"value\": dict_params[\"PARAMS\"][\"TAUX\"]}}\n                    },\n                },\n            )\n            # Ajout des param\u00e8tres au noeud d'int\u00e9ret\n            parameters.prelevements_sociaux.reductions_cotisations_sociales.add_child(\n                \"new_allegement_cotisation_allocations_familiales\",\n                reform_parameters_subtree,\n            )\n\n            return parameters\n\n        # D\u00e9finition de la classe de r\u00e9forme\n        class StructuralReformAllocationsFamiliales(Reform):\n            name = \"Ajout d'un nouvel all\u00e8gement g\u00e9n\u00e9ral de type 'All\u00e8gement cotisations allocations familiales'\"\n\n            # Application de la r\u00e9forme\n            def apply(self):\n                # Ajout des param\u00e8tres des all\u00e8gements de cotisation\n                self.modify_parameters(\n                    modifier_function=modify_new_allocations_familiales_parameters\n                )\n                # Ajout de la variable \u00e0 calculer\n                self.add_variable(new_allegement_allocations_familiales)\n\n        # Application de la r\u00e9forme du syst\u00e8me socio-fiscal\n        reformed_tax_benefit_system = StructuralReformAllocationsFamiliales(\n            tax_benefit_system\n        )\n\n        return reformed_tax_benefit_system\n\n    elif dict_params[\"TYPE\"] == \"maladie\":\n        # D\u00e9finition de la fonction de modification des param\u00e8tres\n        def modify_new_maladie_parameters(parameters):\n            # D\u00e9finition des param\u00e8tres \u00e0 ajouter\n            reform_parameters_subtree = ParameterNode(\n                name=\"new_mmid\",\n                data={\n                    \"plafond\": {\n                        \"values\": {period: {\"value\": dict_params[\"PARAMS\"][\"PLAFOND\"]}}\n                    },\n                    \"taux\": {\n                        \"values\": {period: {\"value\": dict_params[\"PARAMS\"][\"TAUX\"]}}\n                    },\n                },\n            )\n            # Ajout des param\u00e8tres au noeud d'int\u00e9ret\n            parameters.prelevements_sociaux.reductions_cotisations_sociales.add_child(\n                \"new_mmid\", reform_parameters_subtree\n            )\n\n            return parameters\n\n        # D\u00e9finition de la classe de r\u00e9forme\n        class StructuralReformMaladie(Reform):\n            name = \"Ajout d'un nouvel all\u00e8gement g\u00e9n\u00e9ral de type 'All\u00e8gement cotisations maladie'\"\n\n            # Application de la r\u00e9forme\n            def apply(self):\n                # Ajout des param\u00e8tres des all\u00e8gements de cotisation\n                self.modify_parameters(modifier_function=modify_new_maladie_parameters)\n                # Ajout de la variable \u00e0 calculer\n                self.add_variable(new_allegement_cotisation_maladie)\n\n        # Application de la r\u00e9forme du syst\u00e8me socio-fiscal\n        reformed_tax_benefit_system = StructuralReformMaladie(tax_benefit_system)\n\n        return reformed_tax_benefit_system\n    else:\n        raise ValueError(\n            \"Unknown allegement type : should be in ['fillon', 'allocations_familiales', 'maladie']\"\n        )\n</code></pre>"},{"location":"api/load_dads/","title":"load_dads","text":""},{"location":"api/load_dads/#bozio_wasmer_simulations.datasets.loaders.load_dads","title":"load_dads","text":"<pre><code>load_dads(project: str, year: int, columns: List[str], filters: Optional[List[Tuple[str, str, str]]] = None)\n</code></pre> <p>Loads the DADS data for a given year.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The name of the CASD project</p> required <code>year</code> <code>int</code> <p>The year of the data to load.</p> required <code>columns</code> <code>List[str]</code> <p>The columns to load.</p> required <code>filters</code> <code>Optional[List[Tuple[str, str, str]]]</code> <p>The filters to apply. Each filter is a tuple of (column, operator, value). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is not available for the given year.</p> Source code in <code>bozio_wasmer_simulations/datasets/loaders.py</code> <pre><code>def load_dads(\n    project: str, year: int, columns: List[str], filters: Optional[List[Tuple[str, str, str]]] = None\n):\n    \"\"\"\n    Loads the DADS data for a given year.\n\n    Args:\n        project (str): The name of the CASD project\n        year (int): The year of the data to load.\n        columns (List[str]): The columns to load.\n        filters (Optional[List[Tuple[str, str, str]]], optional): The filters to apply. Each filter is a tuple of (column, operator, value). Defaults to None.\n\n    Returns:\n        (pd.DataFrame): The loaded data.\n\n    Raises:\n        ValueError: If the data is not available for the given year.\n    \"\"\"\n    # Initialisation du loader\n    loader = Loader()\n    # Distinction selon l'ann\u00e9e\n    if year &lt; 2018:\n        # Variables \u00e0 conserver lors de l'import\n        columns = [e.upper() for e in columns]\n        # Initialisation de la liste r\u00e9sultat\n        list_data_dads = []\n        # Chemin d'acc\u00e8s aux donn\u00e9es\n        table_path = f\"\\\\\\casd.fr\\\\casdfs\\\\Projets\\\\{project}\\\\Data\\\\DADS_DADS Postes_{year}\\\\R\u00e9gions\"\n        # Importation des diff\u00e9rentes tables\n        for i in tqdm([24, 27, 28, 32, 44, 52, 53, 75, 76, 84, 93, 94, 97, 99]):\n            # Nom du jeu de donn\u00e9es\n            table_name = f\"post{i}.sas7bdat\"\n            # Importation des donn\u00e9es\n            list_data_dads.append(\n                loader.load(\n                    path=os.path.join(table_name, table_path),\n                    columns=columns,\n                    filters=filters,\n                )\n            )\n        # Concat\u00e9nation des donn\u00e9es\n        data_dads = pd.concat(list_data_dads, axis=0, ignore_index=True)\n\n    elif (year &gt;= 2018) &amp; (year &lt; 2020):\n        # Variables \u00e0 conserver lors de l'import\n        columns = [e.upper() for e in columns]\n        # Initialisation de la liste r\u00e9sultat\n        list_data_dads = []\n        # Chemin d'acc\u00e8s aux donn\u00e9es\n        table_path = f\"\\\\\\casd.fr\\\\casdfs\\\\Projets\\\\{project}\\\\Data\\\\DADS_DADS Postes_{year}\"\n        # Importation des diff\u00e9rentes tables\n        for i in tqdm(range(1, 5)):\n            # Nom du jeu de donn\u00e9es\n            table_name = f\"post_{i}.sas7bdat\"\n            # Importation des donn\u00e9es\n            list_data_dads.append(\n                loader.load(\n                    path=os.path.join(table_name, table_path),\n                    columns=columns,\n                    filters=filters,\n                )\n            )\n        # Concat\u00e9nation des donn\u00e9es\n        data_dads = pd.concat(list_data_dads, axis=0, ignore_index=True)\n    # Chemin d'acc\u00e8s aux donn\u00e9es\n    elif (year &gt;= 2020) &amp; (year &lt; 2022):\n        # Variables \u00e0 conserver lors de l'import\n        columns = [e.lower() for e in columns]\n        # Chemin\n        table_path = f\"\\\\\\casd.fr\\\\casdfs\\\\Projets\\\\{project}\\\\Data\\\\DADS_DADS Postes_{year}\\\\Format parquet\"\n        # Chargement des donn\u00e9es\n        data_dads = loader.load(path=table_path, columns=columns, filters=filters)\n    elif year == 2022:\n        # Variables \u00e0 conserver lors de l'import\n        columns = [e.lower() for e in columns]\n        # Chemin\n        table_path = f\"\\\\\\casd.fr\\\\casdfs\\\\Projets\\\\{project}\\\\Data\\\\DADS_DADS Postes_{year}\"\n        # Enum\u00e9ration des fichiers\n        list_files = os.listdir(table_path)\n\n        # Restriction aux fichiers parquet relatifs \u00e0 l'ann\u00e9e 2022\n        data_dads = pd.concat(\n            (\n                loader.load(\n                    path=f\"{table_path}\\\\{file}\", columns=columns, filters=filters\n                )\n                for file in list_files\n                if ((file.endswith(\".parquet\")) &amp; (str(year) in file))\n            ),\n            axis=0,\n            join=\"outer\",\n            ignore_index=True,\n        )\n    else:\n        raise ValueError(f\"Data not available for year : {year}\")\n        # data_dads = pd.read_parquet(table_path, columns=columns, filters=filters)\n    return data_dads\n</code></pre>"},{"location":"api/load_fare/","title":"load_fare","text":""},{"location":"api/load_fare/#bozio_wasmer_simulations.datasets.loaders.load_fare","title":"load_fare","text":"<pre><code>load_fare(project: str, year: int, columns: List[str], filters: Optional[List[Tuple[str, str, str]]] = None)\n</code></pre> <p>Loads the FARE data for a given year.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str) </code> <p>The name of the CASD project</p> required <code>year</code> <code>int</code> <p>The year of the data to load.</p> required <code>columns</code> <code>List[str]</code> <p>The columns to load.</p> required <code>filters</code> <code>Optional[List[Tuple[str, str, str]]]</code> <p>The filters to apply. Each filter is a tuple of (column, operator, value). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The loaded data.</p> Source code in <code>bozio_wasmer_simulations/datasets/loaders.py</code> <pre><code>def load_fare(\n    project : str, year: int, columns: List[str], filters: Optional[List[Tuple[str, str, str]]] = None\n):\n    \"\"\"\n    Loads the FARE data for a given year.\n\n    Args:\n        project (str) : The name of the CASD project\n        year (int): The year of the data to load.\n        columns (List[str]): The columns to load.\n        filters (Optional[List[Tuple[str, str, str]]], optional): The filters to apply. Each filter is a tuple of (column, operator, value). Defaults to None.\n\n    Returns:\n        (pd.DataFrame): The loaded data.\n    \"\"\"\n    # Distinction du chemin selon l'ann\u00e9e\n    # Les donn\u00e9es post\u00e9rieures \u00e0 2021 n'\u00e9tant pas disponibles, ce mill\u00e9sime est retenu en dernier ressort\n    if year &lt; 2022:\n        # Chemin d'acc\u00e8s aux donn\u00e9es\n        table_path = f\"\\\\\\casd.fr\\\\casdfs\\\\Projets\\\\{project}\\\\Data\\\\Statistique annuelle d'entreprise_FARE_{year}\"\n        # Nom du jeu de donn\u00e9es\n        table_name = f\"FARE{year}METH{year}.sas7bdat\"\n    else:\n        # Chemin d'acc\u00e8s aux donn\u00e9es\n        table_path = f\"\\\\\\casd.fr\\\\casdfs\\\\Projets\\\\{project}\\\\Data\\\\Statistique annuelle d'entreprise_FARE_2021\"\n        # Nom du jeu de donn\u00e9es\n        table_name = f\"FARE2021METH2021.sas7bdat\"\n    # Initialisation du loader\n    loader = Loader()\n    # Chargement des donn\u00e9es\n    data_fare = loader.load(\n        path=os.path.join(table_path, table_name), columns=columns, filters=filters\n    )\n\n    return data_fare\n</code></pre>"},{"location":"api/preprocess_dads_openfisca_ag/","title":"preprocess_dads_openfisca_ag","text":""},{"location":"api/preprocess_dads_openfisca_ag/#bozio_wasmer_simulations.simulation.empirical.preprocessing.preprocess_dads_openfisca_ag","title":"preprocess_dads_openfisca_ag","text":"<pre><code>preprocess_dads_openfisca_ag(data_dads: DataFrame, year: int, list_zonage_zrr: List[str], list_zonage_zrd: List[str]) -&gt; DataFrame\n</code></pre> <p>Preprocesses the data to make it compatible with Openfisca for simulating general exemptions.</p> <p>Parameters:</p> Name Type Description Default <code>data_dads</code> <code>DataFrame</code> <p>The input data.</p> required <code>year</code> <code>int</code> <p>The year for which the data is being processed.</p> required <code>list_zonage_zrr</code> <code>List[str]</code> <p>A list of codes for rural revitalization zones.</p> required <code>list_zonage_zrd</code> <code>List[str]</code> <p>A list of codes for defense restructuring zones.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The preprocessed data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/preprocessing.py</code> <pre><code>def preprocess_dads_openfisca_ag(\n    data_dads: pd.DataFrame,\n    year: int,\n    list_zonage_zrr: List[str],\n    list_zonage_zrd: List[str],\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Preprocesses the data to make it compatible with Openfisca for simulating general exemptions.\n\n    Args:\n        data_dads (pd.DataFrame):\n            The input data.\n        year (int):\n            The year for which the data is being processed.\n        list_zonage_zrr (List[str]):\n            A list of codes for rural revitalization zones.\n        list_zonage_zrd (List[str]):\n            A list of codes for defense restructuring zones.\n\n    Returns:\n        (pd.DataFrame): The preprocessed data.\n    \"\"\"\n    # Construction de colonnes d'int\u00e9r\u00eat\n\n    # Cr\u00e9ation d'une pcs \u00e0 deux chiffres\n    data_dads[\"pcs_2\"] = data_dads[\"pcs\"].str[:2]\n    # Conversion de la de la date de d\u00e9but de contrat de travail en datetime\n    data_dads[\"date_fin_contrat\"] = (\n        pd.to_datetime(f\"{year}-01-01\", format=\"%Y-%m-%d\")\n        + pd.to_timedelta(arg=data_dads[\"datfin\"], unit=\"D\")\n    ).dt.strftime(\"%Y-%m-%d\")\n    # Conversion en string\n    data_dads[\"date_debut_contrat\"] = (\n        pd.to_datetime(data_dads[\"date_debut_contrat\"], format=\"%Y-%m-%d\")\n        .dt.strftime(\"%Y-%m-%d\")\n        .fillna(\"1970-01-01\")\n    )\n\n    # Secteur d'activite employeur (prend les valeurs 'agricole', 'non agricole' et 'non_renseign\u00e9')\n    data_dads[\"secteur_activite_employeur\"] = np.where(\n        data_dads[\"a88\"] == \"01\",\n        TypesSecteurActivite.agricole,\n        TypesSecteurActivite.non_agricole,\n    )\n    # Travailleur occasionnel agricole\n    tode_condition = (data_dads[\"a88\"] == \"01\") &amp; data_dads[\"motifcdd\"].isin(\n        [\"03\", \"04\"]\n    )\n    data_dads[\"exoneration_cotisations_employeur_tode_eligibilite\"] = np.where(\n        tode_condition, True, False\n    )\n    data_dads[\"choix_exoneration_cotisations_employeur_agricole\"] = np.where(\n        tode_condition, True, False\n    )\n    data_dads[\"travailleur_occasionnel_agricole\"] = np.where(\n        tode_condition, True, False\n    )\n    # Indicatrices de zonage\n    data_dads[\"zone_restructuration_defense\"] = data_dads[\"comt\"].isin(list_zonage_zrd)\n    data_dads[\"zone_revitalisation_rurale\"] = data_dads[\"comt\"].isin(list_zonage_zrr)\n\n    # Cat\u00e9gorie du salari\u00e9 (prend des valeurs parmi 'prive_non_cadre', 'prive_cadre', 'public_titulaire_etat', 'public_titulaire_militaire', 'public_titulaire_territoriale', 'public_titulaire_hospitaliere', 'public_non_titulaire', 'non_pertinent')\n    # On ne s'int\u00e9resse qu'au statut cadre/non cadre\n    # 'domempl_empl' in ['1', '2', '3'],\n    # 'nat_contrat'=='50' 104929\n    data_dads[\"categorie_salarie\"] = np.where(\n        data_dads[\"pcs_2\"] == \"37\",\n        TypesCategorieSalarie.prive_cadre,\n        TypesCategorieSalarie.prive_non_cadre,\n    )\n    # Contrat de travail (prend des valeurs parmi 'temps_plein', 'temps_partiel', 'forfait_heures_semaines', 'forfait_heures_mois', 'forfait_heures_annee', 'forfait_jours_annee', 'sans_objet')\n    # On se restreint \u00e0 l'impl\u00e9mentattion de 'temps_plein', 'temps_partiel'\n    data_dads[\"contrat_de_travail\"] = np.where(\n        data_dads[\"eqtp\"] &lt; 1,\n        TypesContratDeTravail.temps_partiel,\n        TypesContratDeTravail.temps_plein,\n    )\n    data_dads[\"contrat_de_travail_fin\"] = np.where(\n        data_dads[\"datfin\"] &lt; 360, data_dads[\"date_fin_contrat\"], \"2099-12-31\"\n    )\n    # Ajout du type de contrat de travail\n    data_dads[\"contrat_de_travail_type\"] = (\n        data_dads[\"nat_contrat\"].map(dict_nat_type_contrat).fillna(TypesContrat.cdi)\n    )\n    # R\u00e9gime Alsace-Moselle\n    data_dads[\"salarie_regime_alsace_moselle\"] = np.where(\n        data_dads[\"dept\"].isin([\"57\", \"67\", \"68\"]), True, False\n    )\n\n    # Variables construites suivant le statut d'apprenti\n    apprenti_condition = data_dads[\"contrat_travail\"].isin([\"04\", \"05\"])\n    # Construction de la r\u00e9mun\u00e9ration\n    data_dads[\"salaire_de_base\"] = np.where(apprenti_condition, 0, data_dads[\"brut_s\"])\n    data_dads[\"remuneration_apprenti\"] = np.where(\n        apprenti_condition, data_dads[\"brut_s\"], 0\n    )\n    # Date de d\u00e9but du contrat d'apprentissage\n    data_dads[\"apprentissage_contrat_debut\"] = np.where(\n        apprenti_condition, data_dads[\"date_debut_contrat\"], \"1970-01-01\"\n    )\n    # Statut d'apprenti\n    data_dads[\"apprenti\"] = np.where(apprenti_condition, True, False)\n\n    # Variables construites suivant le statut de stagiaire\n    stagiaire_condition = data_dads[\"nat_contrat\"] == \"29\"\n    # Nombre d'heures effectu\u00e9es en stage\n    data_dads[\"stage_duree_heures\"] = np.where(\n        stagiaire_condition, data_dads[\"nbheur\"], 0\n    )\n    # Gratification\n    data_dads[\"stage_gratification\"] = np.where(\n        stagiaire_condition, data_dads[\"salaire_de_base\"], 0\n    )\n    data_dads[\"salaire_de_base\"] = np.where(\n        stagiaire_condition, 0, data_dads[\"salaire_de_base\"]\n    )\n\n    # Ajout des taux de versement transport\n    # data_dads['taux_versement_transport'] = 0.032\n    # Ajout des taux d'accident du travail\n    data_dads[\"taux_accident_travail\"] = 0.0212\n\n    # Ajout de l'effectif de l'entreprise\n    data_dads = pd.merge(\n        left=data_dads,\n        right=data_dads.groupby([\"siren\"], as_index=False)[\"eqtp\"]\n        .sum()\n        .rename({\"eqtp\": \"effectif_entreprise\"}, axis=1),\n        on=\"siren\",\n        how=\"left\",\n        validate=\"many_to_one\",\n    )\n\n    # Variables identiques \u00e0 celles des DADS\n    data_dads.rename(\n        {\n            \"comr\": \"depcom\",\n            \"comt\": \"depcom_entreprise\",\n            \"date_debut_contrat\": \"contrat_de_travail_debut\",\n            \"nbheur\": \"heures_remunerees_volume\",\n            \"pepa\": \"prime_exceptionnelle_pouvoir_achat\",\n        },\n        axis=1,\n        inplace=True,\n    )  # 'eqtp' : 'quotite_de_travail',\n    # Ajout de la PPV si l'ann\u00e9e de r\u00e9f\u00e9rence est bien 2022\n    if year == 2022:\n        data_dads.rename(\n            {\n                \"ppv_defisc\": \"prime_partage_valeur_exoneree\",\n                \"ppv_ndefisc\": \"prime_partage_valeur_non_exoneree\",\n            },\n            axis=1,\n            inplace=True,\n        )\n        data_dads[\"prime_partage_valeur_exoneree\"] = data_dads[\n            \"prime_partage_valeur_exoneree\"\n        ].fillna(0)\n        data_dads[\"prime_partage_valeur_non_exoneree\"] = data_dads[\n            \"prime_partage_valeur_non_exoneree\"\n        ].fillna(0)\n\n    # Compl\u00e9tion des Nan\n    data_dads[[\"depcom\", \"depcom_entreprise\"]] = data_dads[\n        [\"depcom\", \"depcom_entreprise\"]\n    ].fillna(\"\")\n    # data_dads['quotite_de_travail'] = data_dads['quotite_de_travail'].fillna(1)\n    data_dads[\"salaire_de_base\"] = data_dads[\"salaire_de_base\"].fillna(0)\n\n    return data_dads\n</code></pre>"},{"location":"api/preprocess_simulated_variables/","title":"preprocess_simulated_variables","text":""},{"location":"api/preprocess_simulated_variables/#bozio_wasmer_simulations.simulation.empirical.preprocessing.preprocess_simulated_variables","title":"preprocess_simulated_variables","text":"<pre><code>preprocess_simulated_variables(data: DataFrame) -&gt; DataFrame\n</code></pre> <p>Post-processes the simulated variables.</p> <p>Calculates the total exemptions, total reductions, and total exemptions and reductions. Corrects the unemployment benefits and calculates the gross salary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The input data with simulated variables.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The post-processed data.</p> Source code in <code>bozio_wasmer_simulations/simulation/empirical/preprocessing.py</code> <pre><code>def preprocess_simulated_variables(data: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Post-processes the simulated variables.\n\n    Calculates the total exemptions, total reductions, and total exemptions and reductions.\n    Corrects the unemployment benefits and calculates the gross salary.\n\n    Args:\n        data (pd.DataFrame):\n            The input data with simulated variables.\n\n    Returns:\n        (pd.DataFrame): The post-processed data.\n    \"\"\"\n    # Somme des exon\u00e9rations\n    data[\"exonerations\"] = (\n        data[\n            [\n                \"exoneration_cotisations_employeur_apprenti\",\n                \"exoneration_cotisations_employeur_jei\",\n                \"exoneration_cotisations_employeur_zrd\",\n                \"exoneration_cotisations_employeur_zrr\",\n                \"exoneration_cotisations_employeur_stagiaire\",\n            ]\n        ].sum(axis=1)\n        - data[\"exoneration_cotisations_employeur_tode\"]\n    )\n    # Somme des all\u00e8gements\n    data[\"allegements\"] = data[\n        [\n            \"allegement_general\",\n            \"allegement_cotisation_maladie\",\n            \"allegement_cotisation_allocations_familiales\",\n        ]\n    ].sum(axis=1)\n    # Somme des exon\u00e9rations et all\u00e8gements\n    data[\"exonerations_et_allegements\"] = data[[\"exonerations\", \"allegements\"]].sum(\n        axis=1\n    )\n    # Correction des allocations chomages\n    data[\"cotisations_employeur\"] = (\n        data[\"cotisations_employeur\"]\n        - data[\"chomage_employeur\"]\n        - data[\"assiette_cotisations_sociales\"] * 0.0405\n        - data[\n            [\n                \"allegement_cotisation_maladie\",\n                \"allegement_cotisation_allocations_familiales\",\n            ]\n        ].sum(axis=1)\n    )\n    # Extraction des bandeaux de la variable hors allegements\n    data[\"salaire_super_brut_hors_allegements\"] = (\n        data[\"salaire_super_brut_hors_allegements\"]\n        - data[\"chomage_employeur\"]\n        - data[\"assiette_cotisations_sociales\"] * 0.0405\n        + data[\n            [\n                \"allegement_cotisation_maladie\",\n                \"allegement_cotisation_allocations_familiales\",\n            ]\n        ].sum(axis=1)\n    )\n    # Suppression de la colonne \"chomage_employeur\"\n    # data.drop('chomage_employeur', axis=1, inplace=True)\n    # Calcul du salaire super brut\n    data[\"salaire_super_brut\"] = (\n        data[\"salaire_super_brut_hors_allegements\"]\n        - data[\"exonerations_et_allegements\"]\n        + data[\"prime_partage_valeur_exoneree\"]\n    )\n\n    return data\n</code></pre>"},{"location":"concepts/EMPLOYMENT_EFFECTS/","title":"Methodology underlying the estimation of the effects of reforms on employment","text":"<p>The effect of a reform of payroll tax reductions on employment is estimated applying an elasticity of employment to its cost, both at the individual and company level. In other words, the employment response of employers to a reform is supposed to depend not only on how much the individual labor cost of each contract has changed, but also on how much the firm total labor cost is impacted by the new payroll tax reduction scheme. </p>"},{"location":"concepts/EMPLOYMENT_EFFECTS/#modeling-of-the-employment-effect-of-a-reform","title":"Modeling of the employment effect of a reform","text":"<p>Let \\(LC_{s,f,sim}\\) denote the simulated labor cost and \\(LC_{s,f,0}\\) the initial labor cost, applicable to the employee \\(s\\) employed in  firm \\(f\\), and \\(\\partial LC_{s,f}\\) is the overall percentage change in the labor cost of this group of workers. The labor cost affects the level of employment according to an elasticity \\(\\epsilon^{'}_{w(s)}\\) of wage earners \\(s\\) with wage \\(w(s)\\), which is decreasing with the wage level. </p> <p>In addition to the individual labor cost, we also consider the effect of the overall percentage change in labor cost within firm \\(f\\) noted \\(\\partial MS_f = \\sum_{s \\in f} \\left( LC_{s,f,sim} - LC_{f,s,0} \\right)\\) at which employment is assumed to be elastic too (we denote \\(\\mu\\) this elasticity, constant with wage). </p> <p>Following this approach, the employment effect of a variation in labor cost is written as follows: \\( Employment \\; effect= \\sum_f \\sum_s \\left( \\partial LC_{s,f} \\times \\epsilon^{'}_{w(s)} + \\partial MS_f \\times \\mu \\right) \\) </p> <p>For example, for a company with a single type of employee who earns wage \\(w\\) and \\(N(w)\\) employees, the formula simply becomes: \\( Employment \\; effect= N(w) \\partial LC_{s,f} \\times \\epsilon^{'}_{w(s)} + N(w) \\partial MS_f \\times \\mu \\)</p>"},{"location":"concepts/EMPLOYMENT_EFFECTS/#elasticity-function","title":"Elasticity function","text":"<p>This elasticity depends only on the individual's gross salary level.</p> <p>Its form is constrained and is that of a affine function below a certain threshold and a constant function above. It can thus be defined by three parameters:</p> <ul> <li><code>y0_elasticite</code>, which designates the y-intercept (i.e. the effect on employment of a variation in the cost of labor at the minimum wage);</li> <li><code>seuil_pallier_elasticite_smic</code>: the wage level (expressed in multiples of the minimum wage) above which the elasticity of employment to its cost becomes constant;</li> <li><code>pallier_elasticite</code>: the level of elasticity once the threshold has been reached.</li> </ul> <p></p>"},{"location":"concepts/MARGINAL_CAPTATION_RATE/","title":"Estimating incentives to raise wages","text":"<p>The concept of the marginal effective tax rate (METR) is key in our simulations to measure the incentives of the employer to raise its employees wages'.  The METR refers to the fraction, let's call it \\(C\\), of a certain increase in the employer's labor cost received by the employee.  Noting \\(S_{CT}\\) as the net wage associated with a labor cost \\(CT\\) for the employer, for a variation in labor cost \\(\\delta\\), the marginal capture rate can be expressed as : \\(C = \\frac{S_{CT+\\delta} - S_{CT}}{\\delta} \\)  Thus, an effective rate of 70% leads to an increase in payroll costs of \u20ac100 to distribute an additional \u20ac30 to the employee, once we've taken into account: the additional employer and employee contributions.</p> <p>In our empirical simulations the marginal effective tax rate is calculated with a step of \u20ac317 corresponding to an increase of the gross salary of 0.01 minimum wage.</p>"},{"location":"concepts/SIMULATIONS/","title":"Methodology underlying the estimation of the effects of reforms","text":"<p>The main goal of this package is to simulate different payroll tax reductions and compare labor cost before and after changing the tax reduction rules applicable in 2023.</p>"},{"location":"concepts/SIMULATIONS/#data","title":"Data","text":"<p>Simulations are iterated on the \"Base Tous Salari\u00e9s, Postes\" of the  D\u00e9clarations Annuelles de Donn\u00e9es Sociales (DADS, see documentation).</p>"},{"location":"concepts/SIMULATIONS/#simulation-module","title":"Simulation module","text":"<p>We use version 166.1.5 of the <code>openfisca-france</code> package to simulate all the employers contributions and payroll tax reductions applicable to each employee. These simulations make it possible to deduce a labor cost associated with each individual.  A reform module is then used to simulate a set of alternative payroll tax reductions and deduce a new labor cost. These new reductions can take the form of :</p> <ul> <li>a \"Fillon\" payroll tax reduction with parameters \\(\\left( rate_{max}, ceiling \\right)\\) : \\(rate = \\frac{rate_{max}}{ceiling -1} \\times \\left( ceiling \\times \\frac{Gross \\;Minimum \\; Wage}{Gross \\; Salary} -1 \\right)\\)</li> <li>a \"Convexe Fillon\" payroll tax reduction with parameters \\(\\left( rate_{max}, ceiling, exponent \\right)\\) : \\(rate = rate_{max} \\times \\left[ \\frac{ceiling \\times \\frac{Gross \\;Minimum \\; Wage}{Gross \\; Salary} -1}{ceiling -1}  \\right]^{exponent}\\)</li> <li>a \"Family\" or \"Illness\" payroll tax reduction with parameters \\(\\left( rate_{max}, ceiling \\right)\\): \\(rate = \\mathbb{1}_{Gross \\; Salary \\leq ceiling} \\times rate_{max}\\)</li> </ul>"},{"location":"concepts/SIMULATIONS/#perimeter","title":"Perimeter","text":"<p>With the default parameters, simulations are iterated on the main employment period [1] of private sector employees (excluding those of \"particuliers employeurs\" - individual employers), aged 18 to 64 and employed in mainland France. These observations are then re-weighted on the basis of ACOSS distribution of employees by gross wage bins.</p> <p>The following tax reductions have been simulated: - TODE,  - Apprentice,  - Trainee,  - Young Innovative Company (JEI), - Defense Restructuring Zone (ZRD), - Rural Revitalization Zone (ZRR). </p> <p>However, the following tax reduction is ignored: - \"Zone Franche Urbaine (ZFU)\"</p> <p>By default, employees to whom one of these tax reductions applies are not affected by a simulated reform.</p>"},{"location":"concepts/SIMULATIONS/#warnings","title":"Warnings","text":"<p>Compared with version 166.1.5 of the <code>openfisca-france</code> package, <code>chomage_employeur</code> contributions have been modified so that they always amount to 4.5% of the social security contribution base.</p> <p>This correction, currently implemented in this package's code, will be included in a future PR on <code>openfisca-france</code>. Hence, using a later version of <code>openfisca-france</code> may lead to over-corrections.</p> <p>[1]: the continuum of employment contracts with the highest net salary for each employee</p>"}]}